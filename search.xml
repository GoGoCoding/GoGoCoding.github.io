<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis 事务</title>
      <link href="/2021/05/01/Redis/Redis%20%E4%BA%8B%E5%8A%A1/"/>
      <url>/2021/05/01/Redis/Redis%20%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>Redis 是没有回滚机制的，通过 WATCH、MULTI、EXEC、DISCARD 四个命令，勉强实现了原子性、一致性和隔离性，因为是内存缓存，所以持久性是没法保证的。</p><h1 id="原子性"><a class="markdownIt-Anchor" href="#原子性"></a> 原子性</h1><ul><li>命令入队时就报错，会放弃事务执行，保证原子性；</li><li>命令入队时没报错，实际执行时报错，不保证原子性；</li><li>EXEC 命令执行时实例故障，如果开启了 AOF 日志，可以保证原子性。</li></ul><h1 id="一致性"><a class="markdownIt-Anchor" href="#一致性"></a> 一致性</h1><ul><li>命令入队时就报错，在这种情况下，事务本身就会被放弃执行，所以可以保证数据库的一致性</li><li>命令入队时没报错，实际执行时报错，在这种情况下，有错误的命令不会被执行，正确的命令可以正常执行，也不会改变数据库的一致性。</li><li>EXEC 命令执行时实例发生故障，Redis 事务机制对一致性属性是有保证的</li></ul><h1 id="隔离性"><a class="markdownIt-Anchor" href="#隔离性"></a> 隔离性</h1><ul><li>可以通过WATCH 机制提供事务隔离性。</li></ul><h1 id="持久性"><a class="markdownIt-Anchor" href="#持久性"></a> 持久性</h1><p>因为 Redis 是内存数据库，所以，数据是否持久化保存完全取决于 Redis 的持久化配置模式。<br />如果 Redis 没有使用 RDB 或 AOF，那么事务的持久化属性肯定得不到保证。如果 Redis 使用了 RDB 模式，那么，在一个事务执行后，而下一次的 RDB 快照还未执行前，如果发生了实例宕机，这种情况下，事务修改的数据也是不能保证持久化的。如果 Redis 采用了 AOF 模式，因为 AOF 模式的三种配置选项 no、everysec 和 always 都会存在数据丢失的情况，所以，事务的持久性属性也还是得不到保证。所以，不管 Redis 采用什么持久化模式，事务的持久性属性是得不到保证的。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Q&amp;A</title>
      <link href="/2021/04/06/Redis/Redis%20Q&amp;A/"/>
      <url>/2021/04/06/Redis/Redis%20Q&amp;A/</url>
      
        <content type="html"><![CDATA[<h1 id="问题1和跟-redis-相比simplekv-还缺少什么"><a class="markdownIt-Anchor" href="#问题1和跟-redis-相比simplekv-还缺少什么"></a> 问题1：和跟 Redis 相比，SimpleKV 还缺少什么？</h1><p><img src="http://qiniu.gogocoding.cn/mweb/simpleKV%20vs%20Redis.jpg" alt="simpleKV vs Redis" /></p><h1 id="问题2整数数组和压缩列表作为底层数据结构的优势是什么"><a class="markdownIt-Anchor" href="#问题2整数数组和压缩列表作为底层数据结构的优势是什么"></a> 问题2：整数数组和压缩列表作为底层数据结构的优势是什么？</h1><p>整数数组和压缩列表的设计，充分体现了 Redis“又快又省”特点中的“省”，也就是节省内存空间。整数数组和压缩列表都是在内存中分配一块地址连续的空间，然后把集合中的元素一个接一个地放在这块空间内，非常紧凑。因为元素是挨个连续放置的，我们不用再通过额外的指针把元素串接起来，这就避免了额外指针带来的空间开销。<br />Redis 之所以采用不同的数据结构，其实是在性能和内存使用效率之间进行的平衡</p><h1 id="问题3redis-基本-io-模型中还有哪些潜在的性能瓶颈"><a class="markdownIt-Anchor" href="#问题3redis-基本-io-模型中还有哪些潜在的性能瓶颈"></a> 问题3：Redis 基本 IO 模型中还有哪些潜在的性能瓶颈？</h1><p>在 Redis 基本 IO 模型中，主要是主线程在执行操作，任何耗时的操作，例如 bigkey、全量返回等操作，都是潜在的性能瓶颈。</p><h1 id="问题-4aof-重写过程中有没有其他潜在的阻塞风险"><a class="markdownIt-Anchor" href="#问题-4aof-重写过程中有没有其他潜在的阻塞风险"></a> 问题 4：AOF 重写过程中有没有其他潜在的阻塞风险？</h1><p>风险一：Redis 主线程 fork 创建 bgrewriteaof 子进程时，内核需要创建用于管理子进程的相关数据结构，这些数据结构在操作系统中通常叫作进程控制块（Process Control Block，简称为 PCB）。内核要把主线程的 PCB 内容拷贝给子进程。这个创建和拷贝过程由内核执行，是会阻塞主线程的。而且，在拷贝过程中，子进程要拷贝父进程的页表，这个过程的耗时和 Redis 实例的内存大小有关。如果 Redis 实例内存大，页表就会大，fork 执行时间就会长，这就会给主线程带来阻塞风险。</p><p>风险二：bgrewriteaof 子进程会和主线程共享内存。当主线程收到新写或修改的操作时，主线程会申请新的内存空间，用来保存新写或修改的数据，如果操作的是 bigkey，也就是数据量大的集合类型数据，那么，主线程会因为申请大空间而面临阻塞风险。因为操作系统在分配内存空间时，有查找和锁的开销，这就会导致阻塞。</p><h1 id="问题-5aof-重写为什么不共享使用-aof-本身的日志"><a class="markdownIt-Anchor" href="#问题-5aof-重写为什么不共享使用-aof-本身的日志"></a> 问题 5：AOF 重写为什么不共享使用 AOF 本身的日志？</h1><p>如果都用 AOF 日志的话，主线程要写，bgrewriteaof 子进程也要写，这两者会竞争文件系统的锁，这就会对 Redis 主线程的性能造成影响。</p><h1 id="问题6为什么主从库间的复制不使用-aof"><a class="markdownIt-Anchor" href="#问题6为什么主从库间的复制不使用-aof"></a> 问题6：为什么主从库间的复制不使用 AOF？</h1><ol><li>RDB 文件是二进制文件，无论是要把 RDB 写入磁盘，还是要通过网络传输 RDB，IO 效率都比记录和传输 AOF 的高。</li><li>在从库端进行恢复时，用 RDB 的恢复效率要高于用 AOF。</li></ol><h1 id="问题-7在主从切换过程中客户端能否正常地进行请求操作呢"><a class="markdownIt-Anchor" href="#问题-7在主从切换过程中客户端能否正常地进行请求操作呢"></a> 问题 7：在主从切换过程中，客户端能否正常地进行请求操作呢？</h1><p>主从集群一般是采用读写分离模式，当主库故障后，客户端仍然可以把读请求发送给从库，让从库服务。但是，对于写请求操作，客户端就无法执行了。</p><h1 id="问题-8如果想要应用程序不感知服务的中断还需要哨兵或客户端再做些什么吗"><a class="markdownIt-Anchor" href="#问题-8如果想要应用程序不感知服务的中断还需要哨兵或客户端再做些什么吗"></a> 问题 8：如果想要应用程序不感知服务的中断，还需要哨兵或客户端再做些什么吗？</h1><p>一方面，客户端需要能缓存应用发送的写请求。只要不是同步写操作（Redis 应用场景一般也没有同步写），写请求通常不会在应用程序的关键路径上，所以，客户端缓存写请求后，给应用程序返回一个确认就行。<br />另一方面，主从切换完成后，客户端要能和新主库重新建立连接，哨兵需要提供订阅频道，让客户端能够订阅到新主库的信息。同时，客户端也需要能主动和哨兵通信，询问新主库的信息。</p><h1 id="问题-95-个哨兵实例的集群quorum-值设为-2-在运行过程中如果有-3-个哨兵实例都发生故障了此时redis-主库如果有故障还能正确地判断主库客观下线吗如果可以的话还能进行主从库自动切换吗"><a class="markdownIt-Anchor" href="#问题-95-个哨兵实例的集群quorum-值设为-2-在运行过程中如果有-3-个哨兵实例都发生故障了此时redis-主库如果有故障还能正确地判断主库客观下线吗如果可以的话还能进行主从库自动切换吗"></a> 问题 9：5 个哨兵实例的集群，quorum 值设为 2。在运行过程中，如果有 3 个哨兵实例都发生故障了，此时，Redis 主库如果有故障，还能正确地判断主库“客观下线”吗？如果可以的话，还能进行主从库自动切换吗？</h1><p>因为判定主库“客观下线”的依据是，认为主库“主观下线”的哨兵个数要大于等于 quorum 值，现在还剩 2 个哨兵实例，个数正好等于 quorum 值，所以还能正常判断主库是否处于“客观下线”状态。如果一个哨兵想要执行主从切换，就要获到半数以上的哨兵投票赞成，也就是至少需要 3 个哨兵投票赞成。但是，现在只有 2 个哨兵了，所以就无法进行主从切换了。</p><h1 id="问题-10哨兵实例是不是越多越好呢如果同时调大-down-after-milliseconds-值对减少误判是不是也有好处"><a class="markdownIt-Anchor" href="#问题-10哨兵实例是不是越多越好呢如果同时调大-down-after-milliseconds-值对减少误判是不是也有好处"></a> 问题 10：哨兵实例是不是越多越好呢？如果同时调大 down-after-milliseconds 值，对减少误判是不是也有好处？</h1><p>哨兵实例越多，误判率会越低，但是在判定主库下线和选举 Leader 时，实例需要拿到的赞成票数也越多，等待所有哨兵投完票的时间可能也会相应增加，主从库切换的时间也会变长，客户端容易堆积较多的请求操作，可能会导致客户端请求溢出，从而造成请求丢失。如果业务层对 Redis 的操作有响应时间要求，就可能会因为新主库一直没有选定，新操作无法执行而发生超时报警。</p><p>调大 down-after-milliseconds 后，可能会导致这样的情况：主库实际已经发生故障了，但是哨兵过了很长时间才判断出来，这就会影响到 Redis 对业务的可用性。</p><h1 id="问题11为什么-redis-不直接用一个表把键值对和实例的对应关系记录下来"><a class="markdownIt-Anchor" href="#问题11为什么-redis-不直接用一个表把键值对和实例的对应关系记录下来"></a> 问题11：为什么 Redis 不直接用一个表，把键值对和实例的对应关系记录下来？</h1><p>如果使用表记录键值对和实例的对应关系，一旦键值对和实例的对应关系发生了变化（例如实例有增减或者数据重新分布），就要修改表。如果是单线程操作表，那么所有操作都要串行执行，性能慢；如果是多线程操作表，就涉及到加锁开销。此外，如果数据量非常大，使用表记录键值对和实例的对应关系，需要的额外存储空间也会增加。基于哈希槽计算时，虽然也要记录哈希槽和实例的对应关系，但是哈希槽的个数要比键值对的个数少很多，无论是修改哈希槽和实例的对应关系，还是使用额外空间存储哈希槽和实例的对应关系，都比直接记录键值对和实例的关系的开销小得多。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Q&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切片集群</title>
      <link href="/2021/04/06/Redis/%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%EF%BC%8C%E6%98%AF%E8%AF%A5%E5%A2%9E%E5%8A%A0%E5%86%85%E5%AD%98%E8%BF%98%E6%98%AF%E5%8A%A0%E5%AE%9E%E4%BE%8B/"/>
      <url>/2021/04/06/Redis/%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%EF%BC%8C%E6%98%AF%E8%AF%A5%E5%A2%9E%E5%8A%A0%E5%86%85%E5%AD%98%E8%BF%98%E6%98%AF%E5%8A%A0%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="如何保存更多数据"><a class="markdownIt-Anchor" href="#如何保存更多数据"></a> 如何保存更多数据</h1><p>Redis 应对数据量增多的两种方案：纵向扩展（scale up）和横向扩展（scale out）。</p><ul><li><strong>纵向扩展</strong>：升级单个 Redis 实例的资源配置，包括增加内存容量、增加磁盘容量、使用更高配置的 CPU。就像下图中，原来的实例内存是 8GB，硬盘是 50GB，纵向扩展后，内存增加到 24GB，磁盘增加到 150GB。</li><li><strong>横向扩展</strong>：横向增加当前 Redis 实例的个数，就像下图中，原来使用 1 个 8GB 内存、50GB 磁盘的实例，现在使用三个相同配置的实例。</li></ul><p><img src="http://qiniu.gogocoding.cn/mweb/%E7%BA%B5%E5%90%91%E5%92%8C%E6%A8%AA%E5%90%91%E6%89%A9%E5%B1%95.jpg" alt="纵向和横向扩展" /></p><h1 id="数据切片和实例的对应分布关系"><a class="markdownIt-Anchor" href="#数据切片和实例的对应分布关系"></a> 数据切片和实例的对应分布关系</h1><p>Redis Cluster 方案采用哈希槽（Hash Slot，接下来我会直接称之为 Slot），来处理数据和实例之间的映射关系。在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。</p><p>具体的映射过程分为两大步：首先根据键值对的 key，按照CRC16 算法计算一个 16 bit 的值；然后，再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽</p><p>我们在部署 Redis Cluster 方案时，可以使用 cluster create 命令创建集群，此时，Redis 会自动把这些槽平均分布在集群实例上。例如，如果集群中有 N 个实例，那么，每个实例上的槽个数为 16384/N 个。</p><p>手动分配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 172.16.19.3 –p 6379 cluster addslots 0,1</span><br><span class="line">redis-cli -h 172.16.19.4 –p 6379 cluster addslots 2,3</span><br><span class="line">redis-cli -h 172.16.19.5 –p 6379 cluster addslots 4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 切片集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 概述</title>
      <link href="/2021/03/31/Redis/Redis/"/>
      <url>/2021/03/31/Redis/Redis/</url>
      
        <content type="html"><![CDATA[<p><img src="media/79da7093ed998a99d9abe91e610b74e7.jpg" alt="79da7093ed998a99d9abe91e610b74e7" /></p><p>“两大维度”就是指系统维度和应用维度，“三大主线”也就是指高性能、高可靠和高可扩展（可以简称为“三高”）</p><p>Redis涉及知识点可以按照这三大主线，给它们分下类，就像图片中展示的那样，具体如下：</p><ul><li><strong>高性能主线</strong>，包括线程模型、数据结构、持久化、网络框架；</li><li><strong>高可靠主线</strong>，包括主从复制、哨兵机制；</li><li><strong>高可扩展主线</strong>，包括数据分片、负载均衡。</li></ul><p>Redis 问题画像<br /><img src="media/%E7%94%BB%E5%83%8F.jpeg" alt="画像" /></p><p>Redis 中主要的数据类型和底层数据结构<br /><img src="media/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="数据结构" /></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis AOF</title>
      <link href="/2021/03/31/Redis/Redis%E5%AE%95%E6%9C%BA%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1/"/>
      <url>/2021/03/31/Redis/Redis%E5%AE%95%E6%9C%BA%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="宕机了redis如何避免数据丢失"><a class="markdownIt-Anchor" href="#宕机了redis如何避免数据丢失"></a> 宕机了，Redis如何避免数据丢失？</h1><ol><li>从后端数据库恢复这些数据</li><li>AOF（Append Only File）日志</li><li>RDB（Redis DataBase）快照</li></ol><h2 id="aof"><a class="markdownIt-Anchor" href="#aof"></a> AOF</h2><p>三种写回策略<br /><img src="http://qiniu.gogocoding.cn/mweb/%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5.jpg" alt="写回策略" /></p><p>这里主要存在以下三个方面的性能问题：</p><ol><li>文件系统本身对文件大小有限制，无法保存过大的文件；</li><li>如果文件太大，之后再往里面追加命令记录的话，效率也会变低；</li><li>如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到 Redis 的正常使用。</li></ol><h3 id="日志文件太大了怎么办"><a class="markdownIt-Anchor" href="#日志文件太大了怎么办"></a> 日志文件太大了怎么办？</h3><p><strong>重写机制</strong>： AOF 重写机制就是在重写时，Redis 根据数据库的现状创建一个新的 AOF 文件，也就是说，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入</p><h3 id="aof-重写会阻塞吗"><a class="markdownIt-Anchor" href="#aof-重写会阻塞吗"></a> AOF 重写会阻塞吗?</h3><p>每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。而且，因为 Redis 采用额外的线程进行数据重写，所以，这个过程并不会阻塞主线程。<br /><img src="http://qiniu.gogocoding.cn/mweb/%E9%87%8D%E5%86%99.jpg" alt="重写" /></p><h2 id="rdb"><a class="markdownIt-Anchor" href="#rdb"></a> RDB</h2><p>RDB与AOF 相比，RDB 记录的是某一时刻的数据，并不是操作，所以，在做数据恢复时，我们可以直接把 RDB 文件读入内存，很快地完成恢复。</p><p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。</p><ul><li>save：在主线程中执行，会导致阻塞；</li><li>bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。</li></ul><h1 id="主从同步"><a class="markdownIt-Anchor" href="#主从同步"></a> 主从同步</h1><p>Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。</p><ul><li>读操作：主库、从库都可以接收；</li><li>写操作：首先到主库执行，然后，主库将写操作同步给从库。</li></ul><h1 id="哨兵机制主库挂了如何不间断服务"><a class="markdownIt-Anchor" href="#哨兵机制主库挂了如何不间断服务"></a> 哨兵机制：主库挂了，如何不间断服务？</h1><p>如果主库挂了，我们就需要运行一个新主库，比如说把一个从库切换为主库，把它当成主库。这就涉及到三个问题：</p><ol><li>主库真的挂了吗？</li><li>该选择哪个从库作为主库？</li><li>怎么把新主库的相关信息通知给从库和客户端呢？</li></ol><p>这就要提到哨兵机制了。在 Redis 主从集群中，哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制模式下故障转移的这三个问题。</p><p>哨兵其实就是一个运行在特殊模式下的 Redis 进程，主从库实例运行的同时，它也在运行。哨兵主要负责的就是三个任务：监控、选主（选择主库）和通知。</p><h2 id="通知"><a class="markdownIt-Anchor" href="#通知"></a> 通知</h2><p>通知任务相对来说比较简单，哨兵只需要把新主库信息发给从库和客户端，让它们和新主库建立连接就行，并不涉及决策的逻辑</p><h2 id="监控"><a class="markdownIt-Anchor" href="#监控"></a> 监控</h2><p>监控是指哨兵进程在运行时，周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。如果从库没有在规定时间内响应哨兵的 PING 命令，哨兵就会把它标记为“下线状态”；同样，如果主库也没有在规定时间内响应哨兵的 PING 命令，哨兵就会判定主库下线，然后开始自动切换主库的流程。</p><h2 id="选主"><a class="markdownIt-Anchor" href="#选主"></a> 选主</h2><p>先保证所选的从库仍然在线运行，检查从库的当前在线状态，还要判断它之前的网络连接状态。<br />第一轮：优先级最高的从库得分高。<br />第二轮：和旧主库同步程度最接近的从库得分高。<br />第三轮：ID 号小的从库得分高。</p><p>git</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据恢复 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ETCD 优化思路</title>
      <link href="/2021/03/22/etcd/etcd%20%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/"/>
      <url>/2021/03/22/etcd/etcd%20%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="优化读性能"><a class="markdownIt-Anchor" href="#优化读性能"></a> 优化读性能</h1><ol><li>我们可通过 etcd clientv3 自带的 Round-robin 负载均衡算法或者 Load Balancer，尽量确保整个集群负载均衡。</li><li>在开启鉴权场景时，建议你尽量使用证书而不是密码认证，避免校验密码的昂贵开销。</li><li>根据业务场景选择合适的读模式，串行读比线性度性能提高 30% 以上，延时降低一倍。线性读性能受节点之间 RTT 延时、磁盘 IO 延时、当前写 QPS 等多重因素影响。</li><li>最容易被大家忽视的就是写 QPS 对读 QPS 的影响，我通过一系列压测数据，整理成一个表格，让你更直观感受写 QPS 对读性能的影响。多可用区部署会导致节点 RTT 延时增高，读性能下降。因此你需要在高可用和高性能上做取舍和平衡。</li><li>在访问数据前，你的读性能还可能会受授权性能、expensive read request、treeIndex 及 boltdb 的锁等影响。你需要遵循最佳实践，避免一个请求查询大量 key、大 key-value 等，否则会导致读性能剧烈下降。</li></ol><h1 id="k8s大集群核心问题"><a class="markdownIt-Anchor" href="#k8s大集群核心问题"></a> K8S大集群核心问题</h1><p>expensive request、db size、key-value 大小</p><ol><li>针对 expensive request， Kubernetes 采用了分页机制、资源按 namespace 拆分部署策略、核心的 Informer 机制、优化 client 与 kube-apiserver 连接异常后的 Watch 恢复效率的 bookmark 机制、以及进一步优化 kube-apiserver 重建场景下 Watch 恢复效率的 Notify 机制</li><li>针对 db size 和 key-value 大小，Kubernetes 社区的解决方案核心思想是拆分，通过 Lease 和 EndpointSlice 资源对象成功解决了大规模集群过程遇到 db size 和 key-value 瓶颈。</li></ol>]]></content>
      
      
      <categories>
          
          <category> ETCD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ETCD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器编排与Kubernetes作业管理</title>
      <link href="/2020/12/07/Kubernetes/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E4%B8%8EKubernetes%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86/"/>
      <url>/2020/12/07/Kubernetes/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E4%B8%8EKubernetes%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="容器编排与kubernetes作业管理"><a class="markdownIt-Anchor" href="#容器编排与kubernetes作业管理"></a> 容器编排与Kubernetes作业管理</h1><h2 id="deployment"><a class="markdownIt-Anchor" href="#deployment"></a> Deployment</h2><p>Deployment实现了 Kubernetes 项目中一个非常重要的功能：Pod 的“水平扩展 / 收缩”（horizontal scaling out/in）。这个功能，是从 PaaS 时代开始，一个平台级项目就必须具备的编排能力。这个能力的实现，依赖的是 Kubernetes 项目中的一个非常重要的概念（API 对象）：ReplicaSet。</p><p><img src="http://qiniu.gogocoding.cn/mweb/Dep-Rep.png" alt="Dep-Rep-w300" /></p><p>Deployment 四个状态</p><ol><li>DESIRED：用户期望的 Pod 副本个数（spec.replicas 的值）；</li><li>CURRENT：当前处于 Running 状态的 Pod 的个数；</li><li>UP-TO-DATE：当前处于最新版本的 Pod 的个数，所谓最新版本指的是 Pod 的 Spec 部分与 Deployment 里 Pod 模板里定义的完全一致；</li><li>AVAILABLE：当前已经可用的 Pod 的个数，即：既是 Running 状态，又是最新版本，并且已经处于 Ready（健康检查正确）状态的 Pod 的个数。</li></ol><p>只有这个 AVAILABLE 字段，描述的才是用户所期望的最终状态。</p><h2 id="statefulset"><a class="markdownIt-Anchor" href="#statefulset"></a> StatefulSet</h2><p>StatefulSet 其实就是一种特殊的 Deployment，而其独特之处在于，它的每个 Pod 都被编号了。而且，这个编号会体现在 Pod 的名字和 hostname 等标识信息上，这不仅代表了 Pod 的创建顺序，也是 Pod 的重要网络标识（即：在整个集群里唯一的、可被访问的身份）。有了这个编号后，StatefulSet 就使用 Kubernetes 里的两个标准功能：Headless Service 和 PV/PVC，实现了对 Pod 的拓扑状态和存储状态的维护。</p><p>实例之间有不对等关系，以及实例对外部数据有依赖关系的应用，就被称为“有状态应用”（Stateful Application）</p><p>StatefulSet 这个控制器的主要作用之一，就是使用 Pod 模板创建 Pod 的时候，对它们进行编号，并且按照编号顺序逐一完成创建工作。而当 StatefulSet 的“控制循环”发现 Pod 的“实际状态”与“期望状态”不一致，需要新建或者删除 Pod 进行“调谐”的时候，它会严格按照这些 Pod 编号的顺序，逐一完成这些操作。</p><p>StatefulSet 把真实世界里的应用状态，抽象为了两种情况：</p><ol><li><strong>拓扑状态</strong>：这种情况意味着，应用的多个实例之间不是完全对等的关系。这些应用实例，必须按照某些顺序启动，比如应用的主节点 A 要先于从节点 B 启动。而如果你把 A 和 B 两个 Pod 删除掉，它们再次被创建出来时也必须严格按照这个顺序才行。并且，新创建出来的 Pod，必须和原来 Pod 的网络标识一样，这样原先的访问者才能使用同样的方法，访问到这个新 Pod。</li><li><strong>存储状态</strong>：这种情况意味着，应用的多个实例分别绑定了不同的存储数据。对于这些应用实例来说，Pod A 第一次读取到的数据，和隔了十分钟之后再次读取到的数据，应该是同一份，哪怕在此期间 Pod A 被重新创建过。这种情况最典型的例子，就是一个数据库应用的多个存储实例。</li></ol><h3 id="statefulset-的工作原理"><a class="markdownIt-Anchor" href="#statefulset-的工作原理"></a> StatefulSet 的工作原理</h3><p>作为一个应用开发者，我可能对持久化存储项目（比如 Ceph、GlusterFS 等）一窍不通，也不知道公司的 Kubernetes 集群里到底是怎么搭建出来的，我也自然不会编写它们对应的 Volume 定义文件。所谓“术业有专攻”，这些关于 Volume 的管理和远程持久化存储的知识，不仅超越了开发者的知识储备，还会有暴露公司基础设施秘密的风险。</p><p>Kubernetes 项目引入了一组叫作 Persistent Volume Claim（PVC）和 Persistent Volume（PV）的 API 对象，大大降低了用户声明和使用持久化 Volume 的门槛。Kubernetes 中 PVC 和 PV 的设计，实际上类似于“接口”和“实现”的思想。开发者只要知道并会使用“接口”，即：PVC；而运维人员则负责给“接口”绑定具体的实现，即：PV。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  serviceName: &quot;nginx&quot;</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.9.1</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">          name: web</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: www</span><br><span class="line">          mountPath: &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</span><br><span class="line">  volumeClaimTemplates:</span><br><span class="line">  - metadata:</span><br><span class="line">      name: www</span><br><span class="line">    spec:</span><br><span class="line">      accessModes:</span><br><span class="line">      - ReadWriteOnce</span><br><span class="line">      resources:</span><br><span class="line">        requests:</span><br><span class="line">          storage: 1Gi</span><br></pre></td></tr></table></figure><p>StatefulSet 的工作原理：</p><ol><li>首先，StatefulSet 的控制器直接管理的是 Pod。StatefulSet 区分这些实例的方式，就是通过在 Pod 的名字里加上事先约定好的编号。</li><li>其次，Kubernetes 通过 Headless Service，为这些有编号的 Pod，在 DNS 服务器中生成带有同样编号的 DNS 记录。</li><li>最后，StatefulSet 还为每一个 Pod 分配并创建一个同样编号的 PVC。这样，Kubernetes 就可以通过 Persistent Volume 机制为这个 PVC 绑定上对应的 PV，从而保证了每一个 Pod 都拥有一个独立的 Volume。</li></ol><p>在这种情况下，即使 Pod 被删除，它所对应的 PVC 和 PV 依然会保留下来。所以当这个 Pod 被重新创建出来之后，Kubernetes 会为它找到同样编号的 PVC，挂载这个 PVC 对应的 Volume，从而获取到以前保存在 Volume 里的数据。</p><h2 id="daemonset"><a class="markdownIt-Anchor" href="#daemonset"></a> DaemonSet</h2><p>DaemonSet 的主要作用，是让你在 Kubernetes 集群里，运行一个 Daemon Pod，这个pod有如下三个特征</p><ol><li>这个 Pod 运行在 Kubernetes 集群里的每一个节点（Node）上；</li><li>每个节点上只有一个这样的 Pod 实例；</li><li>当有新的节点加入 Kubernetes 集群后，该 Pod 会自动地在新节点上被创建出来；而当旧节点被删除后，它上面的 Pod 也相应地会被回收掉。</li></ol><p>Daemon Pod 的意义是非常重要的。比如：</p><ol><li>各种网络插件的 Agent 组件，都必须运行在每一个节点上，用来处理这个节点上的容器网络；</li><li>各种存储插件的 Agent 组件，也必须运行在每一个节点上，用来在这个节点上挂载远程存储目录，操作容器的 Volume 目录；</li><li>各种监控组件和日志组件，也必须运行在每一个节点上，负责这个节点上的监控信息和日志搜集。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: DaemonSet</span><br><span class="line">metadata:</span><br><span class="line">  name: fluentd-elasticsearch</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: fluentd-logging</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      name: fluentd-elasticsearch</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: fluentd-elasticsearch</span><br><span class="line">    spec:</span><br><span class="line">      tolerations:</span><br><span class="line">      - key: node-role.kubernetes.io&#x2F;master</span><br><span class="line">        effect: NoSchedule</span><br><span class="line">      containers:</span><br><span class="line">      - name: fluentd-elasticsearch</span><br><span class="line">        image: k8s.gcr.io&#x2F;fluentd-elasticsearch:1.20</span><br><span class="line">        resources:</span><br><span class="line">          limits:</span><br><span class="line">            memory: 200Mi</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 200Mi</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: varlog</span><br><span class="line">          mountPath: &#x2F;var&#x2F;log</span><br><span class="line">        - name: varlibdockercontainers</span><br><span class="line">          mountPath: &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers</span><br><span class="line">          readOnly: true</span><br><span class="line">      terminationGracePeriodSeconds: 30</span><br><span class="line">      volumes:</span><br><span class="line">      - name: varlog</span><br><span class="line">        hostPath:</span><br><span class="line">          path: &#x2F;var&#x2F;log</span><br><span class="line">      - name: varlibdockercontainers</span><br><span class="line">        hostPath:</span><br><span class="line">          path: &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers</span><br></pre></td></tr></table></figure><h2 id="job"><a class="markdownIt-Anchor" href="#job"></a> Job</h2><p>有一类作业“离线业务”，或者叫作 Batch Job（计算业务）。这种业务在计算完成后就直接退出了，而此时如果你依然用 Deployment 来管理这种业务的话，就会发现 Pod 会在计算结束后退出，然后被 Deployment Controller 不断地重启。</p><p>Job API 对象的定义非常简单，我来举个例子，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: batch&#x2F;v1</span><br><span class="line">kind: Job</span><br><span class="line">metadata:</span><br><span class="line">  name: pi</span><br><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: pi</span><br><span class="line">        image: resouer&#x2F;ubuntu-bc </span><br><span class="line">        command: [&quot;sh&quot;, &quot;-c&quot;, &quot;echo &#39;scale&#x3D;10000; 4*a(1)&#39; | bc -l &quot;]</span><br><span class="line">      restartPolicy: Never</span><br><span class="line">  backoffLimit: 4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Cloud Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pod</title>
      <link href="/2020/12/07/Kubernetes/Pod/"/>
      <url>/2020/12/07/Kubernetes/Pod/</url>
      
        <content type="html"><![CDATA[<h1 id="pod"><a class="markdownIt-Anchor" href="#pod"></a> Pod</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><p>Pod，而不是容器，才是 Kubernetes 项目中的最小编排单位。凡是调度、网络、存储，以及安全相关的属性，基本上是 Pod 级别的；凡是跟容器的 Linux Namespace 相关的属性，也一定是 Pod 级别的。</p><h3 id="nodeselector"><a class="markdownIt-Anchor" href="#nodeselector"></a> NodeSelector</h3><p>NodeSelector是一个供用户将 Pod 与 Node 进行绑定的字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">...</span><br><span class="line">spec:</span><br><span class="line"> nodeSelector:</span><br><span class="line">   disktype: ssd</span><br></pre></td></tr></table></figure><h3 id="hostaliases"><a class="markdownIt-Anchor" href="#hostaliases"></a> HostAliases</h3><p>HostAliases：定义了 Pod 的 hosts 文件（比如 /etc/hosts）里的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">...</span><br><span class="line">spec:</span><br><span class="line">  hostAliases:</span><br><span class="line">  - ip: &quot;10.1.2.3&quot;</span><br><span class="line">    hostnames:</span><br><span class="line">    - &quot;foo.remote&quot;</span><br><span class="line">    - &quot;bar.remote&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="imagepullpolicy"><a class="markdownIt-Anchor" href="#imagepullpolicy"></a> ImagePullPolicy</h3><p>ImagePullPolicy定义了镜像拉取的策略。</p><ul><li>Always：每次都重新拉取镜像</li><li>Never ：从来不拉取新镜像</li><li>IfNotPresent：如果本地没有就拉取</li></ul><h3 id="lifecycle"><a class="markdownIt-Anchor" href="#lifecycle"></a> Lifecycle</h3><p>Lifecycle 定义的是 Container Lifecycle Hooks。顾名思义，Container Lifecycle Hooks 的作用，是在容器状态发生变化时触发一系列“钩子”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: lifecycle-demo</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: lifecycle-demo-container</span><br><span class="line">    image: nginx</span><br><span class="line">    lifecycle:</span><br><span class="line">      postStart:</span><br><span class="line">        exec:</span><br><span class="line">          command: [&quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, &quot;echo Hello from the postStart handler &gt; &#x2F;usr&#x2F;share&#x2F;message&quot;]</span><br><span class="line">      preStop:</span><br><span class="line">        exec:</span><br><span class="line">          command: [&quot;&#x2F;usr&#x2F;sbin&#x2F;nginx&quot;,&quot;-s&quot;,&quot;quit&quot;]</span><br></pre></td></tr></table></figure><h3 id="projected-volume"><a class="markdownIt-Anchor" href="#projected-volume"></a> Projected Volume</h3><p>Projected Volume的作用，是为容器提供预先定义好的数据</p><ol><li>Secret</li><li>ConfigMap</li><li>Downward API</li><li>ServiceAccountToken</li></ol><p><code>Secret</code>把 Pod 想要访问的加密数据，存放到 Etcd中，然后通过volume的方式挂载到pod中，已提供给pod中的容器使用 加密数据-&gt;etcd-&gt;volume-&gt;pod-&gt;container</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: test-projected-volume </span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: test-secret-volume</span><br><span class="line">    image: busybox</span><br><span class="line">    args:</span><br><span class="line">    - sleep</span><br><span class="line">    - &quot;86400&quot;</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: mysql-cred</span><br><span class="line">      mountPath: &quot;&#x2F;projected-volume&quot;</span><br><span class="line">      readOnly: true</span><br><span class="line">  volumes:</span><br><span class="line">  - name: mysql-cred</span><br><span class="line">    projected:</span><br><span class="line">      sources:</span><br><span class="line">      - secret:</span><br><span class="line">          name: user</span><br><span class="line">      - secret:</span><br><span class="line">          name: pass</span><br></pre></td></tr></table></figure><p><code>ConfigMap</code> 和<code>Secret</code>类似，它与 Secret 的区别在于，ConfigMap 保存的是不需要加密的、应用所需的配置信息。而 ConfigMap 的用法几乎与 Secret 完全相同：你可以使用 kubectl create configmap 从文件或者目录创建 ConfigMap，也可以直接编写 ConfigMap 对象的 YAML 文件。</p><p><code>Downward API</code>的作用是：让 Pod 里的容器能够直接获取到这个 Pod API 对象本身的信息。有两种方式可以将 Pod 和 Container 字段呈现给运行中的容器： 1、Environment variables 2、Volume Files 这两种呈现 Pod 和 Container 字段的方式都称为 Downward API。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: test-downwardapi-volume</span><br><span class="line">  labels:</span><br><span class="line">    zone: us-est-coast</span><br><span class="line">    cluster: test-cluster1</span><br><span class="line">    rack: rack-22</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: client-container</span><br><span class="line">      image: k8s.gcr.io&#x2F;busybox</span><br><span class="line">      command: [&quot;sh&quot;, &quot;-c&quot;]</span><br><span class="line">      args:</span><br><span class="line">      - while true; do</span><br><span class="line">          if [[ -e &#x2F;etc&#x2F;podinfo&#x2F;labels ]]; then</span><br><span class="line">            echo -en &#39;\n\n&#39;; cat &#x2F;etc&#x2F;podinfo&#x2F;labels; fi;</span><br><span class="line">          sleep 5;</span><br><span class="line">        done;</span><br><span class="line">      volumeMounts:</span><br><span class="line">        - name: podinfo</span><br><span class="line">          mountPath: &#x2F;etc&#x2F;podinfo</span><br><span class="line">          readOnly: false</span><br><span class="line">  volumes:</span><br><span class="line">    - name: podinfo</span><br><span class="line">      projected:</span><br><span class="line">        sources:</span><br><span class="line">        - downwardAPI:</span><br><span class="line">            items:</span><br><span class="line">              - path: &quot;labels&quot;</span><br><span class="line">                fieldRef:</span><br><span class="line">                  fieldPath: metadata.labels</span><br></pre></td></tr></table></figure><p>Downward API 支持的字段已经非常丰富了，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 使用fieldRef可以声明使用:</span><br><span class="line">spec.nodeName - 宿主机名字</span><br><span class="line">status.hostIP - 宿主机IP</span><br><span class="line">metadata.name - Pod的名字</span><br><span class="line">metadata.namespace - Pod的Namespace</span><br><span class="line">status.podIP - Pod的IP</span><br><span class="line">spec.serviceAccountName - Pod的Service Account的名字</span><br><span class="line">metadata.uid - Pod的UID</span><br><span class="line">metadata.labels[&#39;&lt;KEY&gt;&#39;] - 指定&lt;KEY&gt;的Label值</span><br><span class="line">metadata.annotations[&#39;&lt;KEY&gt;&#39;] - 指定&lt;KEY&gt;的Annotation值</span><br><span class="line">metadata.labels - Pod的所有Label</span><br><span class="line">metadata.annotations - Pod的所有Annotation</span><br><span class="line"></span><br><span class="line">2. 使用resourceFieldRef可以声明使用:</span><br><span class="line">容器的CPU limit</span><br><span class="line">容器的CPU request</span><br><span class="line">容器的memory limit</span><br><span class="line">容器的memory request</span><br></pre></td></tr></table></figure><p>其实，Secret、ConfigMap，以及 Downward API 这三种 Projected Volume 定义的信息，大多还可以通过环境变量的方式出现在容器里。但是，通过环境变量获取这些信息的方式，不具备自动更新的能力。所以，一般情况下建议使用 Volume 文件的方式获取这些信息。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Cloud Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Micro Services</title>
      <link href="/2020/10/30/Notes/Micro%20Services/"/>
      <url>/2020/10/30/Notes/Micro%20Services/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> MicroServices </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MicroServices </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/08/Interview/MQ/"/>
      <url>/2020/09/08/Interview/MQ/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a class="markdownIt-Anchor" href="#"></a> </h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/08/Interview/Micro/"/>
      <url>/2020/09/08/Interview/Micro/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a class="markdownIt-Anchor" href="#"></a> </h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/08/Interview/MySQL/"/>
      <url>/2020/09/08/Interview/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a class="markdownIt-Anchor" href="#"></a> </h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2020/08/11/Data%20Structure%20and%20Algorithm/%E6%A0%91/"/>
      <url>/2020/08/11/Data%20Structure%20and%20Algorithm/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="1-树总共包含4节内容-具体如下"><a class="markdownIt-Anchor" href="#1-树总共包含4节内容-具体如下"></a> 1. 树，总共包含4节内容。具体如下：</h1><ol><li>树、二叉树</li><li>二叉查找树</li><li>平衡二叉树、红黑树</li><li>递归树</li></ol><h1 id="2-树"><a class="markdownIt-Anchor" href="#2-树"></a> 2 树</h1><h2 id="21-树的常用概念"><a class="markdownIt-Anchor" href="#21-树的常用概念"></a> 2.1. 树的常用概念</h2><p>根节点、叶子节点、父节点、子节点、兄弟节点，还有节点的高度、深度以及层数，树的高度。</p><h2 id="22-概念解释"><a class="markdownIt-Anchor" href="#22-概念解释"></a> 2.2 概念解释</h2><p>节点：树中的每个元素称为节点<br />父子关系：相邻两节点的连线，称为父子关系<br />根节点：没有父节点的节点<br />叶子节点：没有子节点的节点<br />父节点：指向子节点的节点<br />子节点：被父节点指向的节点<br />兄弟节点：具有相同父节点的多个节点称为兄弟节点关系<br />节点的高度：节点到叶子节点的最长路径所包含的边数<br />节点的深度：根节点到节点的路径所包含的边数<br />节点的层数：节点的深度+1（根节点的层数是1）<br />树的高度：等于根节点的高度</p><h1 id="3-二叉树"><a class="markdownIt-Anchor" href="#3-二叉树"></a> 3. 二叉树</h1><h2 id="31-概念"><a class="markdownIt-Anchor" href="#31-概念"></a> 3.1. 概念</h2><h3 id="311-什么是二叉树"><a class="markdownIt-Anchor" href="#311-什么是二叉树"></a> 3.1.1. 什么是二叉树？</h3><p>每个节点最多只有2个子节点的树，这两个节点分别是左子节点和右子节点。</p><h3 id="312-什么是满二叉树"><a class="markdownIt-Anchor" href="#312-什么是满二叉树"></a> 3.1.2. 什么是满二叉树？</h3><p>有一种二叉树，除了叶子节点外，每个节点都有左右两个子节点，这种二叉树叫做满二叉树。</p><h3 id="313什么是完全二叉树"><a class="markdownIt-Anchor" href="#313什么是完全二叉树"></a> 3.1.3.什么是完全二叉树？</h3><p>有一种二叉树，叶子节点都在最底下两层，最后一层叶子节都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树。</p><h2 id="32-完全二叉树的存储"><a class="markdownIt-Anchor" href="#32-完全二叉树的存储"></a> 3.2. 完全二叉树的存储</h2><h3 id="321-链式存储"><a class="markdownIt-Anchor" href="#321-链式存储"></a> 3.2.1. 链式存储</h3><p>每个节点由3个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式比较常用，大部分二叉树代码都是通过这种方式实现的。</p><h3 id="322-顺序存储"><a class="markdownIt-Anchor" href="#322-顺序存储"></a> 3.2.2. 顺序存储</h3><p>用数组来存储，对于完全二叉树，如果节点X存储在数组中的下标为i，那么它的左子节点的存储下标为2<em>i，右子节点的下标为2</em>i+1，反过来，下标i/2位置存储的就是该节点的父节点。注意，根节点存储在下标为1的位置。完全二叉树用数组来存储时最省内存的方式。</p><h2 id="33-二叉树的遍历"><a class="markdownIt-Anchor" href="#33-二叉树的遍历"></a> 3.3. 二叉树的遍历</h2><h3 id="331-前序遍历"><a class="markdownIt-Anchor" href="#331-前序遍历"></a> 3.3.1. 前序遍历：</h3><p>对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p><h3 id="332-中序遍历"><a class="markdownIt-Anchor" href="#332-中序遍历"></a> 3.3.2. 中序遍历：</h3><p>对于树中的任意节点来说，先打印它的左子树，然后再打印它的本身，最后打印它的右子树。</p><h3 id="333-后序遍历"><a class="markdownIt-Anchor" href="#333-后序遍历"></a> 3.3.3. 后序遍历：</h3><p>对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印它本身。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">前序遍历的递推公式：</span><br><span class="line">preOrder(r) &#x3D; print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)</span><br><span class="line">中序遍历的递推公式：</span><br><span class="line">inOrder(r) &#x3D; inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)</span><br><span class="line">后序遍历的递推公式：</span><br><span class="line">postOrder(r) &#x3D; postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r</span><br></pre></td></tr></table></figure><p>时间复杂度：3种遍历方式中，每个节点最多会被访问2次，所以时间复杂度是O(n)。</p><h1 id="4-练习题"><a class="markdownIt-Anchor" href="#4-练习题"></a> 4. 练习题</h1><p>leetcode：94、105、106、889</p><h2 id="41-二叉树的中序遍历-leetcode题号-94"><a class="markdownIt-Anchor" href="#41-二叉树的中序遍历-leetcode题号-94"></a> 4.1 二叉树的中序遍历 : <code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94</a></h2><h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4><p>递归</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> res []<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        leftRes := inorderTraversal(root.Left)</span><br><span class="line">        res = <span class="built_in">append</span>(res, leftRes...)</span><br><span class="line">    &#125;</span><br><span class="line">    res  = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">    <span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">        rightRes := inorderTraversal(root.Right)</span><br><span class="line">        res = <span class="built_in">append</span>(res, rightRes...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> inorderIterate(root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderIterate</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stack, rest := Stack([]*TreeNode&#123;root&#125;), []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">cur := stack.Pop()</span><br><span class="line"><span class="keyword">if</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> cur.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">stack.Push(cur.Right)</span><br><span class="line">&#125;</span><br><span class="line">stack.Push(cur)</span><br><span class="line">stack.Push(<span class="literal">nil</span>) <span class="comment">// 待读取标记</span></span><br><span class="line"><span class="keyword">if</span> cur.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">stack.Push(cur.Left)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rest = <span class="built_in">append</span>(rest, stack.Pop().Val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stack []*TreeNode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span> <span class="title">Push</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">*s = <span class="built_in">append</span>(*s, node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span> <span class="title">Pop</span><span class="params">()</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">n := []*TreeNode(*s)[<span class="built_in">len</span>(*s)<span class="number">-1</span>]</span><br><span class="line">*s = []*TreeNode(*s)[:<span class="built_in">len</span>(*s)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="42-从前序与中序遍历序列构造二叉树-leetcode题号-105"><a class="markdownIt-Anchor" href="#42-从前序与中序遍历序列构造二叉树-leetcode题号-105"></a> 4.2 从前序与中序遍历序列构造二叉树 : <code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="keyword">int</span>, inorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> || <span class="built_in">len</span>(inorder) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中顺序列找根结点</span></span><br><span class="line">    <span class="keyword">var</span> root <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> k, v :=  <span class="keyword">range</span> inorder &#123;</span><br><span class="line">        <span class="keyword">if</span> v == preorder[<span class="number">0</span>] &#123;</span><br><span class="line">            root = k</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右子树归类</span></span><br><span class="line">    <span class="comment">// pre_left, pre_right := preorder[1: root+1], preorder[root+1:]</span></span><br><span class="line">    <span class="comment">// in_left, in_right := inorder[0: root], inorder[root+1:]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左右子树递归</span></span><br><span class="line">    <span class="keyword">return</span> &amp;TreeNode&#123;</span><br><span class="line">        Val:   preorder[<span class="number">0</span>],</span><br><span class="line">        Left:  buildTree(preorder[<span class="number">1</span>: root+<span class="number">1</span>], inorder[<span class="number">0</span>: root]),</span><br><span class="line">        Right: buildTree(preorder[root+<span class="number">1</span>:], inorder[root+<span class="number">1</span>:]),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="43-从中序与后序遍历序列构造二叉树-leetcode题号-106"><a class="markdownIt-Anchor" href="#43-从中序与后序遍历序列构造二叉树-leetcode题号-106"></a> 4.3 从中序与后序遍历序列构造二叉树 : <code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(inorder []<span class="keyword">int</span>, postorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(inorder) == <span class="number">0</span> || <span class="built_in">len</span>(postorder) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> root <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> inorder &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == postorder[<span class="built_in">len</span>(postorder) - <span class="number">1</span>]) &#123;</span><br><span class="line">            root = k</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;TreeNode &#123;</span><br><span class="line">        Val : inorder[root],</span><br><span class="line">        Left : buildTree(inorder[<span class="number">0</span> : root], postorder[<span class="number">0</span>: root]),</span><br><span class="line">        Right : buildTree(inorder[root +<span class="number">1</span> :], postorder[root : <span class="built_in">len</span>(postorder) - <span class="number">1</span>]),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="43-根据前序和后序遍历构造二叉树-leetcode题号-889"><a class="markdownIt-Anchor" href="#43-根据前序和后序遍历构造二叉树-leetcode题号-889"></a> 4.3 根据前序和后序遍历构造二叉树 : <code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructFromPrePost</span><span class="params">(pre []<span class="keyword">int</span>, post []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">node:=&amp;TreeNode&#123;Val: pre[<span class="number">0</span>]&#125;</span><br><span class="line">    <span class="comment">//长度至少要大于1才能构建子树</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(pre)&gt;<span class="number">1</span>&#123;</span><br><span class="line">i:=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i&lt;<span class="built_in">len</span>(post)&#123;</span><br><span class="line"><span class="keyword">if</span> post[i]==pre[<span class="number">1</span>]&#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//长度大于1，因此按照自定义的规则来说，必然可以构建左子树</span></span><br><span class="line">node.Left=constructFromPrePost(pre[<span class="number">1</span>:i+<span class="number">2</span>],post[<span class="number">0</span>:i+<span class="number">1</span>])</span><br><span class="line"><span class="comment">//可能存在右子树，那么构建右子树</span></span><br><span class="line"><span class="keyword">if</span> i+<span class="number">2</span>&lt;<span class="built_in">len</span>(pre)&#123;</span><br><span class="line">node.Right=constructFromPrePost(pre[i+<span class="number">2</span>:],post[i+<span class="number">1</span>:<span class="built_in">len</span>(post)<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2020/08/09/Data%20Structure%20and%20Algorithm/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2020/08/09/Data%20Structure%20and%20Algorithm/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-普通二分查找的非递归与递归实现"><a class="markdownIt-Anchor" href="#1-普通二分查找的非递归与递归实现"></a> 1 普通二分查找的非递归与递归实现</h1><p>条件：无重复元素的有序数组</p><h4 id="11-非递归"><a class="markdownIt-Anchor" href="#11-非递归"></a> 1.1 非递归</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BinarySearch</span><span class="params">(arr []<span class="keyword">int</span>, v <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(arr)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">low := <span class="number">0</span></span><br><span class="line">hight := n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> low &lt;= hight &#123;</span><br><span class="line">mid := low + ((hight - low) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> arr[mid] == v &#123;</span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> arr[mid] &gt; v &#123;</span><br><span class="line">hight = mid - <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">low = mid + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-递归"><a class="markdownIt-Anchor" href="#12-递归"></a> 1.2 递归</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BinarySearchRecursive</span><span class="params">(arr []<span class="keyword">int</span>, v <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(arr)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bs()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bs</span><span class="params">(arr []<span class="keyword">int</span>, v <span class="keyword">int</span>, low, hight <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> low &gt; hight &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mid := low + ((hight - low) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> a[mid] == v &#123;</span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> a[mid] &gt; v &#123;</span><br><span class="line"><span class="keyword">return</span> bs(arr, v, low, mid<span class="number">-1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> bs(arr, v, mid+<span class="number">1</span>, hight)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2-4种常见的二分查找变形问题"><a class="markdownIt-Anchor" href="#2-4种常见的二分查找变形问题"></a> 2. 4种常见的二分查找变形问题</h1><p>条件：有重复元素的有序数组</p><h2 id="21-查找第一个值等于给定值的元素"><a class="markdownIt-Anchor" href="#21-查找第一个值等于给定值的元素"></a> 2.1 查找第一个值等于给定值的元素</h2><h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BinarySearchFirst</span><span class="params">(arr []<span class="keyword">int</span>, v <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>[arr]</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">low := <span class="number">0</span></span><br><span class="line">hight := n <span class="number">-1</span> </span><br><span class="line"><span class="keyword">for</span> low &lt;= hight &#123;</span><br><span class="line">mid := low + ((hight - low)&gt;&gt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> arr[mid] &gt; v &#123;</span><br><span class="line">hight = mid<span class="number">-1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> arr[mid] &lt; v&#123;</span><br><span class="line">low = mid + <span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span> mid == <span class="number">0</span> || arr[mid - <span class="number">1</span>] != v &#123;</span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">hight = mid <span class="number">-1</span> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span> </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22-查找最后一个值等于给定值的元素"><a class="markdownIt-Anchor" href="#22-查找最后一个值等于给定值的元素"></a> 2.2 查找最后一个值等于给定值的元素</h2><h4 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BinarySearchLast</span><span class="params">(arr []<span class="keyword">int</span>, v <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>[arr]</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">low := <span class="number">0</span></span><br><span class="line">hight := n <span class="number">-1</span> </span><br><span class="line"><span class="keyword">for</span> low &lt;= hight &#123;</span><br><span class="line">mid := low + ((hight - low)&gt;&gt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> arr[mid] &gt; v &#123;</span><br><span class="line">hight = mid<span class="number">-1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> arr[mid] &lt; v&#123;</span><br><span class="line">low = mid + <span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span> mid == n<span class="number">-1</span> || arr[mid + <span class="number">1</span>] != v &#123;</span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">low = mid + <span class="number">1</span> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span> </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="23-查找第一个大于等于给定值的元素"><a class="markdownIt-Anchor" href="#23-查找第一个大于等于给定值的元素"></a> 2.3 查找第一个大于等于给定值的元素</h2><h4 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BinarySearchFirstGT</span><span class="params">(arr []<span class="keyword">int</span>, v <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>[arr]</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">low := <span class="number">0</span></span><br><span class="line">hight := n <span class="number">-1</span> </span><br><span class="line"><span class="keyword">for</span> low &lt;= hight &#123;</span><br><span class="line">mid := low + ((hight - low)&gt;&gt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> arr[mid] &gt;= value &#123;</span><br><span class="line"><span class="keyword">if</span> (mid ==<span class="number">0</span>) || a[mid - <span class="number">1</span>]&lt; v &#123;</span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">hight = mid <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">low = mid + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span> </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="24-查找最后一个小于等于给定值的元素"><a class="markdownIt-Anchor" href="#24-查找最后一个小于等于给定值的元素"></a> 2.4 查找最后一个小于等于给定值的元素</h2><h4 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BinarySearchLastLT</span><span class="params">(arr []<span class="keyword">int</span>, v <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>[arr]</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">low := <span class="number">0</span></span><br><span class="line">hight := n - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> low &lt;= hight &#123;</span><br><span class="line">mid := low + ((hight - low) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> arr[mid] &lt;= value &#123;</span><br><span class="line"><span class="keyword">if</span> (mid == n<span class="number">-1</span>) || a[mid+<span class="number">1</span>] &gt; v &#123;</span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">low = mid + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">hight = mid - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习题"><a class="markdownIt-Anchor" href="#练习题"></a> 练习题</h1><p>1.搜索旋转排序数组 : <code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33</a></p><h3 id="思路一"><a class="markdownIt-Anchor" href="#思路一"></a> 思路一：</h3><ol><li>先二分法找到 数组旋转分界点</li><li>判断 目标点在分界点的左侧还是右侧，传入对应的二分查找方法中去</li></ol><h4 id="代码-5"><a class="markdownIt-Anchor" href="#代码-5"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">low := <span class="number">0</span></span><br><span class="line">hight := n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nums[low] &gt; target &amp;&amp; nums[hight] &lt; target &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flag <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> low &lt;= hight &#123;</span><br><span class="line">mid := low + ((hight - low) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> nums[mid] &gt; nums[low] &#123;</span><br><span class="line">low = mid</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; nums[low] &#123;</span><br><span class="line">hight = mid</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> nums[mid] &gt;= nums[hight] &#123;</span><br><span class="line">flag = mid</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">flag = hight</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= target &#123;</span><br><span class="line"><span class="keyword">return</span> sort(nums, <span class="number">0</span>, flag, target)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sort(nums, flag+<span class="number">1</span>, n<span class="number">-1</span>, target)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sort</span><span class="params">(arr []<span class="keyword">int</span>, start, end, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">low := start</span><br><span class="line">hight := end</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> low &lt;= hight &#123;</span><br><span class="line">mid := low + ((hight - low) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> arr[mid] == target &#123;</span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> arr[mid] &lt; target &#123;</span><br><span class="line">low = mid + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">hight = mid - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路二"><a class="markdownIt-Anchor" href="#思路二"></a> 思路二</h3><p>我们可以在常规二分搜索的时候查看当前 mid 为分割位置分割出来的两个部分 [l, mid] 和 [mid + 1, r] 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分搜索的上下界，因为我们能够根据有序的那部分判断出 target 在不在这个部分</p><h4 id="代码-6"><a class="markdownIt-Anchor" href="#代码-6"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    low := <span class="number">0</span></span><br><span class="line">    hight := n <span class="number">-1</span> </span><br><span class="line">    <span class="keyword">for</span> low &lt;= hight &#123;</span><br><span class="line">        mid := low +((hight -low) &gt;&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[low] &lt;= nums[mid] &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[low] &lt;= target &amp;&amp; nums[mid] &gt; target &#123;</span><br><span class="line">                hight = mid <span class="number">-1</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target &amp;&amp; nums[hight] &gt;= target &#123;</span><br><span class="line">                low = mid +<span class="number">1</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                hight = mid <span class="number">-1</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2020/08/06/Data%20Structure%20and%20Algorithm/%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/08/06/Data%20Structure%20and%20Algorithm/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-几种经典排序算法及其时间复杂度级别"><a class="markdownIt-Anchor" href="#1-几种经典排序算法及其时间复杂度级别"></a> 1. 几种经典排序算法及其时间复杂度级别</h1><ul><li>冒泡、插入、选择 O(n^2) 基于比较</li><li>快排、归并 O(nlogn) 基于比较</li><li>计数、基数、桶 O(n) 不基于比较</li></ul><h1 id="2-如何分析一个排序算法"><a class="markdownIt-Anchor" href="#2-如何分析一个排序算法"></a> 2. 如何分析一个排序算法？</h1><ol><li>学习排序算法的思路？明确原理、掌握实现以及分析性能。</li><li>如何分析排序算法性能？从执行效率、内存消耗以及稳定性3个方面分析排序算法的性能。</li><li>执行效率：从以下3个方面来衡量<br />1）最好情况、最坏情况、平均情况时间复杂度<br />2）时间复杂度的系数、常数、低阶：排序的数据量比较小时考虑<br />3）比较次数和交换（或移动）次数</li><li>内存消耗：通过空间复杂度来衡量。针对排序算法的空间复杂度，引入原地排序的概念，原地排序算法就是指空间复杂度为O(1)的排序算法。</li><li>稳定性：如果待排序的序列中存在值等的元素，经过排序之后，相等元素之间原有的先后顺序不变，就说明这个排序算法时稳定的。</li></ol><h1 id="3-冒泡排序"><a class="markdownIt-Anchor" href="#3-冒泡排序"></a> 3. 冒泡排序</h1><h2 id="31-排序原理"><a class="markdownIt-Anchor" href="#31-排序原理"></a> 3.1. 排序原理</h2><ol><li>冒泡排序只会操作相邻的两个数据。</li><li>对相邻两个数据进行比较，看是否满足大小关系要求，若不满足让它俩互换。</li><li>一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作。</li><li>优化：若某次冒泡不存在数据交换，则说明已经达到完全有序，所以终止冒泡。</li></ol><h2 id="32-代码实现"><a class="markdownIt-Anchor" href="#32-代码实现"></a> 3.2. 代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span> <span class="params">([]<span class="keyword">int</span> a, <span class="keyword">int</span> n)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;=<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; n; i++ &#123; </span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n-i<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> a[j] &gt; a[j+<span class="number">1</span>] &#123;</span><br><span class="line">                temp := a[j]</span><br><span class="line">                a[i] = a[j+]</span><br><span class="line">                a[j+<span class="number">1</span>] = temp</span><br><span class="line">                flag = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !flag &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="33-性能分析"><a class="markdownIt-Anchor" href="#33-性能分析"></a> 3.3. 性能分析</h2><h3 id="331-执行效率最小时间复杂度-最大时间复杂度-平均时间复杂度"><a class="markdownIt-Anchor" href="#331-执行效率最小时间复杂度-最大时间复杂度-平均时间复杂度"></a> 3.3.1 执行效率：最小时间复杂度、最大时间复杂度、平均时间复杂度</h3><ul><li>最小时间复杂度：数据完全有序时，只需进行一次冒泡操作即可，时间复杂度是O(n)。</li><li>最大时间复杂度：数据倒序排序时，需要n次冒泡操作，时间复杂度是O(n^2)。</li><li>平均时间复杂度：通过有序度和逆序度来分析。</li></ul><p>什么是有序度？<br />有序度是数组中具有有序关系的元素对的个数，比如[2,4,3,1,5,6]这组数据的有序度就是11，分别是[2,4][2,3][2,5][2,6][4,5][4,6][3,5][3,6][1,5][1,6][5,6]。同理，对于一个倒序数组，比如[6,5,4,3,2,1]，有序度是0；对于一个完全有序的数组，比如[1,2,3,4,5,6]，有序度为n*(n-1)/2，也就是15，完全有序的情况称为满有序度。<br />什么是逆序度？逆序度的定义正好和有序度相反。核心公式：逆序度=满有序度-有序度。<br />排序过程，就是有序度增加，逆序度减少的过程，最后达到满有序度，就说明排序完成了。<br />冒泡排序包含两个操作原子，即比较和交换，每交换一次，有序度加1。不管算法如何改进，交换的次数总是确定的，即逆序度。<br />对于包含n个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏的情况初始有序度为0，所以要进行n*(n-1)/2交换。最好情况下，初始状态有序度是n*(n-1)/2，就不需要进行交互。我们可以取个中间值n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。<br />换句话说，平均情况下，需要n*(n-1)/4次交换操作，比较操作可定比交换操作多，而复杂度的上限是O(n<sup>2)，所以平均情况时间复杂度就是O(n</sup>2)。<br />以上的分析并不严格，但很实用，这就够了。</p><h3 id="332-空间复杂度每次交换仅需1个临时变量故空间复杂度为o1是原地排序算法"><a class="markdownIt-Anchor" href="#332-空间复杂度每次交换仅需1个临时变量故空间复杂度为o1是原地排序算法"></a> 3.3.2 空间复杂度：每次交换仅需1个临时变量，故空间复杂度为O(1)，是原地排序算法。</h3><h3 id="333-算法稳定性如果两个值相等就不会交换位置故是稳定排序算法"><a class="markdownIt-Anchor" href="#333-算法稳定性如果两个值相等就不会交换位置故是稳定排序算法"></a> 3.3.3 算法稳定性：如果两个值相等，就不会交换位置，故是稳定排序算法。</h3><h1 id="4-插入排序"><a class="markdownIt-Anchor" href="#4-插入排序"></a> 4. 插入排序</h1><h2 id="41-算法原理"><a class="markdownIt-Anchor" href="#41-算法原理"></a> 4.1. 算法原理</h2><p>首先，我们将数组中的数据分为2个区间，即已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想就是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间中的元素一直有序。重复这个过程，直到未排序中元素为空，算法结束。</p><h2 id="42代码实现"><a class="markdownIt-Anchor" href="#42代码实现"></a> 4.2代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertionSort</span> <span class="params">([]<span class="keyword">int</span> a, n <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        value := a[i]</span><br><span class="line">        j:=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> ; j&gt;<span class="number">0</span>; j--&#123;</span><br><span class="line">            <span class="keyword">if</span> a[j]&gt;a[i] &#123;</span><br><span class="line">                a[j+<span class="number">1</span>]= a[j]</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="43-性能分析"><a class="markdownIt-Anchor" href="#43-性能分析"></a> 4.3 性能分析</h2><h3 id="431-时间复杂度最好-最坏-平均情况"><a class="markdownIt-Anchor" href="#431-时间复杂度最好-最坏-平均情况"></a> 4.3.1 时间复杂度：最好、最坏、平均情况</h3><p>如果要排序的数组已经是有序的，我们并不需要搬移任何数据。只需要遍历一遍数组即可，所以时间复杂度是O(n)。如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，因此时间复杂度是O(n<sup>2)。而在一个数组中插入一个元素的平均时间复杂都是O(n)，插入排序需要n次插入，所以平均时间复杂度是O(n</sup>2)。</p><h3 id="432-空间复杂度从上面的代码可以看出插入排序算法的运行并不需要额外的存储空间所以空间复杂度是o1是原地排序算法"><a class="markdownIt-Anchor" href="#432-空间复杂度从上面的代码可以看出插入排序算法的运行并不需要额外的存储空间所以空间复杂度是o1是原地排序算法"></a> 4.3.2 空间复杂度：从上面的代码可以看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是O(1)，是原地排序算法。</h3><h3 id="433-算法稳定性在插入排序中对于值相同的元素我们可以选择将后面出现的元素插入到前面出现的元素的后面这样就保持原有的顺序不变所以是稳定的"><a class="markdownIt-Anchor" href="#433-算法稳定性在插入排序中对于值相同的元素我们可以选择将后面出现的元素插入到前面出现的元素的后面这样就保持原有的顺序不变所以是稳定的"></a> 4.3.3 算法稳定性：在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现的元素的后面，这样就保持原有的顺序不变，所以是稳定的。</h3><h1 id="5-归并排序"><a class="markdownIt-Anchor" href="#5-归并排序"></a> 5 归并排序</h1><h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MergeSort</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">arrLen := <span class="built_in">len</span>(arr)</span><br><span class="line"><span class="keyword">if</span> arrLen &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mergeSort(arr, <span class="number">0</span>, arrLen<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(arr []<span class="keyword">int</span>, start, end <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> start &gt;= end &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mid := (start + end) / <span class="number">2</span></span><br><span class="line">mergeSort(arr, start, mid)</span><br><span class="line">mergeSort(arr, mid+<span class="number">1</span>, end)</span><br><span class="line">merge(arr, start, mid, end)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(arr []<span class="keyword">int</span>, start, mid, end <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">tmpArr := <span class="built_in">make</span>([]<span class="keyword">int</span>, end-start+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">i := start</span><br><span class="line">j := mid + <span class="number">1</span></span><br><span class="line">k := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; i &lt;= mid &amp;&amp; j &lt;= end; k++ &#123;</span><br><span class="line"><span class="keyword">if</span> arr[i] &lt;= arr[j] &#123;</span><br><span class="line">tmpArr[k] = arr[i]</span><br><span class="line">i++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tmpArr[k] = arr[j]</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ; i &lt;= mid; i++ &#123;</span><br><span class="line">tmpArr[k] = arr[i]</span><br><span class="line">k++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ; j &lt;= end; j++ &#123;</span><br><span class="line">tmpArr[k] = arr[j]</span><br><span class="line">k++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">copy</span>(arr[start:end+<span class="number">1</span>], tmpArr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-快速排序"><a class="markdownIt-Anchor" href="#6-快速排序"></a> 6 快速排序</h1><h4 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QuickSort is quicksort methods for golang</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">separateSort(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">separateSort</span><span class="params">(arr []<span class="keyword">int</span>, start, end <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> start &gt;= end &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">i := partition(arr, start, end)</span><br><span class="line">separateSort(arr, start, i<span class="number">-1</span>)</span><br><span class="line">separateSort(arr, i+<span class="number">1</span>, end)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(arr []<span class="keyword">int</span>, start, end <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// 选取最后一位当对比数字</span></span><br><span class="line">pivot := arr[end]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = start</span><br><span class="line"><span class="keyword">for</span> j := start; j &lt; end; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> arr[j] &lt; pivot &#123;</span><br><span class="line"><span class="keyword">if</span> !(i == j) &#123;</span><br><span class="line"><span class="comment">// 交换位置</span></span><br><span class="line">arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">&#125;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[i], arr[end] = arr[end], arr[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="桶排序"><a class="markdownIt-Anchor" href="#桶排序"></a> 桶排序</h1><h4 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 获取待排序数组中的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMax</span><span class="params">(a []<span class="keyword">int</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">max := a[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(a); i++&#123;</span><br><span class="line"><span class="keyword">if</span> a[i] &gt; max&#123;</span><br><span class="line">max = a[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BucketSort</span><span class="params">(a []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">num := <span class="built_in">len</span>(a)</span><br><span class="line"><span class="keyword">if</span> num &lt;= <span class="number">1</span>&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">max := getMax(a)</span><br><span class="line">buckets := <span class="built_in">make</span>([][]<span class="keyword">int</span>, num)  <span class="comment">// 二维切片</span></span><br><span class="line"></span><br><span class="line">index :=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; num; i++&#123;</span><br><span class="line">index = a[i]*(num <span class="number">-1</span>) / max  <span class="comment">// 桶序号</span></span><br><span class="line">buckets[index] = <span class="built_in">append</span>(buckets[index],a[i]) <span class="comment">// 加入对应的桶中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tmpPos := <span class="number">0</span>  <span class="comment">// 标记数组位置</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">bucketLen := <span class="built_in">len</span>(buckets[i])</span><br><span class="line"><span class="keyword">if</span> bucketLen &gt; <span class="number">0</span>&#123;</span><br><span class="line">Sort.QuickSort(buckets[i])  <span class="comment">// 桶内做快速排序</span></span><br><span class="line"><span class="built_in">copy</span>(a[tmpPos:], buckets[i])</span><br><span class="line">tmpPos += bucketLen</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 桶排序简单实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BucketSortSimple</span><span class="params">(source []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(source)&lt;=<span class="number">1</span>&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">array := <span class="built_in">make</span>([]<span class="keyword">int</span>, getMax(source)+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(source); i++&#123;</span><br><span class="line">array[source[i]] ++</span><br><span class="line">&#125;</span><br><span class="line">    fmt.Println(array)</span><br><span class="line">c := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(array); i++&#123;</span><br><span class="line"><span class="keyword">for</span> array[i] != <span class="number">0</span> &#123;</span><br><span class="line">            c = <span class="built_in">append</span>(c, i)</span><br><span class="line">array[i] --</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">copy</span>(source,c)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/2020/08/04/Data%20Structure%20and%20Algorithm/%E9%80%92%E5%BD%92/"/>
      <url>/2020/08/04/Data%20Structure%20and%20Algorithm/%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>#1. 什么是递归？</p><ol><li>递归是一种非常高效、简洁的编码技巧，一种应用非常广泛的算法，比如DFS深度优先搜索、前中后序二叉树遍历等都是使用递归。</li><li>方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。</li><li>基本上，所有的递归问题都可以用递推公式来表示，比如<br />f(n) = f(n-1) + 1;<br />f(n) = f(n-1) + f(n-2);<br />f(n)=n*f(n-1);</li></ol><p>#2. 为什么使用递归？递归的优缺点？</p><ol><li>优点：代码的表达力很强，写起来简洁。</li><li>缺点：空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。</li></ol><p>#3. 什么样的问题可以用递归解决呢？</p><p>一个问题只要同时满足以下3个条件，就可以用递归来解决：</p><ol><li>问题的解可以分解为几个子问题的解。何为子问题？就是数据规模更小的问题。</li><li>问题与子问题，除了数据规模不同，求解思路完全一样</li><li>存在递归终止条件</li></ol><p>#4. 如何实现递归？</p><ol><li>递归代码编写<br />写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</li><li>递归代码理解<br />对于递归代码，若试图想清楚整个递和归的过程，实际上是进入了一个思维误区。<br />那该如何理解递归代码呢？如果一个问题A可以分解为若干个子问题B、C、D，你可以假设子问题B、C、D已经解决。而且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。<br />因此，理解递归代码，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</li></ol><p>#5. 递归常见问题及解决方案</p><p>1.警惕堆栈溢出：可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。<br />2.警惕重复计算：通过某种数据结构来保存已经求解过的值，从而避免重复计算。</p><p>#6. 如何将递归改写为非递归代码？</p><p>笼统的讲，所有的递归代码都可以改写为迭代循环的非递归写法。如何做？抽象出递推公式、初始值和边界条件，然后用迭代循环实现。</p><p>#7. 练习题<br />##1. 斐波那契数列: <code>剑指 Offer 10</code>题号: <a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10</a></p><h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span> ||n==<span class="number">1</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    dp:=<span class="built_in">make</span>([]<span class="keyword">int</span>,n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span>;i&lt;=n;i++&#123;</span><br><span class="line">        dp[i]=(dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>])%<span class="number">1000000007</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2. 汉诺塔问题: <code>面试题 08.06.</code>题号: <a href="https://leetcode-cn.com/problems/hanota-lcci/">面试题 08.06. </a></p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>递归重点：1）必须可以拆分为若干个规模较小，与原问题形式相同的子问题；并且子问题可以用完全相同的解题思路解决；（递归主体）<br />2）递归的演化过程是一个对原问题从大到小进行拆解的过程，并且会有一个明确的终点。（终止条件）<br />假设共n个盘子，三个柱子分别是x,y,z，则目的是将x柱上面的n个盘子转移到z柱上面，那么分析：<br />1.将n-1个盘子从x柱转移到y柱<br />2.将x柱上最后一个盘子转移到z柱<br />3.将n-1个盘子从y柱转移到z柱<br />可见，1，3是汉诺塔问题；终止条件，当n=1时无法再细化。<br />所以判断可以使用递归解决该问题。</p><h4 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hanota</span><span class="params">(A []<span class="keyword">int</span>, B []<span class="keyword">int</span>, C []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(A)</span><br><span class="line">hanio(n, &amp;A, &amp;B, &amp;C)</span><br><span class="line"><span class="keyword">return</span> C</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hanio</span><span class="params">(n <span class="keyword">int</span>, a *[]<span class="keyword">int</span>, b *[]<span class="keyword">int</span>, c *[]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">1</span> || n &gt; <span class="number">14</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">*c = <span class="built_in">append</span>(*c, (*a)[<span class="built_in">len</span>(*a)<span class="number">-1</span>])</span><br><span class="line">*a = (*a)[:<span class="built_in">len</span>(*a)<span class="number">-1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">hanio(n<span class="number">-1</span>, a, c, b)</span><br><span class="line">*c = <span class="built_in">append</span>(*c, (*a)[<span class="built_in">len</span>(*a)<span class="number">-1</span>])</span><br><span class="line">*a = (*a)[:<span class="built_in">len</span>(*a)<span class="number">-1</span>]</span><br><span class="line">hanio(n<span class="number">-1</span>, b, a, c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/2020/08/03/Data%20Structure%20and%20Algorithm/%E9%98%9F%E5%88%97/"/>
      <url>/2020/08/03/Data%20Structure%20and%20Algorithm/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是队列"><a class="markdownIt-Anchor" href="#1-什么是队列"></a> 1. 什么是队列？</h1><ol><li>先进者先出，这就是典型的“队列”结构。</li><li>支持两个操作：入队enqueue()，放一个数据到队尾；出队dequeue()，从队头取一个元素。</li><li>所以，和栈一样，队列也是一种操作受限的线性表。</li></ol><h1 id="2-如何实现队列"><a class="markdownIt-Anchor" href="#2-如何实现队列"></a> 2. 如何实现队列？</h1><ol><li>队列API<br />public interface Queue<T> {<br />public void enqueue(T item); //入队<br />public T dequeue(); //出队<br />public int size(); //统计元素数量<br />public boolean isNull(); //是否为空<br />}</li><li>数组实现（顺序队列）：</li><li>链表实现（链式队列）：</li><li>循环队列（基于数组）：</li></ol><h1 id="3-队列有哪些常见的应用"><a class="markdownIt-Anchor" href="#3-队列有哪些常见的应用"></a> 3. 队列有哪些常见的应用？</h1><ol><li>阻塞队列<br />1)在队列的基础上增加阻塞操作，就成了阻塞队列。<br />2）阻塞队列就是在队列为空的时候，从队头取数据会被阻塞，因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后在返回。<br />3）从上面的定义可以看出这就是一个“生产者-消费者模型”。这种基于阻塞队列实现的“生产者-消费者模型”可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了，这时生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续生产。不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据处理效率，比如配置几个消费者，来应对一个生产者。</li><li>并发队列<br />1）在多线程的情况下，会有多个线程同时操作队列，这时就会存在线程安全问题。能够有效解决线程安全问题的队列就称为并发队列。<br />2）并发队列简单的实现就是在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或取操作。<br />3）实际上，基于数组的循环队列利用CAS原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</li><li>线程池资源枯竭是的处理<br />在资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</li></ol><h1 id="4-思考"><a class="markdownIt-Anchor" href="#4-思考"></a> 4. 思考</h1><p>1.除了线程池这种池结构会用到队列排队请求，还有哪些类似线程池结构或者场景中会用到队列的排队请求呢？<br />2.今天讲到并发队列，关于如何实现无锁的并发队列，网上有很多讨论。对这个问题，你怎么看？</p><h1 id="5-练习题"><a class="markdownIt-Anchor" href="#5-练习题"></a> 5. 练习题</h1><p>1.滑动窗口的最大值: <code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/number-of-recent-calls/">剑指 Offer 59</a></p><h2 id="1滑动窗口的最大值"><a class="markdownIt-Anchor" href="#1滑动窗口的最大值"></a> 1.滑动窗口的最大值</h2><p><code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">剑指 Offer 59</a></p><h3 id="思路一"><a class="markdownIt-Anchor" href="#思路一"></a> 思路一</h3><h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSlidingWindow</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    ret := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    queue := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, k)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> k &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line"><span class="comment">// 窗口已经移动到第i个位置， 而queue[0]保存的值已经是窗口之外的索引，因此有queue[0] &lt;= i - k; </span></span><br><span class="line">        <span class="comment">// i &gt;= k 代表，窗口的移动已经超过初始的k个大小。这样才有queue = queue[1:]的意义</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= k &amp;&amp; queue[<span class="number">0</span>] &lt;= i - k &#123;</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 校验新进来的v和queue内保存的值比较，如果有小于v的，那么淘汰掉。目的是为了当窗口不断移动时，始终保持窗口内有最大值，</span></span><br><span class="line">        <span class="comment">// 并且是顺序排列的。 也就是优先队列。 golang的slice可以作为双向队列，左右两边都可以pop</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &amp;&amp; nums[queue[<span class="built_in">len</span>(queue)<span class="number">-1</span>]] &lt;= v &#123;</span><br><span class="line">            queue = queue[:(<span class="built_in">len</span>(queue)<span class="number">-1</span>)]</span><br><span class="line">        &#125;</span><br><span class="line">        queue = <span class="built_in">append</span>(queue, i)</span><br><span class="line">        <span class="keyword">if</span> i &gt;= k - <span class="number">1</span> &#123;</span><br><span class="line">            ret = <span class="built_in">append</span>(ret, nums[queue[<span class="number">0</span>]])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/2020/08/02/Data%20Structure%20and%20Algorithm/%E6%A0%88/"/>
      <url>/2020/08/02/Data%20Structure%20and%20Algorithm/%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是栈"><a class="markdownIt-Anchor" href="#1-什么是栈"></a> 1. 什么是栈？</h1><p>后进者先出，先进者后出，这就是典型的“栈”结构。从栈的操作特性来看，是一种“操作受限”的线性表，只允许在端插入和删除数据。</p><h1 id="2-为什么需要栈"><a class="markdownIt-Anchor" href="#2-为什么需要栈"></a> 2. 为什么需要栈？</h1><ol><li>栈是一种操作受限的数据结构，其操作特性用数组和链表均可实现。</li><li>任何数据结构都是对特定应用场景的抽象，数组和链表虽然使用起来更加灵活，但却暴露了几乎所有的操作，难免会引发错误操作的风险。</li><li>所以，当某个数据集合只涉及在某端插入和删除数据，且满足后进者先出，先进者后出的操作特性时，我们应该首选栈这种数据结构。</li></ol><h1 id="3如何实现栈"><a class="markdownIt-Anchor" href="#3如何实现栈"></a> 3.如何实现栈？</h1><h2 id="31-栈的api"><a class="markdownIt-Anchor" href="#31-栈的api"></a> 3.1 栈的API</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stack</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">interface</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ItemStack the stack of items</span></span><br><span class="line"><span class="keyword">type</span> ItemStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    items []Item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New Create a new ItemStack</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ItemStack)</span> <span class="title">New</span><span class="params">()</span> *<span class="title">ItemStack</span></span> &#123;</span><br><span class="line">    s.items = []Item&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push adds an Item to the top of the stack</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ItemStack)</span> <span class="title">Push</span><span class="params">(t Item)</span></span> &#123;</span><br><span class="line">    s.items = <span class="built_in">append</span>(s.items, t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop removes an Item from the top of the stack</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ItemStack)</span> <span class="title">Pop</span><span class="params">()</span> *<span class="title">Item</span></span> &#123;</span><br><span class="line">    item := s.items[<span class="built_in">len</span>(s.items)<span class="number">-1</span>] <span class="comment">// 后进先出</span></span><br><span class="line">    s.items = s.items[<span class="number">0</span>:<span class="built_in">len</span>(s.items)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> &amp;item</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// size of stack</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ItemStack)</span> <span class="title">size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s.items)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="32-数组实现自动扩容"><a class="markdownIt-Anchor" href="#32-数组实现自动扩容"></a> 3.2 数组实现（自动扩容）</h2><p>时间复杂度分析：根据均摊复杂度的定义，可以得数组实现（自动扩容）符合大多数情况是O(1)级别复杂度，个别情况是O(n)级别复杂度，比如自动扩容时，会进行完整数据的拷贝。<br />空间复杂度分析：在入栈和出栈的过程中，只需要一两个临时变量存储空间，所以O(1)级别。我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。</p><p>3.链表实现<br />时间复杂度分析：压栈和弹栈的时间复杂度均为O(1)级别，因为只需更改单个节点的索引即可。<br />空间复杂度分析：在入栈和出栈的过程中，只需要一两个临时变量存储空间，所以O(1)级别。我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。</p><h1 id="4-栈的应用"><a class="markdownIt-Anchor" href="#4-栈的应用"></a> 4. 栈的应用</h1><h2 id="41-栈在函数调用中的应用"><a class="markdownIt-Anchor" href="#41-栈在函数调用中的应用"></a> 4.1 栈在函数调用中的应用</h2><p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将其中的临时变量作为栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p><h2 id="42-栈在表达式求值中的应用比如3413944-123"><a class="markdownIt-Anchor" href="#42-栈在表达式求值中的应用比如3413944-123"></a> 4.2 栈在表达式求值中的应用（比如：34+13*9+44-12/3）</h2><p>利用两个栈，其中一个用来保存操作数，另一个用来保存运算符。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较，若比运算符栈顶元素优先级高，就将当前运算符压入栈，若比运算符栈顶元素的优先级低或者相同，从运算符栈中取出栈顶运算符，从操作数栈顶取出2个操作数，然后进行计算，把计算完的结果压入操作数栈，继续比较。</p><h2 id="43-栈在括号匹配中的应用比如"><a class="markdownIt-Anchor" href="#43-栈在括号匹配中的应用比如"></a> 4.3 栈在括号匹配中的应用（比如：{}{<a href="">()</a>}）</h2><p>用栈保存为匹配的左括号，从左到右一次扫描字符串，当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号，如果能匹配上，则继续扫描剩下的字符串。如果扫描过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。<br />当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明未匹配的左括号为非法格式。</p><h2 id="44-如何实现浏览器的前进后退功能"><a class="markdownIt-Anchor" href="#44-如何实现浏览器的前进后退功能"></a> 4.4 如何实现浏览器的前进后退功能？</h2><p>我们使用两个栈X和Y，我们把首次浏览的页面依次压如栈X，当点击后退按钮时，再依次从栈X中出栈，并将出栈的数据一次放入Y栈。当点击前进按钮时，我们依次从栈Y中取出数据，放入栈X中。当栈X中没有数据时，说明没有页面可以继续后退浏览了。当Y栈没有数据，那就说明没有页面可以点击前进浏览了。</p><h1 id="5-思考"><a class="markdownIt-Anchor" href="#5-思考"></a> 5. 思考</h1><ol><li>我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？<br />答：因为函数调用的执行顺序符合后进者先出，先进者后出的特点。比如函数中的局部变量的生命周期的长短是先定义的生命周期长，后定义的生命周期短；还有函数中调用函数也是这样，先开始执行的函数只有等到内部调用的其他函数执行完毕，该函数才能执行结束。<br />正是由于函数调用的这些特点，根据数据结构是特定应用场景的抽象的原则，我们优先考虑栈结构。</li><li>我们都知道，JVM 内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储 Java 中的对象。那 JVM 里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？<br />答：JVM里面的栈和我们这里说的是一回事，被称为方法栈。和前面函数调用的作用是一致的，用来存储方法中的局部变量</li></ol><h1 id="6-练习题"><a class="markdownIt-Anchor" href="#6-练习题"></a> 6. 练习题</h1><p>1.有效的括号: <code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/valid-parentheses/">20</a><br />2.最小栈: <code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/min-stack/">155</a><br />3.用栈实现队列: <code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232</a><br />4.比较含退格的字符串: <code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/backspace-string-compare/">844</a><br />5.基本计算器: <code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/basic-calculator/">224</a><br />6.棒球比赛: <code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/baseball-game/">682</a><br />7.下一个更大元素: <code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/next-greater-element-i/">496</a></p><h2 id="1-有效的括号"><a class="markdownIt-Anchor" href="#1-有效的括号"></a> 1. 有效的括号</h2><p><code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/valid-parentheses/">20</a></p><h3 id="思路一"><a class="markdownIt-Anchor" href="#思路一"></a> 思路一</h3><ol><li>初始化栈 S。</li><li>一次处理表达式的每个括号。</li><li>如果遇到开括号，我们只需将其推到栈上即可。这意味着我们将稍后处理它，让我们简单地转到前面的 子表达式。</li><li>如果我们遇到一个闭括号，那么我们检查栈顶的元素。如果栈顶的元素是一个 相同类型的 左括号，那么我们将它从栈中弹出并继续处理。否则，这意味着表达式无效。</li><li>如果到最后我们剩下的栈中仍然有元素，那么这意味着表达式无效。</li></ol><h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    schar := []<span class="keyword">rune</span>(s)</span><br><span class="line"><span class="keyword">var</span> stack []<span class="keyword">rune</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(schar); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> schar[i] == <span class="string">&#x27;(&#x27;</span> || schar[i] == <span class="string">&#x27;[&#x27;</span> || schar[i] == <span class="string">&#x27;&#123;&#x27;</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, schar[i])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> schar[i] == <span class="string">&#x27;)&#x27;</span> &#123;</span><br><span class="line">tem := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">stack = <span class="built_in">append</span>(stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">if</span> tem != <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> schar[i] == <span class="string">&#x27;]&#x27;</span> &#123;</span><br><span class="line">tem := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">stack = <span class="built_in">append</span>(stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">if</span> tem != <span class="string">&#x27;[&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> schar[i] == <span class="string">&#x27;&#125;&#x27;</span> &#123;</span><br><span class="line">tem := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">stack = <span class="built_in">append</span>(stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">if</span> tem != <span class="string">&#x27;&#123;&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-最小栈"><a class="markdownIt-Anchor" href="#2-最小栈"></a> 2. 最小栈</h2><p><code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/min-stack/">155</a></p><h3 id="思路一-2"><a class="markdownIt-Anchor" href="#思路一-2"></a> 思路一</h3><p>常规思路，普通栈操作+ 一遍遍历最小值</p><h4 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    items []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MinStack</span></span> &#123;</span><br><span class="line">    stack := MinStack&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> stack</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    this.items = <span class="built_in">append</span>(this.items, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Pop</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    this.items = <span class="built_in">append</span>(this.items[:<span class="built_in">len</span>(this.items) <span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res := this.items[<span class="built_in">len</span>(this.items) - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">GetMin</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    minV := this.items[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(this.items);i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> minV &gt; this.items[i]&#123;</span><br><span class="line">            minV = this.items[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minV</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-用栈实现队列"><a class="markdownIt-Anchor" href="#3-用栈实现队列"></a> 3. 用栈实现队列</h2><p><code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232</a></p><h3 id="思路一-3"><a class="markdownIt-Anchor" href="#思路一-3"></a> 思路一</h3><p>使用两个栈来模拟队列操作</p><h4 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    input []<span class="keyword">int</span></span><br><span class="line">    output []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MyQueue</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MyQueue&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    this.input = <span class="built_in">append</span>(this.input, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    this.Peek()</span><br><span class="line">    e := this.output[<span class="built_in">len</span>(this.output) - <span class="number">1</span>]</span><br><span class="line">    this.output = this.output[:<span class="built_in">len</span>(this.output) - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the front element. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Peek</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.output) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(this.input) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            this.output = <span class="built_in">append</span>(this.output, this.input[<span class="built_in">len</span>(this.input) - <span class="number">1</span>])</span><br><span class="line">            this.input = this.input[:<span class="built_in">len</span>(this.input) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> this.output[<span class="built_in">len</span>(this.output) - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.input) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(this.output) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-比较含退格的字符串"><a class="markdownIt-Anchor" href="#4-比较含退格的字符串"></a> 4. 比较含退格的字符串</h2><p><code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/backspace-string-compare/">844</a></p><h3 id="思路一-4"><a class="markdownIt-Anchor" href="#思路一-4"></a> 思路一</h3><p>重构字符串，依次压栈，遇到退格就出栈，最后比较两个栈</p><h4 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backspaceCompare</span><span class="params">(S <span class="keyword">string</span>, T <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stackS []<span class="keyword">rune</span></span><br><span class="line">    <span class="keyword">var</span> StackT []<span class="keyword">rune</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> _, item := <span class="keyword">range</span> S &#123;</span><br><span class="line">        <span class="keyword">if</span> item != <span class="string">&#x27;#&#x27;</span> &#123;</span><br><span class="line">            stackS = <span class="built_in">append</span>(stackS,item)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stackS) &gt;<span class="number">0</span> &#123;</span><br><span class="line">                stackS = stackS[:<span class="built_in">len</span>(stackS) - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> T&#123;</span><br><span class="line">        <span class="keyword">if</span> item != <span class="string">&#x27;#&#x27;</span> &#123;</span><br><span class="line">            StackT = <span class="built_in">append</span>(StackT,item)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(StackT) &gt;<span class="number">0</span> &#123;</span><br><span class="line">                StackT = StackT[:<span class="built_in">len</span>(StackT) - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stackS) &gt;<span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(StackT)&gt;<span class="number">0</span> &#123;</span><br><span class="line">        itemS := stackS[<span class="built_in">len</span>(stackS)<span class="number">-1</span>]</span><br><span class="line">        itemT := StackT[<span class="built_in">len</span>(StackT)<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> (itemS != itemT)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        stackS = stackS[:<span class="built_in">len</span>(stackS) - <span class="number">1</span>]</span><br><span class="line">        StackT = StackT[:<span class="built_in">len</span>(StackT) - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(stackS) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(StackT)  == <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-基本计算器"><a class="markdownIt-Anchor" href="#5-基本计算器"></a> 5. 基本计算器</h2><p><code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/basic-calculator/">224</a></p><h3 id="思路一-5"><a class="markdownIt-Anchor" href="#思路一-5"></a> 思路一</h3><p>在遍历s的过程中，再未遇到’(‘之前，一直计算并累计当前的计算结果；遇到’('时，将当前计算结果压栈。<br />另外，通过引入sign符号，避免对&quot;+&quot;、“-”号的多次判断：</p><h4 id="代码-5"><a class="markdownIt-Anchor" href="#代码-5"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">stack := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">res := <span class="number">0</span></span><br><span class="line">sign := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span> &#123;</span><br><span class="line">num := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> s[i] &lt; <span class="string">&#x27;0&#x27;</span> || s[i] &gt; <span class="string">&#x27;9&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">num = num*<span class="number">10</span> + <span class="keyword">int</span>(s[i]-<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">res = res + sign*num</span><br><span class="line">i--</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">switch</span> s[i] &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">sign = <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">sign = <span class="number">-1</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">stack = <span class="built_in">append</span>(stack, res, sign)</span><br><span class="line">res, sign = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">sign := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">num := stack[<span class="built_in">len</span>(stack)<span class="number">-2</span>]</span><br><span class="line">res = num + sign*res</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-2</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-棒球比赛"><a class="markdownIt-Anchor" href="#6-棒球比赛"></a> 6. 棒球比赛</h2><p><code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/baseball-game/">682</a></p><h3 id="思路一-6"><a class="markdownIt-Anchor" href="#思路一-6"></a> 思路一</h3><ol><li>准备一个栈保存数据</li><li>从前往后遍历ops</li><li>如果是+ 计算stack 最后两位的加和score, 并把score入栈</li><li>如果是D 计算stack 最后一位的两倍score,并把score入栈</li><li>如果是C stack 栈顶出栈</li><li>遍历stack,计算加和</li></ol><h4 id="代码-6"><a class="markdownIt-Anchor" href="#代码-6"></a> 代码</h4> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">calPoints</span><span class="params">(ops []<span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stack []<span class="keyword">int</span></span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(ops); i++ &#123;</span><br><span class="line">       </span><br><span class="line">            <span class="keyword">switch</span> ops[i] &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                score := stack[<span class="built_in">len</span>(stack) <span class="number">-1</span> ]+ stack[<span class="built_in">len</span>(stack)<span class="number">-2</span>]</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, score)</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;D&quot;</span>:</span><br><span class="line">                 score := stack[<span class="built_in">len</span>(stack) <span class="number">-1</span> ] * <span class="number">2</span> </span><br><span class="line">                 stack = <span class="built_in">append</span>(stack, score)</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;C&quot;</span>:</span><br><span class="line">                stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                num,_ := strconv.Atoi(ops[i])</span><br><span class="line">                stack = <span class="built_in">append</span>(stack,num)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(stack); i++&#123;</span><br><span class="line">        res = res + stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>-i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-下一个更大元素"><a class="markdownIt-Anchor" href="#7-下一个更大元素"></a> 7. 下一个更大元素</h2><p><code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/next-greater-element-i/">496</a></p><h3 id="思路一-7"><a class="markdownIt-Anchor" href="#思路一-7"></a> 思路一</h3><p>先找到num2的单调增的栈 + map 记录</p><h4 id="代码-7"><a class="markdownIt-Anchor" href="#代码-7"></a> 代码</h4>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">nextGreaterElement</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> stack []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums2 &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(stack) != <span class="number">0</span> &amp;&amp; v &gt; stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] &#123;</span><br><span class="line">m[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] = v</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(stack) != <span class="number">0</span> &#123;</span><br><span class="line">m[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] = <span class="number">-1</span></span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> nums1 &#123;</span><br><span class="line">nums1[k] = m[v]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums1</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2020/08/01/Data%20Structure%20and%20Algorithm/%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/08/01/Data%20Structure%20and%20Algorithm/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-常见的链表结构"><a class="markdownIt-Anchor" href="#1-常见的链表结构"></a> 1. 常见的链表结构</h1><h1 id="11-单链表"><a class="markdownIt-Anchor" href="#11-单链表"></a> 1.1  单链表：</h1><p>每个节点除了存储数据之外，还有记录下一个节点的地址，这样才能串联起来，记录下一个节点地址的指针就是「后续指针next」。其中有两个特殊的节点为「头结点」和「尾节点」，头结点记录链表的基地址，尾节点记录下一个节点地址是NULL，代表链表的最后一个节点。</p><ul><li><p>链表增删效率高<br />对于链表（存储数据无需连续性）的增删，只需要考虑指针的改变，复杂度为O（1）。</p></li><li><p>链表访问慢<br />由于不像数组那样可以根据首选地址和下标计算出内存地址，只能通过遍历节点获取地址。时间复杂度为0（n）。</p></li></ul><h2 id="12-循环链表"><a class="markdownIt-Anchor" href="#12-循环链表"></a> 1.2 循环链表</h2><p>是特殊的单链表，尾节点指针指向链表的头结点。</p><h2 id="13-双向链表"><a class="markdownIt-Anchor" href="#13-双向链表"></a> 1.3 双向链表</h2><p>支持双向，除了「后续指针next」还有「前驱指针prev」<br />相比单链表和双链表，增删查效率高，内存消耗高。</p><h2 id="14-空间换时间时间换空间"><a class="markdownIt-Anchor" href="#14-空间换时间时间换空间"></a> 1.4 空间换时间，时间换空间</h2><p>对于执行慢的程序–&gt;空间换时间<br />对于消耗内存多的程序–&gt;时间换空间</p><h1 id="2-链表和数组的区别"><a class="markdownIt-Anchor" href="#2-链表和数组的区别"></a> 2. 链表和数组的区别</h1><h2 id="21-底层存储结构"><a class="markdownIt-Anchor" href="#21-底层存储结构"></a> 2.1 底层存储结构：</h2><p>数组需要一块连续的内存空间存储<br />链表通过“指针”将一组零散的内存块串联起来使用</p><h2 id="22-性能"><a class="markdownIt-Anchor" href="#22-性能"></a> 2.2 性能：</h2><ol><li><p>链表和数组的（增删查）时间复杂度正好相反。</p></li><li><p>数组使用连续的内存空间，可以借助缓存机制提高效率。<br />链表不连续，所以无法借助缓存机制。</p></li><li><p>数组大小固定，当要申请更大的空间，需要拷贝数据，很耗时。<br />链表则支持动态扩容。</p></li><li><p>相对来说链表比较耗内存，因为需要记录节点指针，内存消耗翻倍。</p></li></ol><h1 id="3-如何优雅的写出链表代码"><a class="markdownIt-Anchor" href="#3-如何优雅的写出链表代码"></a> 3. 如何优雅的写出链表代码</h1><h2 id="31-理解指针或引用的含义"><a class="markdownIt-Anchor" href="#31-理解指针或引用的含义"></a> 3.1 理解指针或引用的含义</h2><ol><li>含义：将某个变量（对象）赋值给指针（引用），实际上就是就是将这个变量（对象）的地址赋值给指针（引用）。</li><li>示例：<br />p—&gt;next = q; 表示p节点的后继指针存储了q节点的内存地址。<br />p—&gt;next = p—&gt;next—&gt;next; 表示p节点的后继指针存储了p节点的下下个节点的内存地址。</li></ol><h2 id="32-警惕指针丢失和内存泄漏单链表"><a class="markdownIt-Anchor" href="#32-警惕指针丢失和内存泄漏单链表"></a> 3.2 警惕指针丢失和内存泄漏（单链表）</h2><h3 id="321-插入节点"><a class="markdownIt-Anchor" href="#321-插入节点"></a> 3.2.1 插入节点</h3><p>在节点a和节点b之间插入节点x，b是a的下一节点，，p指针指向节点a，则造成指针丢失和内存泄漏的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p—&gt;next = x;</span><br><span class="line">x—&gt;next = p—&gt;next; </span><br></pre></td></tr></table></figure><p>显然这会导致x节点的后继指针指向自身。<br />正确的写法是2句代码交换顺序，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x—&gt;next = p—&gt;next; </span><br><span class="line">p—&gt;next = x;</span><br></pre></td></tr></table></figure><h3 id="322-删除节点"><a class="markdownIt-Anchor" href="#322-删除节点"></a> 3.2.2 删除节点</h3><p>在节点a和节点b之间删除节点b，b是a的下一节点，p指针指向节点a：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p—&gt;next = p—&gt;next—&gt;next;</span><br></pre></td></tr></table></figure><h2 id="33-利用哨兵简化实现难度"><a class="markdownIt-Anchor" href="#33-利用哨兵简化实现难度"></a> 3.3 利用“哨兵”简化实现难度</h2><h3 id="331-什么是哨兵"><a class="markdownIt-Anchor" href="#331-什么是哨兵"></a> 3.3.1 什么是“哨兵”？</h3><p>链表中的“哨兵”节点是解决边界问题的，不参与业务逻辑。如果我们引入“哨兵”节点，则不管链表是否为空，head指针都会指向这个“哨兵”节点。我们把这种有“哨兵”节点的链表称为带头链表，相反，没有“哨兵”节点的链表就称为不带头链表。</p><h3 id="332-未引入哨兵的情况"><a class="markdownIt-Anchor" href="#332-未引入哨兵的情况"></a> 3.3.2 未引入“哨兵”的情况</h3><p>如果在p节点后插入一个节点，只需2行代码即可搞定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_node—&gt;next = p—&gt;next;</span><br><span class="line">p—&gt;next = new_node;</span><br></pre></td></tr></table></figure><p>但，若向空链表中插入一个节点，则代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head == null)&#123;</span><br><span class="line">    head = new_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要删除节点p的后继节点，只需1行代码即可搞定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p—&gt;next = p—&gt;next—&gt;next;</span><br></pre></td></tr></table></figure><p>但，若是删除链表的最后一个节点（链表中只剩下这个节点），则代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head—&gt;next == null)&#123;</span><br><span class="line">head = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的情况可以看出，针对链表的插入、删除操作，需要对插入第一个节点和删除最后一个节点的情况进行特殊处理。这样代码就会显得很繁琐，所以引入“哨兵”节点来解决这个问题。</p><h3 id="333-引入哨兵的情况"><a class="markdownIt-Anchor" href="#333-引入哨兵的情况"></a> 3.3.3 引入“哨兵”的情况</h3><p>“哨兵”节点不存储数据，无论链表是否为空，head指针都会指向它，作为链表的头结点始终存在。这样，插入第一个节点和插入其他节点，删除最后一个节点和删除其他节点都可以统一为相同的代码实现逻辑了。</p><h3 id="334-哨兵还有哪些应用场景"><a class="markdownIt-Anchor" href="#334-哨兵还有哪些应用场景"></a> 3.3.4 “哨兵”还有哪些应用场景？</h3><p>但总结起来，哨兵最大的作用就是简化边界条件的处理。</p><h2 id="34-重点留意边界条件处理"><a class="markdownIt-Anchor" href="#34-重点留意边界条件处理"></a> 3.4 重点留意边界条件处理</h2><p>经常用来检查链表是否正确的边界4个边界条件：<br />1.如果链表为空时，代码是否能正常工作？<br />2.如果链表只包含一个节点时，代码是否能正常工作？<br />3.如果链表只包含两个节点时，代码是否能正常工作？<br />4.代码逻辑在处理头尾节点时是否能正常工作？</p><h2 id="35-举例画图辅助思考"><a class="markdownIt-Anchor" href="#35-举例画图辅助思考"></a> 3.5 举例画图，辅助思考</h2><p>核心思想：释放脑容量，留更多的给逻辑思考，这样就会感觉到思路清晰很多。</p><h2 id="36-多写多练没有捷径"><a class="markdownIt-Anchor" href="#36-多写多练没有捷径"></a> 3.6 多写多练，没有捷径</h2><p>0.请判断一个链表是否为回文链表 :<code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/palindrome-linked-list">234</a></p><p>5个常见的链表操作：<br />1.单链表反转 : <code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/reverse-linked-list/">206</a><br />2.链表中环的检测 :<code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/linked-list-cycle/">141</a><br />3.两个有序链表合并:<code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21</a><br />4.删除链表倒数第n个节点:<code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19</a><br />5.求链表的中间节点:<code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876</a></p><h1 id="4-练习题"><a class="markdownIt-Anchor" href="#4-练习题"></a> 4 练习题</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val  <span class="keyword">int</span></span><br><span class="line">    Next *ListNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0-请判断一个链表是否为回文链表"><a class="markdownIt-Anchor" href="#0-请判断一个链表是否为回文链表"></a> 0. 请判断一个链表是否为回文链表。</h2><p><code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/palindrome-linked-list">234</a></p><h3 id="思路一"><a class="markdownIt-Anchor" href="#思路一"></a> 思路一</h3><p>使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。在慢指针前进的过程中，同时修改其 next 指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等。</p><ol><li>首先是利用快慢指针找到链表的中点, 其思路是:<br />快指针与慢指针均从头出发,但快指针的速度是慢指针的两倍, 故当快指针到达链表的尾部时, 慢指针的位置就是终点;</li><li>由于链表的节点数可能为偶数,对于偶数的情形, 快指针所在的终点其实并非是真的在最后一个节点上, 而是指向倒数第二个,故此时慢指针所指向的其实是在前半段链表中, 所以对于这种情形,需要调整下慢指针的位置,将其移后一位;</li><li>以慢指针作为起点,反转后半段链表, 并用一个新指针指向反转后的链表头;</li><li>前后两段链表进行逐个节点的比较, 循环终止条件是前半段链表的指针不等于慢指针, 此时慢指针充当中间界碑;</li><li>链表恢复,其实就是将后半段,再反转回来. (算法做题层面不用实现)</li></ol><h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// 如果head为空，返回false</span></span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义快慢两个指针</span></span><br><span class="line">slow, fast := head, head</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找中点</span></span><br><span class="line"><span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//奇数链表取下一个节点</span></span><br><span class="line"><span class="keyword">if</span> fast != <span class="literal">nil</span> &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转后半段</span></span><br><span class="line"><span class="keyword">var</span> newHead *ListNode</span><br><span class="line"><span class="keyword">for</span> slow != <span class="literal">nil</span> &#123;</span><br><span class="line">tem := slow.Next</span><br><span class="line">slow.Next = newHead</span><br><span class="line">newHead = slow</span><br><span class="line"></span><br><span class="line">slow = tem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转后的值和前半段比较</span></span><br><span class="line"><span class="keyword">for</span> newHead != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> newHead.Val != head.Val &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">newHead = newHead.Next</span><br><span class="line">head = head.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1单链表反转"><a class="markdownIt-Anchor" href="#1单链表反转"></a> 1.单链表反转</h2><p><code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/reverse-linked-list/">206</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> newHead *ListNode</span><br><span class="line">    <span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">        tem := head.Next</span><br><span class="line">        head.Next = newHead</span><br><span class="line">        newHead = head</span><br><span class="line">        head =tem</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2链表中环的检测"><a class="markdownIt-Anchor" href="#2链表中环的检测"></a> 2.链表中环的检测</h2><p><code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/linked-list-cycle/">141</a></p><h3 id="思路一暴力破解"><a class="markdownIt-Anchor" href="#思路一暴力破解"></a> 思路一：暴力破解</h3><ol><li>设置头部哨兵</li><li>从头到尾遍历链表 如果可以遍历完，即 head.Next == nil, 说明链表中不存在环</li><li>每次拿到一个节点p， 从头遍历直到p, 查找是否有p.next 指向过去的某个节点</li></ol><h4 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head ==<span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//哨兵</span></span><br><span class="line">    guard := head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> head.Next != <span class="literal">nil</span>  &#123;</span><br><span class="line">        <span class="keyword">if</span> head == head.Next &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        head = head.Next</span><br><span class="line">        tem := guard</span><br><span class="line">        <span class="keyword">for</span> tem != head &#123;</span><br><span class="line">            <span class="keyword">if</span> tem == head.Next &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            tem = tem.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路二利用map"><a class="markdownIt-Anchor" href="#思路二利用map"></a> 思路二：利用Map</h3><p>通过hash 表来判断链表是否成环</p><h4 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head ==<span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    collection := <span class="built_in">make</span>(<span class="keyword">map</span>[*ListNode]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> head.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> _, exist := collection[head]; exist &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            collection[head] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路三-标准题解"><a class="markdownIt-Anchor" href="#思路三-标准题解"></a> 思路三： 标准题解</h3><p>通过具有不同速度的快慢两个指针遍历链表，空间复杂度可以降低至O(1)；慢指针每次移动一步， 快指针每次移动两部，如果两个指针相遇说明有环；<br />情形类似于两个不同速度的人在操场跑步，跑的快的会追上跑的慢的</p><h4 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head ==<span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   slow, fast := head, head</span><br><span class="line">   <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">       slow = slow.Next</span><br><span class="line">       fast = fast.Next.Next</span><br><span class="line">       <span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3两个有序链表合并"><a class="markdownIt-Anchor" href="#3两个有序链表合并"></a> 3.两个有序链表合并</h2><p><code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21</a></p><h3 id="思路一-2"><a class="markdownIt-Anchor" href="#思路一-2"></a> 思路一：</h3><h4 id="代码-5"><a class="markdownIt-Anchor" href="#代码-5"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">unc mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123;</span><br><span class="line"></span><br><span class="line">    p1, p2 := l1, l2</span><br><span class="line"></span><br><span class="line">    pre :=  &amp;ListNode&#123;&#125;</span><br><span class="line">    result := pre</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p1 != <span class="literal">nil</span> &amp;&amp; p2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p1.Val &lt;= p2.Val &#123;</span><br><span class="line">            pre.Next = p1</span><br><span class="line">            p1 = p1.Next</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.Next = p2</span><br><span class="line">            p2 = p2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> p1 == <span class="literal">nil</span> &#123;</span><br><span class="line">        pre.Next = p2</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        pre.Next = p1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4删除链表倒数第n个节点"><a class="markdownIt-Anchor" href="#4删除链表倒数第n个节点"></a> 4.删除链表倒数第n个节点</h2><p><code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19</a></p><h3 id="思路一-3"><a class="markdownIt-Anchor" href="#思路一-3"></a> 思路一</h3><ol><li>首先我们定义好哨兵节点result，指向哨兵节点的目标元素指针cur，以及目标指针cur的前一个指针pre，此时pre指向nil。</li><li>接下来我们开始遍历整个链表。</li><li>当head移动到距离目标元素cur的距离为N-1时，同时开始移动cur。</li><li>当链表遍历完之后，此时head指向nil，这时的cur就是我们要找的待删除的目标元素。</li><li>最后我们通过pre.Next = pre.Next.Next完成删除操作，就完成了整个解题过程。</li></ol><h4 id="代码-6"><a class="markdownIt-Anchor" href="#代码-6"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    result := &amp;ListNode&#123;&#125;</span><br><span class="line">    result.Next = head</span><br><span class="line">    <span class="keyword">var</span> pre *ListNode</span><br><span class="line">    cur := result</span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt;= n &#123;</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = cur.Next</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.Next</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    pre.Next = pre.Next.Next</span><br><span class="line">    <span class="keyword">return</span> result.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5求链表的中间节点"><a class="markdownIt-Anchor" href="#5求链表的中间节点"></a> 5.求链表的中间节点</h2><p><code>leetcode</code>题号: <a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876</a></p><h3 id="思路一-4"><a class="markdownIt-Anchor" href="#思路一-4"></a> 思路一</h3><p>快慢两个指针，慢的每次走一步，快的每次走两步，快的走到链尾的时候，慢指针正好走到中间</p><h4 id="代码-7"><a class="markdownIt-Anchor" href="#代码-7"></a> 代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">slow, fast := head, head</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fast != <span class="literal">nil</span>  &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">    slow = slow.Next</span><br><span class="line">    fast = fast.Next.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2020/08/01/Data%20Structure%20and%20Algorithm/%E6%95%B0%E7%BB%84/"/>
      <url>/2020/08/01/Data%20Structure%20and%20Algorithm/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>数组看起来简单基础，但是很多人没有理解这个数据结构的精髓。带着为什么数组要从0开始编号，而不是从1开始的问题，进入主题。</p><h1 id="1-数组如何实现随机访问"><a class="markdownIt-Anchor" href="#1-数组如何实现随机访问"></a> 1. 数组如何实现随机访问</h1><ol><li><p>数组是一种线性数据结构，用连续的存储空间存储相同类型数据<br />I. 线性表：数组、链表、队列、栈 非线性表：树 图<br />II. 连续的内存空间、相同的数据，所以数组可以随机访问，但对数组进行删除插入，为了保证数组的连续性，就要做大量的数据搬移工作</p></li><li><p>数组如何实现下标随机访问。<br /><code>a[k]_address = base_address + k * type_size</code></p></li><li><p>纠正数组和链表的错误认识。<br />数组的查找操作时间复杂度并不是O(1)。即便是排好的数组，用二分查找，时间复杂度也是O（logn）。<br />正确表述：数组支持随机访问，根据下标随机访问的时间复杂度为O（1）</p></li></ol><h1 id="2-低效的插入和删除"><a class="markdownIt-Anchor" href="#2-低效的插入和删除"></a> 2. 低效的插入和删除</h1><ol><li>插入：从最好O(1) 最坏O(n) 平均O(n)</li><li>插入：数组若无序，插入新的元素时，可以将第K个位置元素移动到数组末尾，把心的元素，插入到第k个位置，此处复杂度为O(1)。作者举例说明</li><li>删除：从最好O(1) 最坏O(n) 平均O(n)</li><li>多次删除集中在一起，提高删除效率<br />记录下已经被删除的数据，每次的删除操作并不是搬移数据，只是记录数据已经被删除，当数组没有更多的存储空间时，再触发一次真正的删除操作。即JVM标记清除垃圾回收算法。</li></ol><h1 id="3-警惕数组的访问越界问题"><a class="markdownIt-Anchor" href="#3-警惕数组的访问越界问题"></a> 3. 警惕数组的访问越界问题</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(; i&lt;=<span class="number">3</span>; i++)&#123;</span><br><span class="line">        arr[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用C语言循环越界访问的例子说明访问越界的bug。此例在《C陷阱与缺陷》出现过，很惭愧，看过但是现在也只有一丢丢印象。翻了下书，替作者加上一句话：如果用来编译这段程序的编译器按照内存地址递减的方式给变量分配内存，那么内存中的i将会被置为0，则为死循环永远出不去。</p><p><code>注</code>: gcc有一个编译选项（-fno-stack-protector）用于关闭堆栈保护功能。默认情况下启动了堆栈保护，不管i声明在前还是在后，i都会在数组之后压栈，只会循环4次；如果关闭堆栈保护功能，则会出现死循环。<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gccstack/index.html">请参考</a></p><h1 id="4-容器能否完全替代数组"><a class="markdownIt-Anchor" href="#4-容器能否完全替代数组"></a> 4. 容器能否完全替代数组</h1><p>相比于数字，java中的ArrayList封装了数组的很多操作，并支持动态扩容。一旦超过存储容量，扩容时比较耗内存，因为涉及到内存申请和数据搬移。<br />数组适合的场景：</p><ol><li>Java ArrayList 的使用涉及装箱拆箱，有一定的性能损耗，如果特别管柱性能，可以考虑数组</li><li>若数据大小事先已知，并且涉及的数据操作非常简单，可以使用数组</li><li>表示多维数组时，数组往往更加直观。</li><li>业务开发容器即可，底层开发，如网络框架，性能优化。选择数组。</li></ol><h1 id="5-解答开篇问题"><a class="markdownIt-Anchor" href="#5-解答开篇问题"></a> 5. 解答开篇问题</h1><ol><li>从偏移角度理解a[0] 0为偏移量，如果从1计数，会多出K-1。增加cpu负担。为什么循环要写成for(int i = 0;i&lt;3;i++) 而不是for(int i = 0 ;i&lt;=2;i++)。第一个直接就可以算出3-0 = 3 有三个数据，而后者 2-0+1个数据，多出1个加法运算，很恼火。</li><li>也有一定的历史原因</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang基础知识</title>
      <link href="/2020/06/12/Interview/Golang%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/06/12/Interview/Golang%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>ref: <a href="https://blog.csdn.net/yang731227/article/details/90637535?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-12.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-12.nonecase">https://blog.csdn.net/yang731227/article/details/90637535?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-12.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-12.nonecase</a></p><h3 id="q1-写出下面代码输出内容"><a class="markdownIt-Anchor" href="#q1-写出下面代码输出内容"></a> Q1: 写出下面代码输出内容</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    defer_call()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">defer_call</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">&quot;打印前&quot;</span>) &#125;()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">&quot;打印中&quot;</span>) &#125;()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">&quot;打印后&quot;</span>) &#125;()</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;触发异常&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考点：defer执行顺序<br />解答：<br />defer 是后进先出。<br />panic 需要等defer 结束后才会向上传递。 出现panic恐慌时候，会先按照defer的后入先出的顺序执行，最后才会执行panic。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">打印后</span><br><span class="line">打印中</span><br><span class="line">打印前</span><br><span class="line">panic: 触发异常</span><br></pre></td></tr></table></figure><h3 id="q2-以下代码有什么问题说明原因"><a class="markdownIt-Anchor" href="#q2-以下代码有什么问题说明原因"></a> Q2: 以下代码有什么问题，说明原因</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pase_student</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*student)</span><br><span class="line">    stus := []student&#123;</span><br><span class="line">        &#123;Name: <span class="string">&quot;zhou&quot;</span>, Age: <span class="number">24</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">&quot;li&quot;</span>, Age: <span class="number">23</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">&quot;wang&quot;</span>, Age: <span class="number">22</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, stu := <span class="keyword">range</span> stus &#123;</span><br><span class="line">        m[stu.Name] = &amp;stu</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考点：foreach<br />解答：<br />这样的写法初学者经常会遇到的，很危险！ 与Java的foreach一样，都是使用副本的方式。所以m[<a href="http://stu.Name">stu.Name</a>]=&amp;stu实际上一致指向同一个指针， 最终该指针的值为遍历的最后一个struct的值拷贝。 就像想修改切片元素的属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for _, stu :&#x3D; range stus &#123;</span><br><span class="line">    stu.Age &#x3D; stu.Age+10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是不可行的。 大家可以试试打印出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func pase_student() &#123;</span><br><span class="line">    m :&#x3D; make(map[string]*student)</span><br><span class="line">    stus :&#x3D; []student&#123;</span><br><span class="line">        &#123;Name: &quot;zhou&quot;, Age: 24&#125;,</span><br><span class="line">        &#123;Name: &quot;li&quot;, Age: 23&#125;,</span><br><span class="line">        &#123;Name: &quot;wang&quot;, Age: 22&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 错误写法</span><br><span class="line">    for _, stu :&#x3D; range stus &#123;</span><br><span class="line">        m[stu.Name] &#x3D; &amp;stu</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    for k,v:&#x3D;range m&#123;</span><br><span class="line">        println(k,&quot;&#x3D;&gt;&quot;,v.Name)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 正确</span><br><span class="line">    for i:&#x3D;0;i&lt;len(stus);i++  &#123;</span><br><span class="line">        m[stus[i].Name] &#x3D; &amp;stus[i]</span><br><span class="line">    &#125;</span><br><span class="line">    for k,v:&#x3D;range m&#123;</span><br><span class="line">        println(k,&quot;&#x3D;&gt;&quot;,v.Name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="q3下面的代码会输出什么并说明原因"><a class="markdownIt-Anchor" href="#q3下面的代码会输出什么并说明原因"></a> Q3：下面的代码会输出什么，并说明原因</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wg.Add(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;A: &quot;</span>, i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;B: &quot;</span>, i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考点：go执行的随机性和闭包<br />解答：<br />谁也不知道执行后打印的顺序是什么样的，所以只能说是随机数字。 但是A:均为输出10，B:从0~9输出(顺序不定)。 第一个go func中i是外部for的一个变量，地址不变化。遍历完成后，最终i=10。 故go func执行时，i的值始终是10。</p><p>第二个go func中i是函数参数，与外部for中的i完全是两个变量。 尾部(i)将发生值拷贝，go func内部指向值拷贝地址</p><h3 id="q4-下面代码会输出什么"><a class="markdownIt-Anchor" href="#q4-下面代码会输出什么"></a> Q4: 下面代码会输出什么</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">ShowA</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;showA&quot;</span>)</span><br><span class="line">    p.ShowB()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">ShowB</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;showB&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">    People</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Teacher)</span> <span class="title">ShowB</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;teacher showB&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := Teacher&#123;&#125;</span><br><span class="line">    t.ShowA()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>考点：go的组合继承<br />解答：<br />这是Golang的组合模式，可以实现OOP的继承。 被组合的类型People所包含的方法虽然升级成了外部类型Teacher这个组合类型的方法（一定要是匿名字段），但它们的方法(ShowA())调用时接受者并没有发生变化。 此时People类型并不知道自己会被什么类型组合，当然也就无法调用方法时去使用未知的组合者Teacher类型的功能。</p><h3 id="q5-下面代码会触发异常吗请详细说明"><a class="markdownIt-Anchor" href="#q5-下面代码会触发异常吗请详细说明"></a> Q5: 下面代码会触发异常吗？请详细说明</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    int_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    string_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">    int_chan &lt;- <span class="number">1</span></span><br><span class="line">    string_chan &lt;- <span class="string">&quot;hello&quot;</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> value := &lt;-int_chan:</span><br><span class="line">        fmt.Println(value)</span><br><span class="line">    <span class="keyword">case</span> value := &lt;-string_chan:</span><br><span class="line">        <span class="built_in">panic</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="q6-下面代码输出什么"><a class="markdownIt-Anchor" href="#q6-下面代码输出什么"></a> Q6: 下面代码输出什么？</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(index <span class="keyword">string</span>, a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ret := a + b</span><br><span class="line">    fmt.Println(index, a, b, ret)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">1</span></span><br><span class="line">    b := <span class="number">2</span></span><br><span class="line">    <span class="keyword">defer</span> calc(<span class="string">&quot;1&quot;</span>, a, calc(<span class="string">&quot;10&quot;</span>, a, b))</span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> calc(<span class="string">&quot;2&quot;</span>, a, calc(<span class="string">&quot;20&quot;</span>, a, b))</span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考点：defer执行顺序<br />解答：<br />这道题类似第1题 需要注意到defer执行顺序和值传递 index:1肯定是最后执行的，但是index:1的第三个参数是一个函数，所以最先被调用calc(“10”,1,2)<mark>&gt;10,1,2,3 执行index:2时,与之前一样，需要先调用calc(“20”,0,2)</mark>&gt;20,0,2,2 执行到b=1时候开始调用，index:2==&gt;calc(“2”,0,2)<mark>&gt;2,0,2,2 最后执行index:1</mark>&gt;calc(“1”,1,3)==&gt;1,1,3,4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10 1 2 3</span><br><span class="line">20 0 2 2</span><br><span class="line">2 0 2 2</span><br><span class="line">1 1 3 4</span><br></pre></td></tr></table></figure><h3 id="q7请写出以下输入内容"><a class="markdownIt-Anchor" href="#q7请写出以下输入内容"></a> Q7:请写出以下输入内容</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考点：make默认值和append<br />解答：<br />make初始化是由默认值的哦，此处默认值为0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0 0 0 0 0 1 2 3]</span><br></pre></td></tr></table></figure><h3 id="q8-下面的代码有什么问题"><a class="markdownIt-Anchor" href="#q8-下面的代码有什么问题"></a> Q8: 下面的代码有什么问题?</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserAges <span class="keyword">struct</span> &#123;</span><br><span class="line">ages <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ua *UserAges)</span> <span class="title">Add</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">ua.Lock()</span><br><span class="line"><span class="keyword">defer</span> ua.Unlock()</span><br><span class="line">ua.ages[name] = age</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ua *UserAges)</span> <span class="title">Get</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> age, ok := ua.ages[name]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="q9-下面的迭代会有什么问题"><a class="markdownIt-Anchor" href="#q9-下面的迭代会有什么问题"></a> Q9: 下面的迭代会有什么问题？</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *threadSafeSet)</span> <span class="title">Iter</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">set.RLock()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> elem := <span class="keyword">range</span> set.s &#123;</span><br><span class="line">ch &lt;- elem</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">set.RUnlock()</span><br><span class="line"> </span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考点：chan缓存池<br />解答：<br />看到这道题，我也在猜想出题者的意图在哪里。 chan?sync.RWMutex?go?chan缓存池?迭代? 所以只能再读一次题目，就从迭代入手看看。 既然是迭代就会要求set.s全部可以遍历一次。但是chan是为缓存的，那就代表这写入一次就会阻塞</p><h3 id="q10以下代码能编译过去吗为什么"><a class="markdownIt-Anchor" href="#q10以下代码能编译过去吗为什么"></a> Q10:以下代码能编译过去吗？为什么？</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">interface</span> &#123;</span><br><span class="line">Speak(<span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Stduent <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Stduent)</span> <span class="title">Speak</span><span class="params">(think <span class="keyword">string</span>)</span> <span class="params">(talk <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> think == <span class="string">&quot;bitch&quot;</span> &#123;</span><br><span class="line">talk = <span class="string">&quot;You are a good boy&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">talk = <span class="string">&quot;hi&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> peo People = Stduent&#123;&#125;</span><br><span class="line">think := <span class="string">&quot;bitch&quot;</span></span><br><span class="line">fmt.Println(peo.Speak(think))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考点：golang的方法集<br />解答：<br />编译不通过！ 做错了！？说明你对golang的方法集还有一些疑问。 一句话：golang的方法集仅仅影响接口实现和方法表达式转化，与通过实例或者指针调用方法无关。</p><h3 id="q11以下代码打印出来什么内容说出为什么"><a class="markdownIt-Anchor" href="#q11以下代码打印出来什么内容说出为什么"></a> Q11:以下代码打印出来什么内容，说出为什么。</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">interface</span> &#123;</span><br><span class="line">Show()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">Show</span><span class="params">()</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> 、、、 &#123;</span><br><span class="line"><span class="keyword">var</span> stu *Student</span><br><span class="line"><span class="keyword">return</span> stu</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> live() == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;AAAAAAA&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;BBBBBBB&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>[引自]：<a href="https://blog.csdn.net/weiyuefei/article/details/77963810?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase">https://blog.csdn.net/weiyuefei/article/details/77963810?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 基础知识 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDaaS Design</title>
      <link href="/2020/04/22/Project/IDaas/"/>
      <url>/2020/04/22/Project/IDaas/</url>
      
        <content type="html"><![CDATA[<h1 id="identity-as-a-service-idaas"><a class="markdownIt-Anchor" href="#identity-as-a-service-idaas"></a> Identity as a Service (IDaaS)</h1><h2 id="1-idaas-是什么"><a class="markdownIt-Anchor" href="#1-idaas-是什么"></a> 1. IDaaS 是什么</h2><p>一个基于API的身份和用户管理系统.</p><h3 id="11-包括什么"><a class="markdownIt-Anchor" href="#11-包括什么"></a> 1.1 包括什么</h3><ul><li>登录、登出、注册</li><li>多重身份验证 (MFA/2FA)</li><li>帐户验证</li><li>帐户恢复</li><li>账户管理</li><li>Admin APIs</li></ul><h3 id="12-怎样做"><a class="markdownIt-Anchor" href="#12-怎样做"></a> 1.2 怎样做</h3><ul><li>安全</li><li>灵活</li><li>云技术</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cloud Native </tag>
            
            <tag> Saas </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VIM</title>
      <link href="/2020/04/22/VIM/VIM/"/>
      <url>/2020/04/22/VIM/VIM/</url>
      
        <content type="html"><![CDATA[<h1 id="使用的配置"><a class="markdownIt-Anchor" href="#使用的配置"></a> 使用的配置</h1><p><code>https://github.com/amix/vimrc</code></p><h1 id="安装很简单"><a class="markdownIt-Anchor" href="#安装很简单"></a> 安装很简单</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone --depth&#x3D;1 https:&#x2F;&#x2F;github.com&#x2F;amix&#x2F;vimrc.git ~&#x2F;.vim_runtime</span><br><span class="line">sh ~&#x2F;.vim_runtime&#x2F;install_awesome_vimrc.sh </span><br></pre></td></tr></table></figure><h1 id="ack-插件"><a class="markdownIt-Anchor" href="#ack-插件"></a> ack 插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">系统需要安装 ack-grep, ubuntu安装命令：sudo apt-get install ack-grep</span><br></pre></td></tr></table></figure><h1 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h1><ul><li><p>全局查找文件(ctrlp插件)</p><p><code>ctrl + f</code> --打开全局文件搜索面板<br /><code>Esc</code> --退出全局文件搜索面板</p></li><li><p>tab(标签)相关</p><p><code>gt</code> --后一个标签<br /><code>gT</code> --前一个标签<br /><code>num + gt</code> --跳转至第num个标签<br /><code>,tl</code> --上一次的标签<br /><code>:q</code> --关闭标签<br /><code>:Te</code> --新建标签，并打开当前文件目录<br /><code>,tn</code> --新建空白标签</p></li><li><p>目录树(NERD_tree插件)</p><p><code>,nn</code> --打开目录树<br /><code>,nn</code> --关闭目录树</p></li><li><p>窗口相关<br /><code>ctrl + w + q</code> --关闭窗口<br /><code>:q</code> --关闭窗口，窗口只有一个tab的情况<br /><code>ctrl + w + w</code> --切换窗口<br /><code>:sp</code> --竖直方向上拆分当前窗口<br /><code>:vsp</code> --水平方向上拆分当前窗口</p></li><li><p>如何打开一个工程</p><p>在某个工程的根目录下输入打开vim，则该vim窗口的文件操作默认为整个工程，比如全局搜索文件或字段</p></li><li><p>全局搜索字段(ack插件)</p><p><code>,g</code> --打开全局字段搜索面板，默认大小写敏感，-i 不区分大小写，-w 全词匹配<br /><code>q</code> --退出全局字段搜索面板</p></li><li><p>当前文件所在的目录</p><p><code>:E</code> --打开当前目录，一般用于切换当前目录的文件<br /><code>:Te</code> --新建标签并打开当前目录，一般用于打开当前目录下的其它文件</p></li><li><p>查看最近打开的文件列表</p><p><code>,f</code> --打开面板<br /><code>q</code> --退出面板</p></li><li><p>当前文件下搜索</p><p><code>*</code> --按下即可搜索光标所在的单词或当前选中的内容，不区分大小写<br /><code>gd</code> --光标移动至单词，按下即可搜索该单词，区分大小写<br /><code>/</code> --输入单词向下搜索<br /><code>？</code> --输入单词向上搜索，一般用于查log，配合G跳转至文件底部使用</p></li><li><p>显示行修改标志</p><p><code>,d</code> --显示与不显示逐一切换</p></li><li><p>光标停留的位置记录</p><p><code>ctrl + o</code> --上一个时间点光标停留的位置<br /><code>ctrl + i</code> --下一个时间点光标停留的位置</p></li><li><p>文件刷新，即重新载入</p><p><code>:e</code> --重新载入<br /><code>:e!</code> --放弃当前修改，强制重新载入<br /><code>:e file_dir</code> --载入 file_dir 路径下的某个文件</p></li><li><p>粘贴0号寄存器的内容</p><p><code>ctrl + r + 0</code> --比如y复制选中的内容后粘贴到命令输入框</p></li><li><p>折叠命令</p><p><code>za</code> --打开或关闭当前折叠<br /><code>zM</code> --关闭所有折叠<br /><code>zR</code> --打开所有折叠</p></li><li><p>跳出双引号继续编辑</p><p>有些时候输入完字符串需要移动光标至双引号外继续输入<br /><code>&quot;</code> --在 &quot; 处输入 &quot; ，即可将光标跳转至当前双引号之外</p></li><li><p>文件路径</p><p><code>:f</code> --查看当前文件路径</p></li><li><p>变量名补全</p><p><code>ctrl + n</code> --自动补全变量名，再次输入匹配下一个</p></li><li><p>代码块补全，只需输入部分代码，然后按tab键</p><p>lua为例：<br /><code>if + tab</code> --if代码块<br /><code>forp + tab</code> --for i,v in pairs() do end 代码块<br /><code>fori + tab</code> --for i,v in ipairs() do end 代码块<br /><code>fun + tab</code> --函数模板代码块</p></li><li><p>代码检错</p><p><code>:ALEToggle</code> --启动检错</p></li><li><p>代码注释</p><p><code>gcc</code> --注释当前行，再次输入则撤销注释<br /><code>num + gcc</code> --注释num行<br /><code>gc</code> --注释选中部分</p></li><li><p>取消搜索高亮</p></li></ul><p><code>:nohl</code></p><ul><li><p>多窗口显示</p><p><code>:sp</code> --水平切分窗口<br /><code>:vsp</code> --垂直切分窗口</p></li></ul><h1 id="vim-编辑相关"><a class="markdownIt-Anchor" href="#vim-编辑相关"></a> vim 编辑相关</h1><ul><li>范围命令</li></ul><p><code>w</code> --光标所在的位置至单词末尾的部分或一个单词，包括单词后的空格<br /><code>iw</code> --光标所在位置的一个单词，不包括单词后的空格<br /><code>aw</code> --光标所在位置的一个单词，包括单词后的空格<br /><code>b</code> --与 w 相反<br /><code>e</code> --end of word，至单词结尾<br /><code>$</code> --至当前行结尾<br /><code>0</code> --至当前行开头</p><ul><li>操作命令</li></ul><p><code>d:</code> delete<br /><code>dd</code> --删除当前行<br /><code>diw</code> --删除光标所在单词<br /><code>dw</code> --正向删除一个单词（光标后的部分）<br /><code>db</code> --逆向删除一个单词（光标前的部分）<br /><code>d$</code> --删除光标所在的位置至本行末尾<br /><code>d0</code> --删除光标所在的位置至本行首部<br /><code>c:</code> change, 与 d 的区别只在于操作后进入插入状态<br /><code>y:</code> yank, 与 d 的区别在于跟范围命令组合后全部为复制操作</p><ul><li>操作命令（少与范围命令组合）</li></ul><p><code>~</code> --大小写字母转换<br /><code>s</code> --删除一个字母，删除后进入插入模式<br /><code>x</code> --删除一个字母，删除后处于命令模式<br /><code>r</code> --即replace，修改替换一个字母，并且替换过后仍然处于命令模式<br /><code>R</code> --修改替换无限多个在字母</p>]]></content>
      
      
      <categories>
          
          <category> VIM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VIM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter</title>
      <link href="/2020/04/22/flutter/flutter/"/>
      <url>/2020/04/22/flutter/flutter/</url>
      
        <content type="html"><![CDATA[<h1 id="1-dart"><a class="markdownIt-Anchor" href="#1-dart"></a> 1. Dart</h1><h2 id="11-basic-grammar"><a class="markdownIt-Anchor" href="#11-basic-grammar"></a> 1.1 Basic Grammar</h2><h3 id="111-variables-and-types"><a class="markdownIt-Anchor" href="#111-variables-and-types"></a> 1.1.1 Variables and Types</h3><p>Dart 是类型安全的语言，并且所有类型都是对象类型，都继承自顶层类型 Object，因此一切变量的值都是类的实例（即对象），甚至数字、布尔值、函数和 null 也都是继承自 Object 的对象。Dart 内置了一些基本类型，如 num、bool、String、List 和 Map。在默认情况下，未初始化的变量的值都是 null。</p><ul><li><code>num</code>: 只有两种子类：即 64 位 int 和符合 64 位 double。前者代表整数类型，而后者则是浮点数的抽象。</li><li><code>bool</code>: true, false</li><li><code>String</code>: 由 UTF-16 的字符串组成。和 JavaScript 一样，构造字符串字面量时既能使用单引号也能使用双引号，还能在字符串中嵌入变量或表达式：你可以使用 ${express} 把一个表达式的值放进字符串。而如果是一个标识符，你可以省略{}。对于多行字符串的构建，你可以通过三个单引号或三个双引号的方式声明，这与 Python 是一致的</li><li><code>List</code>: List<int></li><li><code>Map</code>:Map&lt;String, String&gt;</li></ul><p>常量定义:</p><ul><li><code>const</code>: 表示变量在编译期间即能确定的值；</li><li><code>final</code>: 则不太一样，用它定义的变量可以在运行时确定值，而一旦确定后就不可再变。</li></ul><h3 id="112-process-control"><a class="markdownIt-Anchor" href="#112-process-control"></a> 1.1.2 Process Control</h3><p><code>if-else</code>、<code>for</code>、<code>while</code>、<code>do-while</code>、<code>break/continue</code>、<code>switch-case</code>、<code>assert</code>，由于与其他编程语言类似</p><h3 id="113-function"><a class="markdownIt-Anchor" href="#113-function"></a> 1.1.3 Function</h3><ul><li>不支持重载</li><li>给参数增加{}，以 paramName: value 的方式指定调用参数，也就是可选命名参数</li><li>给参数增加[]，则意味着这些参数是可以忽略的，也就是可选参数</li><li>Dart 还提供了命名构造函数的方式，使得类的实例化过程语义更清晰。此外，与 C++ 类似，Dart 支持初始化列表。在构造函数的函数体真正执行之前，你还有机会给实例变量赋值，甚至重定向至另一个构造函数。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y, z;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y) : z = <span class="number">0</span>; <span class="comment">// 初始化变量z</span></span><br><span class="line">  Point.bottom(<span class="built_in">num</span> x) : <span class="keyword">this</span>(x, <span class="number">0</span>); <span class="comment">// 重定向构造函数</span></span><br><span class="line">  <span class="keyword">void</span> printInfo() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;(<span class="subst">$x</span>,<span class="subst">$y</span>,<span class="subst">$z</span>)&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = Point.bottom(<span class="number">100</span>);</span><br><span class="line">p.printInfo(); <span class="comment">// 输出(100,0,0)</span></span><br></pre></td></tr></table></figure><h3 id="113-class"><a class="markdownIt-Anchor" href="#113-class"></a> 1.1.3 Class</h3><p>Dart 中并没有 public、protected、private 这些关键字，我们只要在声明变量与方法时，在前面加上“<em>”即可作为 private 方法使用。如果不加“</em>”，则默认为 public。不过，“_”的限制范围并不是类访问级别的，而是库访问级别。</p><p><strong>extends</strong>: 继承父类，子类由父类派生，会自动获取父类的成员变量和方法实现，子类可以根据需要覆写(@override)构造函数及父类方法；</p><p><strong>implements</strong>: 接口实现，子类获取到的仅仅是接口的成员变量符号和方法符号，需要重新实现成员变量，以及方法的声明和初始化，否则编译器会报错。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">void</span> printInfo() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;(<span class="subst">$x</span>,<span class="subst">$y</span>)&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Vector继承自Point</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> <span class="keyword">extends</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">  <span class="built_in">num</span> z = <span class="number">0</span>;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> printInfo() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;(<span class="subst">$x</span>,<span class="subst">$y</span>,<span class="subst">$z</span>)&#x27;</span>); <span class="comment">//覆写了printInfo实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Coordinate是对Point的接口实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coordinate</span> <span class="keyword">implements</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x = <span class="number">0</span>, y = <span class="number">0</span>; <span class="comment">//成员变量需要重新声明</span></span><br><span class="line">  <span class="keyword">void</span> printInfo() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;(<span class="subst">$x</span>,<span class="subst">$y</span>)&#x27;</span>); <span class="comment">//成员函数需要重新声明实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> xxx = Vector(); </span><br><span class="line">  xxx</span><br><span class="line">    ..x = <span class="number">1</span></span><br><span class="line">    ..y = <span class="number">2</span></span><br><span class="line">    ..z = <span class="number">3</span>; <span class="comment">//级联运算符，等同于xxx.x=1; xxx.y=2;xxx.z=3;</span></span><br><span class="line">  xxx.printInfo(); <span class="comment">//输出(1,2,3)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> yyy = Coordinate();</span><br><span class="line">  yyy</span><br><span class="line">    ..x = <span class="number">1</span></span><br><span class="line">    ..y = <span class="number">2</span>; <span class="comment">//级联运算符，等同于yyy.x=1; yyy.y=2;</span></span><br><span class="line">  yyy.printInfo(); <span class="comment">//输出(1,2)</span></span><br><span class="line">  <span class="built_in">print</span> (yyy <span class="keyword">is</span> Point); <span class="comment">//true</span></span><br><span class="line">  <span class="built_in">print</span>(yyy <span class="keyword">is</span> Coordinate); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>with</strong>: 混入鼓励代码重用，可以被视为具有实现方法的接口。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coordinate</span> <span class="title">with</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> yyy = Coordinate();</span><br><span class="line">  yyy.printInfo();</span><br><span class="line">  <span class="built_in">print</span> (yyy <span class="keyword">is</span> Point); <span class="comment">//true</span></span><br><span class="line">  <span class="built_in">print</span>(yyy <span class="keyword">is</span> Coordinate); <span class="comment">//true</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="12-features"><a class="markdownIt-Anchor" href="#12-features"></a> 1.2 Features</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义商品Item类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> price;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  Item(name, price) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义购物车类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">DateTime</span> date;</span><br><span class="line">  <span class="built_in">String</span> code;</span><br><span class="line">  <span class="built_in">List</span>&lt;Item&gt; bookings;</span><br><span class="line"></span><br><span class="line">  price() &#123;</span><br><span class="line">    <span class="built_in">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> bookings) &#123;</span><br><span class="line">      sum += i.price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ShoppingCart(name, code) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.code = code;</span><br><span class="line">    <span class="keyword">this</span>.date = <span class="built_in">DateTime</span>.now();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getInfo() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;购物车信息:&#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;\n-----------------------------&#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;\n用户名: &#x27;</span> + name+ </span><br><span class="line">          <span class="string">&#x27;\n优惠码: &#x27;</span> + code + </span><br><span class="line">          <span class="string">&#x27;\n总价: &#x27;</span> + price().toString() +</span><br><span class="line">          <span class="string">&#x27;\n日期: &#x27;</span> + date.toString() +</span><br><span class="line">          <span class="string">&#x27;\n-----------------------------&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  ShoppingCart sc = ShoppingCart(<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line">  sc.bookings = [Item(<span class="string">&#x27;苹果&#x27;</span>,<span class="number">10.0</span>), Item(<span class="string">&#x27;鸭梨&#x27;</span>,<span class="number">20.0</span>)];</span><br><span class="line">  <span class="built_in">print</span>(sc.getInfo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其他编程语言中，在构造函数的函数体内，将初始化参数赋值给实例变量的方式非常常见。而在 Dart 里，我们可以利用语法糖以及初始化列表，来简化这样的赋值过程，从而直接省去构造函数的函数体：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> price;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  Item(<span class="keyword">this</span>.name, <span class="keyword">this</span>.price);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">DateTime</span> date;</span><br><span class="line">  <span class="built_in">String</span> code;</span><br><span class="line">  <span class="built_in">List</span>&lt;Item&gt; bookings;</span><br><span class="line">  price() &#123;...&#125;</span><br><span class="line">  <span class="comment">//删掉了构造函数函数体</span></span><br><span class="line">  ShoppingCart(<span class="keyword">this</span>.name, <span class="keyword">this</span>.code) : date = <span class="built_in">DateTime</span>.now();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到在 ShoppingCart 类中，price 属性仅用做计算购物车中商品的价格（而不是像 Item 类那样用于数据存取），因此在继承了 Meta 类后，我改写了 ShoppingCart 类中 price 属性的 get 方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> price;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  Meta(<span class="keyword">this</span>.name, <span class="keyword">this</span>.price);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">extends</span> <span class="title">Meta</span></span>&#123;</span><br><span class="line">  Item(name, price) : <span class="keyword">super</span>(name, price);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> <span class="keyword">extends</span> <span class="title">Meta</span></span>&#123;</span><br><span class="line">  <span class="built_in">DateTime</span> date;</span><br><span class="line">  <span class="built_in">String</span> code;</span><br><span class="line">  <span class="built_in">List</span>&lt;Item&gt; bookings;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">double</span> <span class="keyword">get</span> price &#123;</span><br><span class="line">    <span class="built_in">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> bookings) &#123;</span><br><span class="line">    sum += i.price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  ShoppingCart(name, <span class="keyword">this</span>.code) : date = <span class="built_in">DateTime</span>.now(),<span class="keyword">super</span>(name,<span class="number">0</span>);</span><br><span class="line">  getInfo() &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Item extends Meta&#123;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F;重载了+运算符，合并商品为套餐商品</span><br><span class="line">  Item operator+(Item item) &#x3D;&gt; Item(name + item.name, price + item.price); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ShoppingCart extends Meta&#123;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F;把迭代求和改写为归纳合并</span><br><span class="line">  double get price &#x3D;&gt; bookings.reduce((value, element) &#x3D;&gt; value + element).price;</span><br><span class="line">  ...</span><br><span class="line">  getInfo() &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来再看main函数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  ShoppingCart sc = ShoppingCart(<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line">  sc.bookings = [Item(<span class="string">&#x27;苹果&#x27;</span>,<span class="number">10.0</span>), Item(<span class="string">&#x27;鸭梨&#x27;</span>,<span class="number">20.0</span>)];</span><br><span class="line">  <span class="built_in">print</span>(sc.getInfo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>希望指定参数名：通过给参数增加{}实现</li><li>其次，对一个购物车对象来说，一定会有一个有用户名，但不一定有优惠码。 可选参数 ?? 语法糖和初始化列表</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> <span class="keyword">extends</span> <span class="title">Meta</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//默认初始化方法，转发到withCode里</span></span><br><span class="line">  ShoppingCart(&#123;name&#125;) : <span class="keyword">this</span>.withCode(name:name, code:<span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">//withCode初始化方法，使用语法糖和初始化列表进行赋值，并调用父类初始化方法</span></span><br><span class="line">  ShoppingCart.withCode(&#123;name, <span class="keyword">this</span>.code&#125;) : date = <span class="built_in">DateTime</span>.now(), <span class="keyword">super</span>(name,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//??运算符表示为code不为null，则用原值，否则使用默认值&quot;没有&quot;</span></span><br><span class="line">  getInfo () =&gt; <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">购物车信息:</span></span><br><span class="line"><span class="string">-----------------------------</span></span><br><span class="line"><span class="string">  用户名: <span class="subst">$name</span></span></span><br><span class="line"><span class="string">  优惠码: <span class="subst">$&#123;code??<span class="string">&quot;没有&quot;</span>&#125;</span></span></span><br><span class="line"><span class="string">  总价: <span class="subst">$price</span></span></span><br><span class="line"><span class="string">  Date: <span class="subst">$date</span></span></span><br><span class="line"><span class="string">-----------------------------</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  ShoppingCart sc = ShoppingCart.withCode(name:<span class="string">&#x27;张三&#x27;</span>, code:<span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line">  sc.bookings = [Item(<span class="string">&#x27;苹果&#x27;</span>,<span class="number">10.0</span>), Item(<span class="string">&#x27;鸭梨&#x27;</span>,<span class="number">20.0</span>)];</span><br><span class="line">  <span class="built_in">print</span>(sc.getInfo());</span><br><span class="line"></span><br><span class="line">  ShoppingCart sc2 = ShoppingCart(name:<span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line">  sc2.bookings = [Item(<span class="string">&#x27;香蕉&#x27;</span>,<span class="number">15.0</span>), Item(<span class="string">&#x27;西瓜&#x27;</span>,<span class="number">40.0</span>)];</span><br><span class="line">  <span class="built_in">print</span>(sc2.getInfo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，打印信息。不止 ShoppingCart 类需要，Item 对象也可能需要。因此，需要把打印信息的能力单独封装成一个单独的类 PrintHelper。但ShoppingCart 类本身已经继承自 Meta 类，考虑到 Dart 并不支持多继承，这就需要用到了<code>Mixin</code>。在使用时加上 with 关键字即可。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> price;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="comment">//成员变量初始化语法糖</span></span><br><span class="line">  Meta(<span class="keyword">this</span>.name, <span class="keyword">this</span>.price);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">extends</span> <span class="title">Meta</span></span>&#123;</span><br><span class="line">  Item(name, price) : <span class="keyword">super</span>(name, price);</span><br><span class="line">  <span class="comment">//重载+运算符，将商品对象合并为套餐商品</span></span><br><span class="line">  Item <span class="keyword">operator</span>+(Item item) =&gt; Item(name + item.name, price + item.price); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintHelper</span> </span>&#123;</span><br><span class="line">  printInfo() =&gt; <span class="built_in">print</span>(getInfo());</span><br><span class="line">  getInfo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//with表示以非继承的方式复用了另一个类的成员变量及函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> <span class="keyword">extends</span> <span class="title">Meta</span> <span class="title">with</span> <span class="title">PrintHelper</span></span>&#123;</span><br><span class="line">  <span class="built_in">DateTime</span> date;</span><br><span class="line">  <span class="built_in">String</span> code;</span><br><span class="line">  <span class="built_in">List</span>&lt;Item&gt; bookings;</span><br><span class="line">  <span class="comment">//以归纳合并方式求和</span></span><br><span class="line">  <span class="built_in">double</span> <span class="keyword">get</span> price =&gt; bookings.reduce((value, element) =&gt; value + element).price;</span><br><span class="line">  <span class="comment">//默认初始化函数，转发至withCode函数</span></span><br><span class="line">  ShoppingCart(&#123;name&#125;) : <span class="keyword">this</span>.withCode(name:name, code:<span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">//withCode初始化方法，使用语法糖和初始化列表进行赋值，并调用父类初始化方法</span></span><br><span class="line">  ShoppingCart.withCode(&#123;name, <span class="keyword">this</span>.code&#125;) : date = <span class="built_in">DateTime</span>.now(), <span class="keyword">super</span>(name,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//??运算符表示为code不为null，则用原值，否则使用默认值&quot;没有&quot;</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  getInfo() =&gt; <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">购物车信息:</span></span><br><span class="line"><span class="string">-----------------------------</span></span><br><span class="line"><span class="string">  用户名: <span class="subst">$name</span></span></span><br><span class="line"><span class="string">  优惠码: <span class="subst">$&#123;code??<span class="string">&quot;没有&quot;</span>&#125;</span></span></span><br><span class="line"><span class="string">  总价: <span class="subst">$price</span></span></span><br><span class="line"><span class="string">  Date: <span class="subst">$date</span></span></span><br><span class="line"><span class="string">-----------------------------</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  ShoppingCart.withCode(name:<span class="string">&#x27;张三&#x27;</span>, code:<span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line">  ..bookings = [Item(<span class="string">&#x27;苹果&#x27;</span>,<span class="number">10.0</span>), Item(<span class="string">&#x27;鸭梨&#x27;</span>,<span class="number">20.0</span>)]</span><br><span class="line">  ..printInfo();</span><br><span class="line"></span><br><span class="line">  ShoppingCart(name:<span class="string">&#x27;李四&#x27;</span>)</span><br><span class="line">  ..bookings = [Item(<span class="string">&#x27;香蕉&#x27;</span>,<span class="number">15.0</span>), Item(<span class="string">&#x27;西瓜&#x27;</span>,<span class="number">40.0</span>)]</span><br><span class="line">  ..printInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-flutter"><a class="markdownIt-Anchor" href="#2-flutter"></a> 2. Flutter</h1><p><img src="http://qiniu.gogocoding.cn/mweb/15876095568112-2.png" alt="15876095568112" /></p><h2 id="21-widget"><a class="markdownIt-Anchor" href="#21-widget"></a> 2.1 Widget</h2><p><strong>Widget</strong> 到底是什么？<br />Widget是Flutter的一等公民：<br />Widget 是 Flutter 功能的抽象描述，是视图的配置信息，同样也是数据的映射，是 Flutter 开发框架中最基本的概念。<br />前端框架中常见的名词，比如视图（View）、视图控制器（ViewController）、活动（Activity）、应用（Application）、布局（Layout）等，在 Flutter 中都是 Widget。</p><h3 id="211-statelesswidget-statefulwidget-inheritedwidget"><a class="markdownIt-Anchor" href="#211-statelesswidget-statefulwidget-inheritedwidget"></a> 2.1.1 StatelessWidget、StatefulWidget、InheritedWidget…</h3><p><strong>StatelessWidget</strong>:  Text、Container、Row、Column</p><p>在 Flutter 中，Widget 采用由父到子、自顶向下的方式进行构建，父 Widget 控制着子 Widget 的显示样式，其样式配置由父 Widget 在构建时提供。在创建时，除了这些配置参数之外不依赖于任何其他信息，换句话说，它们一旦创建成功就不再关心、也不响应任何数据变化进行重绘。</p><p><strong>StatefulWidget</strong>: Scaffold、Image、Checkbox</p><p>与 StatelessWidget 相对应的，有一些 Widge的展示，除了父 Widget 初始化时传入的静态配置之外，还需要处理用户的交互（比如，用户点击按钮）或其内部数据的变化（比如，网络数据回包），并体现在 UI 上。换句话说，这些 Widget 创建完成后，还需要关心和响应数据变化来进行重绘。</p><p><strong>InheritedWidget</strong>: Theme、MediaQuery<br />Flutter 中的一个功能型 Widget，适用于在 Widget 树中共享数据的场景。通过它，我们可以高效地将数据在 Widget 树中进行跨层传递。</p><p><code>Detaiil</code>：见3.1 Data Transfer between Widget</p><h2 id="22-layout"><a class="markdownIt-Anchor" href="#22-layout"></a> 2.2 Layout</h2><p>在 Flutter 中一切皆 Widget，那么布局也不例外。但与基本控件元素不同，布局类的 Widget 并不会直接呈现视觉内容，而是作为承载其他子 Widget 的容器。</p><p>这些布局类的 Widget，内部都会包含一个或多个子控件（child: &amp; children:），并且都提供了摆放子控件的不同布局方式，可以实现子控件的对齐、嵌套、层叠和缩放等。而我们要做的就是，通过各种定制化的参数，将其内部的子 Widget 依照自己的布局规则放置在特定的位置上，最终形成一个漂亮的布局。</p><p>Flutter 提供了 <a href="https://flutter.dev/docs/development/ui/widgets/layout">31 种布局</a> Widget，对布局控件的划分非常详细，一些相同（或相似）的视觉效果可以通过多种布局控件实现。</p><p><strong>Demo</strong>: [layout]</p><h3 id="221-单子-widget-布局container-padding-与-center"><a class="markdownIt-Anchor" href="#221-单子-widget-布局container-padding-与-center"></a> 2.2.1 单子 Widget 布局：Container、Padding 与 Center</h3><p>单子 Widget 布局类容器比较简单，一般用来对其唯一的子 Widget 进行样式包装，比如限制大小、添加背景色样式、内间距、旋转变换等。这一类布局 Widget，包括 Container、Padding 与 Center 三种。</p><h3 id="222-多子-widget-布局row-column-与-expanded"><a class="markdownIt-Anchor" href="#222-多子-widget-布局row-column-与-expanded"></a> 2.2.2 多子 Widget 布局：Row、Column 与 Expanded</h3><p>对于拥有多个子 Widget 的布局类容器而言，其布局行为无非就是两种规则的抽象：水平方向上应该如何布局、垂直方向上应该如何布局。</p><ul><li>Row: 水平布局</li><li>Column: 垂直布局</li></ul><h3 id="223-层叠-widget-布局stack-与-positioned"><a class="markdownIt-Anchor" href="#223-层叠-widget-布局stack-与-positioned"></a> 2.2.3 层叠 Widget 布局：Stack 与 Positioned</h3><p>有些时候，我们需要让一个控件叠加在另一个控件的上面，比如在一张图片上放置一段文字，又或者是在图片的某个区域放置一个按钮。这时候，我们就需要用到层叠布局容器 Stack 了。</p><h3 id="224-listview-gridview-customscrollview-sliver"><a class="markdownIt-Anchor" href="#224-listview-gridview-customscrollview-sliver"></a> 2.2.4 ListView 、GridView、CustomScrollView + Sliver</h3><ul><li>ListView</li><li>GridView</li></ul><p>ListView 实现了单一视图下可滚动 Widget 的交互模型，同时也包含了 UI 显示相关的控制逻辑和布局模型。但是，对于某些特殊交互场景，比如多个效果联动、嵌套滚动、精细滑动、视图跟随手势操作等，还需要嵌套多个 ListView 来实现。这时，各自视图的滚动和布局模型就是相互独立、分离的，就很难保证整个页面统一一致的滑动效果。</p><p>在 Flutter 中有一个专门的控件 CustomScrollView，用来处理多个需要自定义滚动效果的 Widget。在 CustomScrollView 中，这些彼此独立的、可滚动的 Widget 被统称为 Sliver。</p><p>ListView 的 Sliver 实现为 SliverList，AppBar 的 Sliver 实现为 SliverAppBar。这些 Sliver 不再维护各自的滚动状态，而是交由 CustomScrollView 统一管理，最终实现滑动效果的一致性。</p><p><a href="https://api.flutter.dev/flutter/widgets/widgets-library.html">参考：widgets library</a></p><p>其他：</p><ul><li><p>可拖动Cell排序的ListView:</p><ul><li><a href="https://cloud.tencent.com/developer/article/1472711">ReorderableListView</a></li><li><a href="https://github.com/hanshengchiu/reorderables">reorderables</a></li></ul></li><li><p>左滑删除</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NzkzMDkxMw==&amp;mid=2247483689&amp;idx=1&amp;sn=c73fcb51e34fec53aff832d0a1f74a48&amp;scene=21#wechat_redirect">Dismissible</a></li></ul></li></ul><h2 id="23-route-and-navigator"><a class="markdownIt-Anchor" href="#23-route-and-navigator"></a> 2.3 Route and Navigator</h2><p>在 Flutter 中，页面之间的跳转是通过 <strong>Route</strong> 和 <strong>Navigator</strong> 来管理的：</p><ul><li>Route 是页面的抽象，主要负责创建对应的界面，接收参数，响应 Navigator 打开和关闭；</li><li>Navigator 则会维护一个路由栈管理 Route，Route 打开即入栈，Route 关闭即出栈，还可以直接替换栈内的某一个 Route。</li></ul><h3 id="231-flutter"><a class="markdownIt-Anchor" href="#231-flutter"></a> 2.3.1 Flutter</h3><p><strong>基本路由</strong>:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RaisedButton(</span><br><span class="line">      <span class="comment">//打开页面</span></span><br><span class="line">      onPressed: ()=&gt; Navigator.push(context, MaterialPageRoute(builder: (context) =&gt; SecondScreen()));</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RaisedButton(</span><br><span class="line">      <span class="comment">// 回退页面</span></span><br><span class="line">      onPressed: ()=&gt; Navigator.pop(context)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>命名路由</strong>:<br />要想通过名字来指定页面切换，我们必须先给应用程序 MaterialApp 提供一个页面名称映射规则，即路由表 routes，这样 Flutter 才知道名字与页面 Widget 的对应关系。</p><p>路由表实际上是一个 Map&lt;String,WidgetBuilder&gt;，其中 key 值对应页面名字，而 value 值则是一个 WidgetBuilder 回调函数，我们需要在这个函数中创建对应的页面。而一旦在路由表中定义好了页面名字，我们就可以使用 Navigator.pushNamed 来打开页面了。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//注册路由</span></span><br><span class="line">    routes:&#123;</span><br><span class="line">      <span class="string">&quot;second_page&quot;</span>:(context)=&gt;SecondPage(),</span><br><span class="line">    &#125;,</span><br><span class="line">);</span><br><span class="line"><span class="comment">//使用名字打开页面</span></span><br><span class="line">Navigator.pushNamed(context,<span class="string">&quot;second_page&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>页面参数</strong>:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开页面时传递字符串参数</span></span><br><span class="line">Navigator.of(context).pushNamed(<span class="string">&quot;second_page&quot;</span>, arguments: <span class="string">&quot;Hey&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">//取出路由参数</span></span><br><span class="line">    <span class="built_in">String</span> msg = ModalRoute.of(context).settings.arguments <span class="keyword">as</span> <span class="built_in">String</span>;</span><br><span class="line">    <span class="keyword">return</span> Text(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="232-flutter_boost"><a class="markdownIt-Anchor" href="#232-flutter_boost"></a> 2.3.2 Flutter_Boost</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FlutterBoost.singleton.open(</span><br><span class="line">    <span class="string">&quot;second_page&quot;</span>,</span><br><span class="line">    urlParams: &#123;<span class="string">&quot;feedId&quot;</span>: <span class="string">&quot;Hey feedId&quot;</span>&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">FlutterBoost.singleton.closeCurrent();</span><br></pre></td></tr></table></figure><p><code>详见</code>：<br /><a href="https://github.com/alibaba/flutter_boost/blob/master/README.md">README</a><br /><a href="https://github.com/alibaba/flutter_boost/blob/master/Frequently%20Asked%20Question.md">Frequently Asked Question</a></p><h1 id="3-flutter-advanced"><a class="markdownIt-Anchor" href="#3-flutter-advanced"></a> 3. Flutter Advanced</h1><h2 id="31-life-cycle"><a class="markdownIt-Anchor" href="#31-life-cycle"></a> 3.1 Life Cycle</h2><ol><li>State 生命周期</li><li>App 生命周期</li></ol><h3 id="311-state-生命周期"><a class="markdownIt-Anchor" href="#311-state-生命周期"></a> 3.1.1 State 生命周期</h3><p><img src="http://qiniu.gogocoding.cn/mweb/15876276073352-1.png" alt="15876276073352" /></p><p><strong>创建</strong>:<br />State 初始化时会依次执行 ：构造方法 -&gt; initState -&gt; didChangeDependencies -&gt; build，随后完成页面渲染。</p><ul><li>initState，会在 State 对象被插入视图树的时候调用。这个函数在 State 的生命周期中只会被调用一次，所以我们可以在这里做一些初始化工作</li><li>didChangeDependencies 则用来专门处理 State 对象依赖关系变化，会在 initState() 调用结束后，被 Flutter 调用</li><li>build，作用是构建视图。经过以上步骤，Framework 认为 State 已经准备好了，于是调用 build。我们需要在这个函数中，根据父 Widget 传递过来的初始化配置数据，以及 State 的当前状态，创建一个 Widget 然后返回。</li></ul><p><strong>更新</strong>:<br />Widget 的状态更新，主要由 3 个方法触发：setState、didchangeDependencies 与 didUpdateWidget。</p><ul><li>setState：我们最熟悉的方法之一。当状态数据发生变化时，我们总是通过调用这个方法告诉 Flutter：“我这儿的数据变啦，请使用更新后的数据重建 UI！”</li><li>didChangeDependencies：State 对象的依赖关系发生变化后，Flutter 会回调这个方法，随后触发组件构建。哪些情况下 State 对象的依赖关系会发生变化呢？典型的场景是，系统语言 Locale 或应用主题改变时，系统会通知 State 执行 didChangeDependencies 回调方法。</li><li>didUpdateWidget：当 Widget 的配置发生变化时，比如，父 Widget 触发重建（即父 Widget 的状态发生变化时），热重载时，系统会调用这个函数。</li></ul><p><strong>销毁</strong>:<br />组件销毁相对比较简单。比如组件被移除，或是页面销毁的时候，系统会调用 deactivate 和 dispose 这两个方法，来移除或销毁组件。</p><ul><li>当组件的可见状态发生变化时，deactivate 函数会被调用，这时 State 会被暂时从视图树中移除。值得注意的是，页面切换时，由于 State 对象在视图树中的位置发生了变化，需要先暂时移除后再重新添加，重新触发组件构建，因此这个函数也会被调用。</li><li>当 State 被永久地从视图树中移除时，Flutter 会调用 dispose 函数。而一旦到这个阶段，组件就要被销毁了，所以我们可以在这里进行最终的资源释放、移除监听、清理环境，等等。</li></ul><p><img src="http://qiniu.gogocoding.cn/mweb/15876282836080-1.png" alt="15876282836080" /></p><h3 id="312-app-生命周期"><a class="markdownIt-Anchor" href="#312-app-生命周期"></a> 3.1.2 APP 生命周期</h3><p>didChangeAppLifecycleState 回调函数中，有一个参数类型为 AppLifecycleState 的枚举类，这个枚举类是 Flutter 对 App 生命周期状态的封装。它的常用状态包括 resumed、inactive、paused 这三个。</p><ul><li>resumed：可见的，并能响应用户的输入。</li><li>inactive：处在不活动状态，无法处理用户响应。</li><li>paused：不可见并不能响应用户的输入，但是在后台继续活动中。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt;  <span class="title">with</span> <span class="title">WidgetsBindingObserver</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    WidgetsBinding.instance.addObserver(<span class="keyword">this</span>);<span class="comment">//注册监听器</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">    WidgetsBinding.instance.removeObserver(<span class="keyword">this</span>);<span class="comment">//移除监听器</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeAppLifecycleState(AppLifecycleState state) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">$state</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (state == AppLifecycleState.resumed) &#123;</span><br><span class="line">      <span class="comment">//do sth</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Flutter_boost</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ContainerLifeCycle &#123;</span><br><span class="line">  Init,</span><br><span class="line">  Appear,</span><br><span class="line">  WillDisappear,</span><br><span class="line">  Disappear,</span><br><span class="line">  Destroy,</span><br><span class="line">  Background,</span><br><span class="line">  Foreground</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="32-data-transfer-between-widget"><a class="markdownIt-Anchor" href="#32-data-transfer-between-widget"></a> 3.2 Data Transfer between Widget</h2><ul><li>属性传值</li><li>InheritedWidget</li><li>Notification</li><li>EventBus</li></ul><h3 id="321-属性传值"><a class="markdownIt-Anchor" href="#321-属性传值"></a> 3.2.1 属性传值</h3><p>在 Flutter 中实现跨组件数据传递的标准方式是通过属性传值。我们之前讲布局的时候，利用数据对基础 Widget 的样式进行视觉属性定制，这些参数传递都属于属性传值。</p><h3 id="322-inheritedwidget"><a class="markdownIt-Anchor" href="#322-inheritedwidget"></a> 3.2.2 InheritedWidget</h3><p>对于稍微复杂一点的、尤其视图层级比较深的 UI 样式，一个属性可能需要跨越很多层才能传递给子组件，这种传递方式就会导致中间很多并不需要这个属性的组件也需要接收其子 Widget 的数据，不仅繁琐而且冗余。</p><p>InheritedWidget 是 Flutter 中的一个功能型 Widget，适用于在 Widget 树中共享数据的场景。通过它，我们可以高效地将数据在 Widget 树中进行跨层传递。</p><ul><li>首先，为了使用 InheritedWidget，我们定义了一个继承自它的新类</li><li>然后，我们将需要共享的属性放到类中，并提供了一个 of 方法方便其子 Widget 在 Widget 树中找到它，of方法中调用<code>context</code> 的 <code>T dependOnInheritedWidgetOfExactType&lt;T extends InheritedWidget&gt;(&#123; Object aspect &#125;);</code>。</li><li>最后，重写了 updateShouldNotify 方法，这个方法会在 Flutter 判断InheritedWidget 是否需要重建，从而通知下层观察者组件更新数据时被调用到</li></ul><p><strong>Demo</strong>: [data_transfer]</p><p><a href="https://juejin.im/post/5d14e7d1f265da1b8c199d2b">Flutter - 数据共享，通信，状态管理 - InheritedWidget</a></p><h3 id="323-notification"><a class="markdownIt-Anchor" href="#323-notification"></a> 3.2.3 Notification</h3><p>Notification 是 Flutter 中进行跨层数据共享的另一个重要的机制。如果说 InheritedWidget 的数据流动方式是从父 Widget 到子 Widget 逐层传递，那 Notificaiton 则恰恰相反，数据流动方式是从子 Widget 向上传递至父 Widget。这样的数据传递机制适用于子 Widget 状态变更，发送通知上报的场景。</p><p>如果想要实现自定义通知，我们首先需要继承 Notification 类。Notification 类提供了 dispatch 方法，可以让我们沿着 context 对应的 Element 节点树向上逐层发送通知。</p><p>我们自定义了一个通知和子 Widget。子 Widget 是一个按钮，在点击时会发送通知：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomNotification</span> <span class="keyword">extends</span> <span class="title">Notification</span> </span>&#123;</span><br><span class="line">  CustomNotification(<span class="keyword">this</span>.msg);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽离出一个子Widget用来发通知</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomChild</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RaisedButton(</span><br><span class="line">      <span class="comment">//按钮点击时分发通知</span></span><br><span class="line">      onPressed: () =&gt; CustomNotification(<span class="string">&quot;Hi&quot;</span>).dispatch(context),</span><br><span class="line">      child: Text(<span class="string">&quot;Fire Notification&quot;</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在子 Widget 的父 Widget 中，我们监听了这个通知，一旦收到通知，就会触发界面刷新，展示收到的通知信息：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> _msg = <span class="string">&quot;通知：&quot;</span>;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">//监听通知</span></span><br><span class="line">    <span class="keyword">return</span> NotificationListener&lt;CustomNotification&gt;(</span><br><span class="line">        onNotification: (notification) &#123;</span><br><span class="line">          setState(() &#123;_msg += notification.msg+<span class="string">&quot;  &quot;</span>;&#125;);<span class="comment">//收到子Widget通知，更新msg</span></span><br><span class="line">        &#125;,</span><br><span class="line">        child:Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[Text(_msg),CustomChild()],<span class="comment">//将子Widget加入到视图树中</span></span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Demo</strong>: [data_transfer]</p><h3 id="324-eventbus"><a class="markdownIt-Anchor" href="#324-eventbus"></a> 3.2.4 EventBus</h3><p>无论是 InheritedWidget 还是 Notificaiton，它们的使用场景都需要依靠 Widget 树，也就意味着只能在有父子关系的 Widget 之间进行数据共享。但是，组件间数据传递还有一种常见场景：这些组件间不存在父子关系。这时，事件总线 EventBus 就登场了。</p><p>事件总线是在 Flutter 中实现跨组件通信的机制。它遵循发布 / 订阅模式，允许订阅者订阅事件，当发布者触发事件时，订阅者和发布者之间可以通过事件进行交互。发布者和订阅者之间无需有父子关系，甚至非 Widget 对象也可以发布 / 订阅。这些特点与其他平台的事件总线机制是类似的。</p><p><strong>Demo</strong>: [data_transfer]</p><p><strong>属性传值</strong>：简单，但跨多个父子节点不方便<br /><strong>InheritedWidget</strong>：跨多个父子节点方便，但修改数据麻烦<br /><strong>Notification</strong> ：传递事件方便，读取不方便<br /><strong>EventBus</strong> ：通过事件总线，全局，方便，但要记住事件名称，全局容易冲突，组件消除要清理事件。</p><h2 id="32-state-management-approaches"><a class="markdownIt-Anchor" href="#32-state-management-approaches"></a> 3.2 State Management Approaches</h2><p>随着产品需求迭代节奏加快，项目逐渐变得庞大时，我们往往就需要管理不同组件、不同页面之间共享的数据关系。当需要共享的数据关系达到几十上百个的时候，我们就很难保持清晰的数据流动方向和顺序了，导致应用内各种数据传递嵌套和回调满天飞。在这个时候，我们迫切需要一个解决方案，来帮助我们理清楚这些共享数据的关系，于是状态管理框架便应运而生。</p><ul><li><strong>Provider</strong> : <a href="https://github.com/rrousselGit/provider">https://github.com/rrousselGit/provider</a>   (Flutter 官方推荐)</li><li>BLoC (Business Logic Component): <a href="https://github.com/felangel/bloc/tree/master/packages/flutter_bloc">https://github.com/felangel/bloc/tree/master/packages/flutter_bloc</a>    (<a href="https://bloclibrary.dev/#/gettingstarted">https://bloclibrary.dev/#/gettingstarted</a>)</li><li>flutter_redux :  <a href="https://github.com/brianegan/flutter_redux">https://github.com/brianegan/flutter_redux</a></li><li>fish_redux : <a href="https://github.com/alibaba/fish-redux">https://github.com/alibaba/fish-redux</a>   (阿里)</li><li>flutter_mobx : <a href="https://github.com/mobxjs/mobx.dart">https://github.com/mobxjs/mobx.dart</a></li></ul><p><strong>Provider</strong> 是一个用来提供数据的框架。它是 InheritedWidget 的语法糖，提供了依赖注入的功能，允许在 Widget 树中更加灵活地处理和传递数据。</p><ul><li>资源（即数据状态）如何封装？</li><li>资源放在哪儿，才都能访问得到？</li><li>具体使用时，如何取出资源？</li><li>多状态的资源封装？</li></ul><h2 id="33-以json_serializable的方式创建model类"><a class="markdownIt-Anchor" href="#33-以json_serializable的方式创建model类"></a> 3.3 以json_serializable的方式创建model类</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:json_annotation/json_annotation.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">part</span> <span class="string">&#x27;skill_model.g.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonSerializable</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkillList</span> </span>&#123;</span><br><span class="line">  SkillList();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">int</span> page_size;</span><br><span class="line">  <span class="built_in">int</span> sum_size;</span><br><span class="line">  <span class="built_in">int</span> current_page;</span><br><span class="line">  <span class="built_in">List</span>&lt;SkillListItem&gt; skills;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">factory</span> SkillList.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; json) =&gt; _$SkillListFromJson(json);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; toJson() =&gt; _$SkillListToJson(<span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个SkillList.fromJson 构造函数, 用于从一个map构造出一个 User实例 map structure</span></span><br><span class="line"><span class="comment">//一个toJson 方法, 将 User 实例转化为一个map.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>json_serializable第一次创建类时，您会看到与下图类似的错误。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1937825-d0f49f99696bfdeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="jsonError" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一次性生成</span></span><br><span class="line">flutter packages pub run build_runner build</span><br><span class="line"></span><br><span class="line"><span class="comment">#持续生成</span></span><br><span class="line">flutter packages pub run build_runner watch</span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">request.parseFunction = (json)&#123;</span><br><span class="line">      SkillList tmp = SkillList.fromJson(json);</span><br><span class="line">      <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; newMap = tmp.toJson();</span><br><span class="line">      <span class="keyword">return</span> SkillList.fromJson(json);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>@JsonKey</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> JsonKey(&#123;</span><br><span class="line">   <span class="keyword">this</span>.defaultValue,</span><br><span class="line">   <span class="keyword">this</span>.disallowNullValue,</span><br><span class="line">   <span class="keyword">this</span>.fromJson,</span><br><span class="line">   <span class="keyword">this</span>.ignore,</span><br><span class="line">   <span class="keyword">this</span>.includeIfNull,</span><br><span class="line">   <span class="keyword">this</span>.name,</span><br><span class="line">   <span class="keyword">this</span>.nullable,</span><br><span class="line">   <span class="keyword">this</span>.<span class="keyword">required</span>,</span><br><span class="line">   <span class="keyword">this</span>.toJson,</span><br><span class="line">   <span class="keyword">this</span>.unknownEnumValue,</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>Q : ?? 深拷贝 ？？</p><p><a href="https://repl.it/languages/dart">https://repl.it/languages/dart</a></p><p>1、自我介绍<br />2、flutter 和rn 的对比，技术选型<br />3、flutter 常用的widget  ，分类介绍<br />widget 间数据传递有几种方式</p><ul><li>属性传值</li><li>InheritedWidget</li><li>Notification</li><li>EventBus</li></ul><p>4、widget 通用封装，page 定义，一些 toast / dialog ，封装了什么，举个例子<br />5、container 设置宽高不生效<br />6、 method-channel 封装为pub，并以此 pub 为模块的 FaceBooklogin plugin封装  api 还是 页面<br />7、 AgentWeb加载三方支付网页，解决不断闪烁问题。<br />8、 为什么用flutter_boot，解决什么问题。<br />9、 channel处理通信交互,dio网络请求。<br />10、flutter的启动空白优化采用预处理flutter页面。 启动空白的原因？ 怎么解决</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go实现千万级弹幕系统</title>
      <link href="/2020/03/20/Projects/WebSocket/Go%E5%AE%9E%E7%8E%B0%E5%8D%83%E4%B8%87%E7%BA%A7%E5%BC%B9%E5%B9%95%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/03/20/Projects/WebSocket/Go%E5%AE%9E%E7%8E%B0%E5%8D%83%E4%B8%87%E7%BA%A7%E5%BC%B9%E5%B9%95%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-弹幕技术的复杂度"><a class="markdownIt-Anchor" href="#1-弹幕技术的复杂度"></a> 1. 弹幕技术的复杂度</h1><p>一个直播间：</p><ul><li>在线人数：100万</li><li>发送弹幕：1000条/秒</li><li>推送频率：100万 * 1000条/秒 = 10亿条/秒</li></ul><p>N个直播间呢？？？？？</p><h1 id="2-拉模式与推模式的区别"><a class="markdownIt-Anchor" href="#2-拉模式与推模式的区别"></a> 2. 拉模式与推模式的区别</h1><p><strong>拉模式</strong>:</p><ul><li>数据更新频率低时，大多数请求时无效的；</li><li>在线用户数量多时，服务端的查询负载很高；</li><li>定时轮询拉取，无法满足时效性要求；</li></ul><p><strong>推模式</strong>:</p><ul><li>仅在数据更新时才需要推送；</li><li>需要维护大量的在线长连接；</li><li>数据更新后可以立刻推送；</li></ul><h2 id="21-基于websocket推送"><a class="markdownIt-Anchor" href="#21-基于websocket推送"></a> 2.1 基于WebSocket推送；</h2><ul><li>浏览器支持socket编程，轻松维持服务端的长连接；</li><li>基于TCP可靠传输之上的协议，无需开发者关心通讯细节；</li><li>提供了高度抽象的编程接口，业务开发成本较低；</li></ul>]]></content>
      
      
      <categories>
          
          <category> WebSocket </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> WebSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库性能优化</title>
      <link href="/2020/03/09/DataBase/MySQL/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2020/03/09/DataBase/MySQL/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么影响了mysql数据库性能"><a class="markdownIt-Anchor" href="#1-什么影响了mysql数据库性能"></a> 1. 什么影响了MySQL数据库性能</h1><ol><li>服务器硬件<ol><li>CPU</li><li>内存</li><li>磁盘I/O</li><li>网络I/O</li></ol></li><li>服务器系统和参数</li><li>数据库存储引擎<ol><li>MyISAM: 不支持事务，表级锁</li><li>InnoDB: 事务级存储引擎，完美支持行级锁，事务ACID特性</li></ol></li><li>数据库参数配置（重要）</li><li>数据库结构设计和SQL语句（重要）<ol><li>慢查询，SQL语句优化</li><li>数据库表结构设计</li></ol></li></ol><h2 id="11-服务器硬件优化"><a class="markdownIt-Anchor" href="#11-服务器硬件优化"></a> 1.1 服务器硬件优化</h2><p>[TODO] …</p><h2 id="12-服务器参数优化"><a class="markdownIt-Anchor" href="#12-服务器参数优化"></a> 1.2 服务器参数优化</h2><h3 id="121-内核相关参数"><a class="markdownIt-Anchor" href="#121-内核相关参数"></a> 1.2.1 内核相关参数</h3><p><strong>/etc/sysctl.conf</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">net.core.somaxconn&#x3D;65535</span><br><span class="line">net.core.netdev_max_backlog&#x3D;65535</span><br><span class="line">net.ipv4.tcp_max_syn_backlog&#x3D;65535</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_fin_timeout&#x3D;10</span><br><span class="line">net.ipv4.tcp_tw_reuse&#x3D;1</span><br><span class="line">net.ipv4.tcp_tw_recycle&#x3D;1</span><br><span class="line"></span><br><span class="line">net.core.wmem_default&#x3D;87380</span><br><span class="line">net.core.wmem_max&#x3D;16777216</span><br><span class="line">net.core.rmem_default&#x3D;87380</span><br><span class="line">net.core.rmem_max&#x3D;16777216</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_keepalive_time&#x3D;120</span><br><span class="line">net.ipv4.tcp_keepalive_intvl&#x3D;30</span><br><span class="line">net.ipv4.tcp_keepalive_probes&#x3D;3</span><br></pre></td></tr></table></figure><p><code>kernel.shmmax=4294967295</code>是Linux内核参数中最重要的参数之一，用于定义单个共享内存段的最大值。</p><ol><li>这个参数应该设置的足够大，以便能够在一个共享内存段容纳下整个的InnoDB缓冲池的大小；</li><li>这个值大小建议大于物理内存的一半，一般取值大于InnoDB缓冲池的大小即可；</li></ol><p><code>vm_swappiness=0</code>这个参数当内存不足时会对性能产生比较明显的影响；</p><h3 id="122-增加资源限制"><a class="markdownIt-Anchor" href="#122-增加资源限制"></a> 1.2.2 增加资源限制</h3><p><strong>/etc/security/limit.conf</strong>, 这个文件实际上是Linx PAM,也就是插入式认证模块的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 65535</span><br><span class="line">* hard nofile 65535</span><br></pre></td></tr></table></figure><h3 id="123-磁盘调度策略"><a class="markdownIt-Anchor" href="#123-磁盘调度策略"></a> 1.2.3 磁盘调度策略</h3><p><strong>/sys/block/devname/queue/scheduler</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--查看磁盘调度策略--&gt;</span><br><span class="line">cat /sys/block/sda/queue/scheduler noop anticipatory deadline [cfq]</span><br><span class="line"></span><br><span class="line">&lt;!--修改磁盘调度策略--&gt;</span><br><span class="line">echo deadline &gt; /sys/block/sda/queue/scheduler</span><br></pre></td></tr></table></figure><h3 id="124-文件系统对性能影响"><a class="markdownIt-Anchor" href="#124-文件系统对性能影响"></a> 1.2.4 文件系统对性能影响</h3><pre class="mermaid">graph LR;    Windows-->FAT;    Windows-->NTFS;</pre><pre class="mermaid">graph LR;Linux-->EXT3;Linux-->EXT4Linux-->XFS</pre><h4 id="ext34系统的挂载参数"><a class="markdownIt-Anchor" href="#ext34系统的挂载参数"></a> EXT3/4系统的挂载参数</h4><p><strong>/etc/fstab</strong><br /><code>/dev/sda1/ext4 noatime,nodiratime,data=writeback 1 1</code><br />data参数，data=wtiteback  | ordered | journal 这三个参数代表不同的日志策略，</p><ul><li>writeback 意味着只有原数据写入日志，原数据写入和数据写入并不是同步的，这是最快的一种配置，因为Innodb有自己的事务日志，所以选择Innodb是最好的选择；</li><li>ordered选项只会记录原数据，但提供了一些一致性的保证，在写原数据之前的会先写数据，使他们保持一致，这个选项比writeback 慢一些，但是如果出现崩溃呢更加安全；</li><li>journal提供了原子日志的一种行为，在数据写入到最终位置之前，将记录到日志中，这个选项对Innodb来说是没有必要的，在这三个选项中最慢的一个；</li><li>noatime，nodiratime，用于禁止记录文件的访问时间和读取目录的时间，禁用了这两个时间的选项后，可以减少一些，写的操作。系统在读取文件和目录时候，不必写操作来记录以上两个时间；</li></ul><h2 id="13-数据库引擎"><a class="markdownIt-Anchor" href="#13-数据库引擎"></a> 1.3 数据库引擎</h2><ul><li>客户端：Go, JAVA, PHP, C API, ODBC, JDBC, etc…</li><li>MySQL服务层：连接管理器、查询解析器、查询优化器、查询缓存</li><li>存储引擎层：InnoDB, TokuDB, MyISAM, XtraDB, Archive, CSV, Memory, Federated<br /><code>注意</code>：存储引擎是针对于表的而不是针对于库的（一个库中的不同表可以使用不同的存储引擎）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库集群,PXC、Replication、MyCat</title>
      <link href="/2020/03/09/DataBase/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4/"/>
      <url>/2020/03/09/DataBase/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="1-数据库集群能解决什么问题"><a class="markdownIt-Anchor" href="#1-数据库集群能解决什么问题"></a> 1. 数据库集群能解决什么问题？</h2><p>在低并发的情况下，单节点MySQL的读写速度更快。因为在数据库集群中，多个MySQL节点的数据要通过网络同步，所以读写速度不如单节点MySQL</p><p>但是在高并发的情况下，大量的读写请求会让单节点MySQL的硬盘无法承受，所以速度会变得很慢。</p><p>高并发恰恰是数据库集群的主场。大量的读写请求会被分散发往多个节点执行。众人拾柴火焰高，多个MySQL执行读写请求，肯定比单节点MySQL快，所以在高负载的情况下，单节点MySQL接近崩溃，反而数据库集群的读写速度更快。<br /><img src="http://qiniu.gogocoding.cn/mweb/15837689929083.jpg" width="500"></p><h2 id="2-常见mysql集群方案"><a class="markdownIt-Anchor" href="#2-常见mysql集群方案"></a> 2. 常见MySQL集群方案</h2><ul><li>常见的MySQL集群方案有PXC和Replication<ul><li>PXC集群适合保存少量高价值数据</li><li>Replication集群适合保存大量数据</li></ul></li></ul><img src="http://qiniu.gogocoding.cn/mweb/15837690263525.jpg" width="600"><h3 id="21-docker镜像"><a class="markdownIt-Anchor" href="#21-docker镜像"></a> 2.1 Docker镜像</h3><p>Docker的镜像文件，相当于是一个只读层，不能往里面写入数据。我们可以通过编写dockerfile文件，定义需要安装的程序，比如说MySQL、Redis、JDK、Node.js等等，然后执行这个dockerfile文件，创建出镜像文件。</p><p>手写dockerfile还是比较麻烦的，所以我们可以在Docker的镜像仓库里面寻找别人已经创建好的镜像，比如说你想部署Java程序，那么就在线下载Java镜像即可，非常简单。</p><p>毕竟Docker镜像是只读层，如果我们想要往里面部署层序应该怎么办呢？这个很简单，我们可以给镜像创建一个容器，容器是可读可写的，我们把程序部署在容器里就行了。</p><h3 id="22-docker容器"><a class="markdownIt-Anchor" href="#22-docker容器"></a> 2.2 Docker容器</h3><p>我们说的在Docker虚拟机中创建实例，指的就是容器。因为镜像的内容是只读的，想要部署程序，我们需要创建出容器实例，容器的内容是可以读写的，可以用来部署程序。</p><p>而且容器之间是完全隔离的，我们不用担心一个容器中部署程序，会影响到另一个容器。就比如说我们在CentOS上直接安装MySQL 8.0，它跟Percona Toolkit有冲突，跟Sysbench也有冲突，所以我们做在线修改表结构，以及做压力测试的时候，都是挑选新的虚拟机实例来安装这些程序，访问MySQL的。如果用上了Docker，我可以在A容器里安装MySQL，在B容器跑压力测试，根本不会有冲突。</p><p>再有，必须先有镜像，才能创建出容器，镜像和容器之间是关联的关系。而且一个镜像可以创建出多个容器，像是SaaS云计算，运营商可以把进销存系统打成镜像。有企业购买进销存系统，那么运营商就给客户创建一个容器，客户的进销存数据保存在容器A里面。再有客户购买进销存系统，运营商就创建容器B，以此类推。云计算服务商就是这么卖软件的。</p><h3 id="23-安装docker虚拟机"><a class="markdownIt-Anchor" href="#23-安装docker虚拟机"></a> 2.3 安装Docker虚拟机</h3><p>我们在CentOS7上直接安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker stop</span><br></pre></td></tr></table></figure><h3 id="24-docker虚拟机管理命令"><a class="markdownIt-Anchor" href="#24-docker虚拟机管理命令"></a> 2.4 Docker虚拟机管理命令</h3><p><img src="http://qiniu.gogocoding.cn/mweb/docker%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4.png" alt="docker虚拟机管理命令" /></p><p><strong>设置镜像加速器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io</span><br></pre></td></tr></table></figure><p>编辑/etc/docker/daemon.json文件，把结尾的逗号去掉</p><h4 id="241-管理镜像"><a class="markdownIt-Anchor" href="#241-管理镜像"></a> 2.4.1 管理镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">搜索镜像</span></span><br><span class="line">docker search 关键字</span><br><span class="line"><span class="meta">#</span><span class="bash">下载镜像</span></span><br><span class="line">docker pull 镜像名字</span><br><span class="line"><span class="meta">#</span><span class="bash">查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta">#</span><span class="bash">重命名镜像</span></span><br><span class="line">docker tag 旧镜像 新镜像</span><br><span class="line"><span class="meta">#</span><span class="bash">删除镜像</span></span><br><span class="line">docker rmi 镜像名字</span><br><span class="line"><span class="meta">#</span><span class="bash">导出镜像</span></span><br><span class="line">docker save -o 压缩文件路径 镜像名字</span><br><span class="line"><span class="meta">#</span><span class="bash">导入镜像</span></span><br><span class="line">docker load &lt; 压缩文件路径</span><br></pre></td></tr></table></figure><h4 id="242-创建容器"><a class="markdownIt-Anchor" href="#242-创建容器"></a> 2.4.2 创建容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建普通容器</span></span><br><span class="line">docker run -it --name 别名 镜像名字 程序名字</span><br><span class="line"><span class="meta">#</span><span class="bash">创建含有端口映射的容器</span></span><br><span class="line">docker run -it --name 别名 -p 宿主机端口:容器端口 镜像名字 程序名字</span><br><span class="line"><span class="meta">#</span><span class="bash">创建含有挂载目录的容器</span></span><br><span class="line">docker run -it --name 别名 -v 宿主机目录:容器目录 --privileged 镜像名字 程序名字</span><br></pre></td></tr></table></figure><p><code>注</code>:privileged -&gt; 给容器赋予最高权限</p><h4 id="243-操作容器状态"><a class="markdownIt-Anchor" href="#243-操作容器状态"></a> 2.4.3 操作容器状态</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">暂停容器</span></span><br><span class="line">docker pasue 容器</span><br><span class="line"><span class="meta">#</span><span class="bash">恢复容器</span></span><br><span class="line">docker unpause 容器</span><br><span class="line"><span class="meta">#</span><span class="bash">停止容器</span></span><br><span class="line">docker stop 容器</span><br><span class="line"><span class="meta">#</span><span class="bash">启动容器</span></span><br><span class="line">docker start -i 容器</span><br></pre></td></tr></table></figure><h3 id="25-分布式docker环境"><a class="markdownIt-Anchor" href="#25-分布式docker环境"></a> 2.5 分布式Docker环境</h3><p>Docker Swarm技术可以自动把异地的Docker虚拟机组成一个局域网<br /><img src="http://qiniu.gogocoding.cn/mweb/2.png" alt="2 -c200" /></p><p><code>注</code>：创建Swarm集群后，不要再更换网络，否则会导致Swarm集群失效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建Swarm集群（该节点自动变成管理节点）</span></span><br><span class="line">docker swarm init</span><br><span class="line"><span class="meta">#</span><span class="bash">查看Swarm集群中的Docker节点（管理节点上执行）</span></span><br><span class="line">docker node ls</span><br><span class="line"><span class="meta">#</span><span class="bash">删除Swarm集群的Docker节点（管理节点上执行）</span></span><br><span class="line">docker noode rm 节点ID -f</span><br><span class="line"><span class="meta">#</span><span class="bash">退出Swarm集群（Workd节点上执行）</span></span><br><span class="line">docker swarm leave</span><br><span class="line"><span class="meta">#</span><span class="bash">退出Swarm集群（管理节点上执行）</span></span><br><span class="line">docker swarm leave -f</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看虚拟网络</span></span><br><span class="line">docker network ls</span><br><span class="line"><span class="meta">#</span><span class="bash">创建虚拟网络</span></span><br><span class="line">docker network create -d overlay --attachable 虚拟网络名称</span><br><span class="line"><span class="meta">#</span><span class="bash">删除虚拟网络（先删除该网络上部署的容器）</span></span><br><span class="line">docker network rm 虚拟网络名称</span><br></pre></td></tr></table></figure><p>Swarm虚拟网络使用三个端口，所以必须要在防火墙上面开启2377、7946、4789端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=2377/udp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=2377/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=7946/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=7946/udp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=4789/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=4789/udp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>开启防火墙端口之后，必须要重新启动Docker服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure><h3 id="26-pxc集群"><a class="markdownIt-Anchor" href="#26-pxc集群"></a> 2.6 PXC集群</h3><p>Pecona XtraDB Cluster(PXC)是业界主流的MySQL集群方案，PXC集群的数据同步具有强一致性的特点，并且PXC集群只支持InnoDB引擎。<br /><code>注</code>：PXC集群中MySQL节点的数量最好不要超过15个，集群规模越大，读写速度越慢</p><h4 id="261-下载pxc镜像"><a class="markdownIt-Anchor" href="#261-下载pxc镜像"></a> 2.6.1 下载PXC镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull percona/percona-xtradb-cluster</span><br><span class="line">docker tag percona/percona-xtradb-cluster pxc</span><br><span class="line">docker rmi percona/percona-xtradb-cluster</span><br></pre></td></tr></table></figure><h4 id="262-创建主节点容器"><a class="markdownIt-Anchor" href="#262-创建主节点容器"></a> 2.6.2 创建主节点容器</h4><ul><li>第一个启动的PXC节点是主节点，它要初始化PXC集群</li><li>PXC启动之后，就没有主节点的角色了</li><li>PXC集群中任何节点都是可以读写数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9001:3306 -e MYSQL_ROOT_PASSWORD=123456 -e CLUSTER_NAME=P XC1 -e XTRABACKUP_PASSWORD=123456 -v pnv1:/var/lib/mysql --privileged --name=pn1 --net=swarm_mysql pxc</span><br></pre></td></tr></table></figure><p>创建主节点之后，稍等一会儿，才能连接</p><h4 id="263-创建从节点容器"><a class="markdownIt-Anchor" href="#263-创建从节点容器"></a> 2.6.3 创建从节点容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9001:3306 -e MYSQL_ROOT_PASSWORD=123456 -e CLUSTER_NAME=PXC1 -e XTRABACKUP_PASSWORD=123456 -e CLUSTER_JOIN=pn1 -v pnv2:/var/lib/mysql --privileged --name=pn2 --net=swarm_mysql pxc</span><br></pre></td></tr></table></figure><p>必须主节点可以访问了，才能创建从节点，否则会闪退</p><h4 id="264-pxc容器闪退的解决办法"><a class="markdownIt-Anchor" href="#264-pxc容器闪退的解决办法"></a> 2.6.4 PXC容器闪退的解决办法</h4><p><strong>主节点无法启动</strong></p><p>修改/var/lib/mysql/grastate.dat文件，把safe_to_bootstrap参数改成1，然后就能启动了。</p><p><strong>从节点闪退的原因</strong></p><p>如果主节点没有完全启动成功，从节点就会闪退。</p><h3 id="27-replication集群"><a class="markdownIt-Anchor" href="#27-replication集群"></a> 2.7 Replication集群</h3><p>Replication集群是MySQL自带的数据同步机制,MySQL通过读取、执行另一个MySQL的bin_log日志，实现数据同步。<br /><img src="http://qiniu.gogocoding.cn/mweb/3.png" alt="3" /><br />Replication集群中，数据同步是单向的，从主节点(Master)同步到从节点(Slave)。<br /><img src="http://qiniu.gogocoding.cn/mweb/4.png" alt="4" /></p><h4 id="271-下载replication镜像"><a class="markdownIt-Anchor" href="#271-下载replication镜像"></a> 2.7.1 下载Replication镜像</h4><p>Oracle并没有提供官方的Replication镜像，但是我们可以选择第三方封装的镜像文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull mishamx/mysql</span><br><span class="line">docker tag mishamx/mysql rep</span><br><span class="line">docker rmi mishamx/mysql</span><br></pre></td></tr></table></figure><h4 id="272-创建主节点"><a class="markdownIt-Anchor" href="#272-创建主节点"></a> 2.7.2 创建主节点</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9003:3306 --name rn1 -e MYSQL_MASTER_PORT=3306 -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_REPLICATION_USER=backup -e MYSQL_REPLICATION_PASSWORD=123456 -v rnv1:/var/lib/mysql --privileged --net=swarm_mysql rep</span><br></pre></td></tr></table></figure><h4 id="273-创建从节点"><a class="markdownIt-Anchor" href="#273-创建从节点"></a> 2.7.3 创建从节点</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9003:3306 --name rn2 -e MYSQL_MASTER_HOST=rn1 -e MYSQL_MASTER_PORT=3306 -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_REPLICATION_USER=backup -e MYSQL_REPLICATION_PASSWORD=123456 -v rnv2:/var/lib/mysql --privileged --net=swarm_mysql rep</span><br></pre></td></tr></table></figure><h3 id="28-mycat管理数据库集群"><a class="markdownIt-Anchor" href="#28-mycat管理数据库集群"></a> 2.8 MyCat管理数据库集群</h3><h4 id="281-数据切分"><a class="markdownIt-Anchor" href="#281-数据切分"></a> 2.8.1 数据切分</h4><h5 id="什么是垂直切分"><a class="markdownIt-Anchor" href="#什么是垂直切分"></a> 什么是垂直切分？</h5><p>垂直切分是按照业务对数据表分类，然后把一个数据库拆分成多个独立的数据库<br /><img src="http://qiniu.gogocoding.cn/mweb/5-1.png" alt="5" /></p><ul><li>垂直切分可以把数据库的并发压力，分散到不同的数据库节点，但是垂直切分并不能减少单表的数据量。</li><li>不能跨MySQL节点做表连接查询，只能通过接口方式解决</li><li>跨MySQL节点的事务，需要用分布式事务机制来实现<br /><img src="http://qiniu.gogocoding.cn/mweb/6.png" alt="6" /></li></ul><h5 id="什么是水平切分"><a class="markdownIt-Anchor" href="#什么是水平切分"></a> 什么是水平切分？</h5><p>水平切分是按照某个字段的某种规则，把数据切分到多张数据表<br /><img src="http://qiniu.gogocoding.cn/mweb/7.png" alt="7" /></p><ul><li><p>水平切分可以把数据切分到多张数据表，可以起到缩表的作用</p></li><li><p>只有数据量很大的表，才需要使用水平切分</p></li><li><p>不同数据表的切分规则并不一致，要根据实际业务来确定</p></li><li><p>集群扩容较为麻烦，需要迁移大量的数据</p></li></ul><p><img src="http://qiniu.gogocoding.cn/mweb/8.png" alt="8" /></p><h5 id="使用切分的注意事项"><a class="markdownIt-Anchor" href="#使用切分的注意事项"></a> 使用切分的注意事项</h5><p>添加新的分片，硬件成本和时间成本很大，所以要慎重。可以对分片数据做冷热数据分离，把冷数据移出分片来缩表。<br /><img src="http://qiniu.gogocoding.cn/mweb/9.png" alt="9" /><br />在项目逐步迭代升级的过程中，先是从单节点演化为水平切分的<br /><img src="http://qiniu.gogocoding.cn/mweb/10.png" alt="10" /></p><h4 id="282-安装mycat"><a class="markdownIt-Anchor" href="#282-安装mycat"></a> 2.8.2 安装MyCat</h4><ul><li>MyCat是基于Java语言的开源数据库中间件产品，具有跨平台性</li><li>相较于其他中间件产品，MyCat的切分规则最多，功能最全</li><li>数据库中间件产品并不会频繁更新升级，MyCat功能非常成熟</li></ul><p><strong>安装JDK镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull adoptopenjdk/openjdk8</span><br><span class="line">docker tag adoptopenjdk/openjdk8 openjdk8</span><br><span class="line">docker rm adoptopenjdk/openjdk8</span><br></pre></td></tr></table></figure><p><strong>打开防火墙端口</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8066/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=9066/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p><strong>创建Java容器，在数据卷放入MyCat</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it --name mycat1 –v mycat1:/root/server --privileged --net=host  openjdk8</span><br></pre></td></tr></table></figure><h4 id="283-配置虚拟帐户"><a class="markdownIt-Anchor" href="#283-配置虚拟帐户"></a> 2.8.3 配置虚拟帐户</h4><p>编辑server.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mycat:server</span>&gt;</span></span><br><span class="line">  ……  </span><br><span class="line">  <span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;admin&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>abc123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>neti<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:server</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="284-设置pxc负载均衡"><a class="markdownIt-Anchor" href="#284-设置pxc负载均衡"></a> 2.8.4 设置PXC负载均衡</h4><p>编辑schema.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">...</span> <span class="attr">balance</span> = <span class="string">0</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!----&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="285-设置replication读写分离"><a class="markdownIt-Anchor" href="#285-设置replication读写分离"></a> 2.8.5 设置Replication读写分离</h4><p>编辑schema.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">...</span> <span class="attr">balance</span> = <span class="string">3</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!----&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="285-配置虚拟库和虚拟表"><a class="markdownIt-Anchor" href="#285-配置虚拟库和虚拟表"></a> 2.8.5 配置虚拟库和虚拟表</h4><p>MyCat并不存储数据，所以必须配置可以使用的虚拟逻辑库和关系表。<br /><img src="http://qiniu.gogocoding.cn/mweb/%E8%99%9A%E6%8B%9F%E5%BA%93%E5%92%8C%E8%99%9A%E6%8B%9F%E8%A1%A8.png" alt="虚拟库和虚拟表" /></p><h5 id="datanode标签可以设置使用的真实逻辑库"><a class="markdownIt-Anchor" href="#datanode标签可以设置使用的真实逻辑库"></a> <dataNode>标签可以设置使用的真实逻辑库</h5><h6 id="编辑schemaxml文件"><a class="markdownIt-Anchor" href="#编辑schemaxml文件"></a> 编辑schema.xml文件</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;pxc1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;neti&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;pxc2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;neti&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;rep1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;neti&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn4&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;rep2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;neti&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;tdn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;pxc1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;t1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;tdn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;pxc2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;t1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;tdn3&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;rep1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;t2&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;tdn4&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;rep2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;t2&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;schema name&#x3D;&quot;neti&quot; checkSQLschema&#x3D;&quot;false&quot; sqlMaxLimit&#x3D;&quot;100&quot;&gt;</span><br><span class="line">    &lt;table name&#x3D;&quot;teacher&quot; dataNode&#x3D;&quot;dn1,dn2 &quot; type&#x3D;&quot;global&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;schema&gt;</span><br><span class="line">&lt;schema name&#x3D;&quot;t1&quot; checkSQLschema&#x3D;&quot;false&quot; sqlMaxLimit&#x3D;&quot;100&quot;&gt;</span><br><span class="line">    &lt;table name&#x3D;&quot;teacher&quot; dataNode&#x3D;&quot;tdn1,tdn2&quot; type&#x3D;&quot;global&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;schema&gt;</span><br><span class="line">&lt;schema name&#x3D;&quot;t2&quot; checkSQLschema&#x3D;&quot;false&quot; sqlMaxLimit&#x3D;&quot;100&quot;&gt;</span><br><span class="line">    &lt;table name&#x3D;&quot;teacher&quot; dataNode&#x3D;&quot;tdn3,tdn4&quot; type&#x3D;&quot;global&quot; &#x2F;&gt;</span><br><span class="line">    &lt;table name&#x3D;&quot;student&quot; dataNode&#x3D;&quot;tdn3,tdn4&quot; rule&#x3D;&quot;mod-long &quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;schema&gt;</span><br></pre></td></tr></table></figure><h6 id="编辑serverxml文件"><a class="markdownIt-Anchor" href="#编辑serverxml文件"></a> 编辑server.xml文件</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mycat:server</span>&gt;</span></span><br><span class="line">  ……  </span><br><span class="line">  <span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;admin&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>abc123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>neti,t1,t2 <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:server</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="修改mod-long算法"><a class="markdownIt-Anchor" href="#修改mod-long算法"></a> 修改mod-long算法</h6><p>MyCat默认mod-long是按照三个分片切分数据，所以我们要求改这个默认值<br />修改rule.xml文件中的mod-long分片数量</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;mod-long&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByMod&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="286-启动mycat"><a class="markdownIt-Anchor" href="#286-启动mycat"></a> 2.8.6 启动MyCat</h4><p>MyCat日志文件主要有console.log和mycat.log，存放在logs目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--建立logs目录--&gt;</span><br><span class="line">cd /root/server/mycat</span><br><span class="line">mkdir logs</span><br><span class="line"> </span><br><span class="line">&lt;!--修改权限, 为mycat/bin目录中所有sh命令设置最高权限--&gt;</span><br><span class="line">chmod -R 777 ./*.sh</span><br><span class="line"></span><br><span class="line">&lt;!--启动MyCat程序--&gt;</span><br><span class="line">./startup_nowrap.sh</span><br></pre></td></tr></table></figure><h6 id="在mycat上建表"><a class="markdownIt-Anchor" href="#在mycat上建表"></a> 在MyCat上建表</h6><p><code>注</code>：在MyCat上只能通过SQL语句建表，不可以使用Navicat等图形工具建表; 创建好表以后，插入数据既可以使用SQL语句，也可以使用图形工具了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> teacher(</span><br><span class="line">    id <span class="type">INT</span> UNSIGNED <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name VA  RCHAR(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">    id <span class="type">INT</span> UNSIGNED <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="287-mycat实现水平切分"><a class="markdownIt-Anchor" href="#287-mycat实现水平切分"></a> 2.8.7 MyCat实现水平切分</h4><p>MyCat具有很多水平切分算法</p><table><thead><tr><th style="text-align:center">分片算法</th><th style="text-align:center">使用场合</th><th style="text-align:center">案例</th></tr></thead><tbody><tr><td style="text-align:center">主键求模</td><td style="text-align:center">初始数据很多，但是增幅较慢</td><td style="text-align:center">地图数据</td></tr><tr><td style="text-align:center">枚举值</td><td style="text-align:center">绝大多数场合</td><td style="text-align:center">58同城、饿了么</td></tr><tr><td style="text-align:center">日期分片</td><td style="text-align:center">按照日期查找数据</td><td style="text-align:center">日志数据</td></tr><tr><td style="text-align:center">自然月分片</td><td style="text-align:center">按照日期查找数据</td><td style="text-align:center">财务数据</td></tr><tr><td style="text-align:center">冷数据分片</td><td style="text-align:center">冷热数据分离</td><td style="text-align:center">订单数据</td></tr></tbody></table><h5 id="全局表"><a class="markdownIt-Anchor" href="#全局表"></a> 全局表</h5><ul><li>数据字典表或者数据量不是很大的业务表，都可以定义成全局表</li><li>全局表的数据在每个分片中都是相同的</li><li>配置全局表就是给虚拟表设置type等于global<ul><li><code>&lt;table name=&quot;teacher&quot; dataNode=&quot;tdn3,tdn4&quot; type=&quot;global&quot; /&gt;</code></li></ul></li></ul><h6 id="全局表的sql路由"><a class="markdownIt-Anchor" href="#全局表的sql路由"></a> 全局表的SQL路由</h6><ul><li>查询语句，MyCat会随机路由给一个分片执行</li><li>INSERT、DELETE、UPDATE语句会路由给每个分片去执行</li></ul><h5 id="主键求模切分"><a class="markdownIt-Anchor" href="#主键求模切分"></a> 主键求模切分</h5><ul><li>主键求模切分可以把数据均匀的切分到分片中</li><li>这种切分规则适合初始数据量很大，但是数据增幅不大的场合</li></ul><p><strong>主键求模切分的缺点</strong></p><ul><li>数据不分类直接存储，以后维护的成本比较高。</li></ul><h5 id="枚举值切分"><a class="markdownIt-Anchor" href="#枚举值切分"></a> 枚举值切分</h5><ul><li>枚举值切分是根据固定字段的枚举值来切分数据。枚举值要提前规定好，而且必须是整数类型。</li><li>枚举值文件的序号从0开始，0代表第一个分片，1代表第二个分片，以此类推。</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--city.txt--&gt;</span><br><span class="line">10=0</span><br><span class="line">22=0</span><br><span class="line">24=1</span><br><span class="line">411=1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>在rule.xml文件中声明枚举值算法函数</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-city&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>city_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>partition-by-city<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;partition-by-city&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByFileMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>city.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在schema.xml文件声明虚拟表的时候引用枚举值切分规则</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;company&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;tdn3,tdn4&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding-by-city&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><code>注</code>：热加载配置文件，登录MyCat 9066端口服务，命令列界面：<code>reload @@config_all</code></p><ul><li>创建company 数据表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> company(</span><br><span class="line">    id <span class="type">INT</span> UNSIGNED <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    city_id <span class="type">SMALLINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="288-跨分片的表连接"><a class="markdownIt-Anchor" href="#288-跨分片的表连接"></a> 2.8.8 跨分片的表连接</h4><ul><li>全局表和全局表、全局表和分片表进行表连接都可以。</li><li>分片表和分片表的表连接需要在网络中传输大量的数据，所以MyCat不支持这种跨分片的表连接。</li></ul><h5 id="父子表机制"><a class="markdownIt-Anchor" href="#父子表机制"></a> 父子表机制</h5><ul><li>两张都是用了水平切分的数据表，要实现表连接查询，需要定义父子表关系</li><li>父表数据切分到什么分片，子表的数据会切分到同样的分片</li><li>父表可以由切分规则，但是子表不能配置切分规则</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--schema.xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;ID&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;tdn1,tdn2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">rule</span>=<span class="string">&quot;sharding-by-city&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">childTable</span> <span class="attr">name</span>=<span class="string">&quot;payment&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;ID&quot;</span>&gt;</span></span><br><span class="line">        joinKey=&quot;customer_id&quot; parentKey=&quot;id&quot; /&gt;</span><br><span class="line">    ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="289-全局主键"><a class="markdownIt-Anchor" href="#289-全局主键"></a> 2.8.9 全局主键</h4><ul><li>在数据库集群环境中，应该使用中间件来生成主键值</li><li>MyCat支持多种主键生成方式，推荐使用Zookeeper方式</li></ul><h5 id="本地文件方式不推荐"><a class="markdownIt-Anchor" href="#本地文件方式不推荐"></a> 本地文件方式（不推荐）</h5><ul><li>MyCat按照计数器的方式生成自增长的主键值</li><li>计数器的参数被保存在文本文档中</li></ul><h5 id="数据库方式不推荐"><a class="markdownIt-Anchor" href="#数据库方式不推荐"></a> 数据库方式（不推荐）</h5><ul><li>Mycat按照计数器的方式生成自增长的主键值</li><li>计数器的参数被保存在数据库中</li></ul><h5 id="本地时间戳方式根据情况选择"><a class="markdownIt-Anchor" href="#本地时间戳方式根据情况选择"></a> 本地时间戳方式（根据情况选择）</h5><ul><li>MyCat根据本地时间戳和机器ID，生成一个18位的主键值</li><li>因为生成的主键值都是偶数，所以无法用在主键求模切分规则上</li></ul><h5 id="zookeeper时间戳方式推荐"><a class="markdownIt-Anchor" href="#zookeeper时间戳方式推荐"></a> Zookeeper时间戳方式（推荐）</h5><ul><li>利用Zookeeper生成时间戳主键值，主键字段必须使用bigint类型</li><li>Zookeeper生成的时间戳主键值包含奇数和偶数，可以用于主键值求模切分</li><li>可以对Zookeeper建立集群，实现分布式生成主键值</li></ul><h4 id="2810-zookeeper"><a class="markdownIt-Anchor" href="#2810-zookeeper"></a> 2.8.10 Zookeeper</h4><ul><li>下载安装Zookeeper官方镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull zookeeper</span><br></pre></td></tr></table></figure><ul><li>启动Zookeeper容器</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name z1</span><br><span class="line">-p 2181:2181 -p3888:3888</span><br><span class="line">-p 2888:2888 --net=swarm_mysql</span><br><span class="line">zookeeper</span><br></pre></td></tr></table></figure><ul><li>编辑MyCat server.xml文件，修改sequnceHandlerType属性</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sequnceHandlerType&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>编辑myid.properties文件，配置参数信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">loadZk&#x3D;true</span><br><span class="line">zkURL&#x3D;192.168.0.1:2181</span><br><span class="line">clusterId&#x3D;mycat-cluster-1</span><br><span class="line">myid&#x3D;mycat_fz_01</span><br><span class="line">clusterSize&#x3D;1</span><br><span class="line">clusterNodes&#x3D;mycat_fz_01</span><br></pre></td></tr></table></figure><ul><li>生成主键</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> NEXT <span class="keyword">VALUE</span> <span class="keyword">FOR</span> MYCATSEQ_GLOBAL;</span><br></pre></td></tr></table></figure><ul><li>使用主键</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> company(id,name,city_id)</span><br><span class="line"><span class="keyword">VALUES</span>(NEXT <span class="keyword">VALUE</span> <span class="keyword">FOR</span> MYCATSEQ_GLOBAL, &quot;...&quot;, ...)</span><br></pre></td></tr></table></figure><p><code>注</code>：Zookeeper生成主键类型为<strong>bigint</strong>, 数据表主键定义也应该是<strong>bigint</strong>类型</p><h2 id="3-双机热备mycat方案"><a class="markdownIt-Anchor" href="#3-双机热备mycat方案"></a> 3. 双机热备MyCat方案</h2><p>双机热备的MyCat方案具备高可用性<br /><img src="http://qiniu.gogocoding.cn/mweb/%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87.png" alt="双机热备" /></p><h3 id="31-配置虚拟ip的前提条件"><a class="markdownIt-Anchor" href="#31-配置虚拟ip的前提条件"></a> 3.1 配置虚拟IP的前提条件</h3><p><strong>不支持</strong></p><ul><li>虚拟IP只支持局域网，不可以在公网设置虚拟IP</li><li>云主机无法设置虚拟IP</li><li>Windows系统和MacOS系统无法设置虚拟机IP,必须是Linux系统</li><li>公司网络跟移动热点网络环境下，都不能设置虚拟IP</li></ul><p><strong>正确设置虚拟IP的环境</strong></p><ul><li>在Vmware虚拟机上面设置桥接网络（必须）</li><li>使用家用路由器的网络环境（连接网线最好，WIFI次之）</li></ul><h3 id="32-keepalived工作原理"><a class="markdownIt-Anchor" href="#32-keepalived工作原理"></a> 3.2 Keepalived工作原理</h3><ul><li>Keepalived基于VRRP协议，可以预防单点故障</li><li>VRRP协议将多个服务节点组成一个网络，里面有一个Master和若干Backup节点</li><li>Master会发送VRRP广播，如果Backup节点收不到广播，就认为Master节点宕机了。Backup节点会选举出一个新的Master节点</li></ul><h3 id="33-让防火墙支持vrrp协议"><a class="markdownIt-Anchor" href="#33-让防火墙支持vrrp协议"></a> 3.3 让防火墙支持VRRP协议</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --direct --permanent --add-rule ipv4</span><br><span class="line">filter INPUT 0 --in-interface ens33 --destination</span><br><span class="line">224.0.0.18 --protocol vrrp -j ACCEPT</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h3 id="34-安装keepalived"><a class="markdownIt-Anchor" href="#34-安装keepalived"></a> 3.4 安装Keepalived</h3><h4 id="341-mycat-docker容器安装keepalived"><a class="markdownIt-Anchor" href="#341-mycat-docker容器安装keepalived"></a> 3.4.1 MyCat Docker容器安装Keepalived</h4><ul><li>进入MyCat容器（基于Ubuntu），执行下列命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install keepalived</span><br></pre></td></tr></table></figure><ul><li>Keepalived的配置文件是/etc/keepalived/keepalived.conf</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vrrp_instance VI-1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface docker_gwbridge</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 123456</span><br><span class="line">    &#125;</span><br><span class="line">    virtaul_ipaddress &#123;</span><br><span class="line">        172.18.0.201</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动Keepalived</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service keepalived start</span><br></pre></td></tr></table></figure><h4 id="342-mycat-docker容器所在的宿主机安装keepalived"><a class="markdownIt-Anchor" href="#342-mycat-docker容器所在的宿主机安装keepalived"></a> 3.4.2 MyCat Docker容器所在的宿主机安装Keepalived</h4><ul><li>必须为两个MyCat容器成功配置Keepalived才算是双机热备方案</li><li>Swarm网络内的虚拟IP无法被外网访问，所以需要把虚拟IP映射到外网<br /><img src="http://qiniu.gogocoding.cn/mweb/IP%E6%98%A0%E5%B0%84.png" alt="IP映射" /></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install keepalived -y</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">vrrp_instance VI-1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 61</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 111111</span><br><span class="line">    &#125;</span><br><span class="line">    virtaul_ipaddress &#123;</span><br><span class="line">        192.168.0.150</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 192.169.0.150 8066 &#123;</span><br><span class="line">    delay_loop 3 #心跳检测（秒）</span><br><span class="line">    lb_algo rr #轮询</span><br><span class="line">    lb_kind NAT</span><br><span class="line">    persistence_timeout 50</span><br><span class="line">    protocol TCP</span><br><span class="line">    real_server 172.18.0.201 8066 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">  virtual_server 192.169.0.150 9066 &#123;</span><br><span class="line">    delay_loop 3 #心跳检测（秒）</span><br><span class="line">    lb_algo rr #轮询</span><br><span class="line">    lb_kind NAT</span><br><span class="line">    persistence_timeout 50</span><br><span class="line">    protocol TCP</span><br><span class="line">    real_server 172.18.0.201 9066 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service keepalived start</span><br></pre></td></tr></table></figure><h3 id="35-创建mysql容器"><a class="markdownIt-Anchor" href="#35-创建mysql容器"></a> 3.5 创建MySQL容器</h3><h4 id="351-创建mysql-docker容器"><a class="markdownIt-Anchor" href="#351-创建mysql-docker容器"></a> 3.5.1 创建MySQL Docker容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9003:3306 --name rn1 -e MYSQL_ROOT_PASSWORD=abc123456 -v rnv1:/var/lib/mysql --privileged --net=swarm_mysql mysql</span><br></pre></td></tr></table></figure><h4 id="352-创建同步账户"><a class="markdownIt-Anchor" href="#352-创建同步账户"></a> 3.5.2 创建同步账户</h4><ul><li>从节点需要先登录到主节点，然后才可以复制binlog日志，所以我们要在主节点上创建一个用于数据同步的账户</li><li>因为root不允许远程登录，所以从节点不能用root账户访问主节点</li></ul><p>开启账户MySQL服务器权限</p><ul><li>Super</li><li>Reload</li><li>Replication Slave</li></ul><h4 id="353-配置主节点"><a class="markdownIt-Anchor" href="#353-配置主节点"></a> 3.5.3 配置主节点</h4><p>修改/etc/mysql/my.cnf配置文件，加上下面参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character_set_server &#x3D; utf8</span><br><span class="line">server_id &#x3D; 1001</span><br><span class="line">log_bin &#x3D; mysql_bin</span><br><span class="line">relay_log &#x3D; relay_bin</span><br><span class="line">log-slave-updates &#x3D; 1</span><br><span class="line">sql_mode&#x3D;NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br></pre></td></tr></table></figure><h4 id="354-配置从节点"><a class="markdownIt-Anchor" href="#354-配置从节点"></a> 3.5.4 配置从节点</h4><p>修改/etc/mysql/my.cnf配置文件，加上下面的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character_set_server &#x3D; utf8</span><br><span class="line">server_id &#x3D; 1002</span><br><span class="line">log_bin &#x3D; mysql_bin</span><br><span class="line">relay_log &#x3D; relay_bin</span><br><span class="line">read-only &#x3D; 1</span><br></pre></td></tr></table></figure><h3 id="35-设置主从同步"><a class="markdownIt-Anchor" href="#35-设置主从同步"></a> 3.5 设置主从同步</h3><p>在从节点上面，执行下面三条SQL语句，就能实现数据同步</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">  </span><br><span class="line">change master <span class="keyword">to</span> </span><br><span class="line">master_host<span class="operator">=</span><span class="string">&#x27;rn1&#x27;</span>,master_port<span class="operator">=</span><span class="number">3306</span>,</span><br><span class="line">master_user<span class="operator">=</span><span class="string">&#x27;backup&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">start</span> slave</span><br></pre></td></tr></table></figure><h3 id="36-检查主从同步状态"><a class="markdownIt-Anchor" href="#36-检查主从同步状态"></a> 3.6 检查主从同步状态</h3><p>在从节点上面执行下面SQL,如果能看到Slave_IO_Running和Slave_SQL_Running两个YES代表主从同步成功</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> slave status;</span><br></pre></td></tr></table></figure><h3 id="37-修改replication集群配置文件schemaxml"><a class="markdownIt-Anchor" href="#37-修改replication集群配置文件schemaxml"></a> 3.7 修改Replication集群配置文件schema.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataNode</span>&gt;</span> ...<span class="tag">&lt;/<span class="name">dataNode</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> &gt;</span> ... <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17. ECDSA, Elliptic Curve Digital Signatures</title>
      <link href="/2020/03/05/CryptoGraphy/17.%20ECDSA:%20Elliptic%20Curve%20Digital%20Signatures/"/>
      <url>/2020/03/05/CryptoGraphy/17.%20ECDSA:%20Elliptic%20Curve%20Digital%20Signatures/</url>
      
        <content type="html"><![CDATA[<p>​<a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm"><strong>ECDSA sign / verify</strong></a>ECDSA签名/验证算法依赖于EC点乘法，并且如下所述工作。对于相同的安全级别，ECDSA密钥和签名比RSA中的短。 256位ECDSA签名具有与3072位RSA签名相同的安全强度。</p><p>​ECDSA在经典Weierstrass形式的有限域上使用加密椭圆曲线（ <a href="https://wizardforcel.gitbooks.io/practical-cryptography-for-developers-book/asymmetric-key-ciphers/elliptic-curve-cryptography-ecc.html">cryptographic <strong>elliptic curves</strong> ,EC</a> ）。 这些曲线由其EC域参数描述，这些参数由各种加密标准（例如 <a href="http://www.secg.org/sec2-v2.pdf"><strong>SECG: SEC 2</strong></a> 和 <a href="https://tools.ietf.org/html/rfc5639"><strong>Brainpool (RFC 5639)</strong></a>）指定。<br />​<br /><strong>​加密中使用的椭圆曲线定义：</strong></p><ul><li><strong>Generator point</strong> <strong>G</strong>：用于曲线上的标量乘法（将整数乘以EC点）</li><li><strong>Order</strong> <em><strong>n</strong></em> ：由G生成，它定义了私钥的长度（例如256位）</li></ul><h2 id="171-密钥生成"><a class="markdownIt-Anchor" href="#171-密钥生成"></a> 17.1 密钥生成</h2><p>​<strong>ECDSA密钥对包括</strong>：</p><ul><li><strong>private key</strong> (integer): <em><strong>privKey</strong></em></li><li><strong>public key</strong> (EC point): <em><strong>pubKey</strong></em> = <em><strong>privKey</strong></em> * <strong>G</strong></li></ul><h2 id="172-ecdsa签名"><a class="markdownIt-Anchor" href="#172-ecdsa签名"></a> 17.2 ECDSA签名</h2><p>​ECDSA签名算法（<a href="https://tools.ietf.org/html/rfc6979#section-3.2"><strong>RFC 6979</strong></a>）将消息msg +私钥 privKey 作为输入，并生成由整数{r，s}对组成的签名作为输出。 ECDSA签名算法基于<a href="https://en.wikipedia.org/wiki/ElGamal_signature_scheme"><strong>ElGamal signature scheme</strong></a>，其工作原理如下（略有简化）：</p><ol><li>使用类似于SHA-256的加密哈希函数计算消息哈希：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>=</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>m</mi><mi>s</mi><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h = hash(msg)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span></li><li>安全地生成范围为[1…n-1]的随机数k<ul><li>在<strong>deterministic-ECDSA</strong>的情况下，值k是从 h + privKey 派生的HMAC</li></ul></li><li>计算随机点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>=</mo><mi>k</mi><mo>⋅</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">R = k \cdot G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>并获取其x坐标：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>=</mo><mi>R</mi><mi mathvariant="normal">.</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">r = R.x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">.</span><span class="mord mathdefault">x</span></span></span></span></li><li>计算签名证明:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><msup><mi>k</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>⋅</mo><mo stretchy="false">(</mo><mi>h</mi><mo>+</mo><mi>r</mi><mo>⋅</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>v</mi><mi>K</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s=k^{-1} \cdot (h + r \cdot privKey)(mod \quad n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><ul><li>模逆 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>k</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k^{-1} (mod \quad n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>是个整数，使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>⋅</mo><msup><mi>k</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>≡</mo><mn>1</mn><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k \cdot k^{-1}≡1(mod \quad n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul></li><li>返回签名{r, s}</li></ol><p>​计算出的签名{r，s}是一对整数，每个整数在[1 … n-1]范围内。 它对随机点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>=</mo><mi>k</mi><mo>⋅</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">R = k \cdot G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>以及证明s进行编码，从而确认签名者知道消息h和私钥privKey。 可以通过使用相应的pubKey验证该证明。</p><h2 id="173-ecdsa验证签名"><a class="markdownIt-Anchor" href="#173-ecdsa验证签名"></a> 17.3 ECDSA验证签名</h2><p>​验证ECDSA签名的算法将签名消息msg +从签名算法产生的签名{r，s} +对应于签名者私钥的公钥pubKey作为输入。 输出为布尔值：有效或无效签名。 ECDSA签名验证算法的工作原理如下（略有简化）：</p><ol><li>使用签名期间使用的相同加密哈希函数计算消息哈希：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>=</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>m</mi><mi>s</mi><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h = hash(msg)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span></li><li>计算签名证明的模逆：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mn>1</mn><mo>=</mo><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s1 = s^{-1} (mod \quad n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li>恢复签名期间使用的随机点：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>R</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo>⋅</mo><mi>s</mi><mn>1</mn><mo stretchy="false">)</mo><mo>⋅</mo><mi>G</mi><mo>+</mo><mo stretchy="false">(</mo><mi>r</mi><mo>⋅</mo><mi>s</mi><mn>1</mn><mo stretchy="false">)</mo><mo>⋅</mo><mi>p</mi><mi>u</mi><mi>b</mi><mi>K</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">R&#x27; = (h \cdot s1) \cdot G + (r \cdot s1) \cdot pubKey</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></li><li>从R’获得其x坐标：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>r</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><msup><mi>R</mi><mo mathvariant="normal">′</mo></msup><mi mathvariant="normal">.</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">r&#x27;= R&#x27;.x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathdefault">x</span></span></span></span></li><li>通过比较r’== r得出签名验证结果</li></ol><p>​签名验证的总体思路是使用公钥恢复点R’，并检查其是否与在签名过程中随机生成的点R相同。</p><p><code>ECDSA签名/验证基本逻辑</code>：</p><ul><li>签名使用私钥privKey和消息哈希h通过椭圆曲线变换将随机点R（仅由其x坐标表示）编码为数字s，这证明了消息签名者知道私钥privKey 。 由于ECDLP问题的困难，签名{r，s}无法显示私钥。</li><li>签名验证使用公钥pubKey和消息哈希h将签名中的证明编号s解码回其原始点R，并将恢复的R的x坐标与签名中的r值进行比较。</li></ul><p>##17.4 ECDSA签名/验证背后的数学</p><p>​上述签名/验证方案如何工作？ 这并不明显，但让我们来研究一下这些方程式。在签名验证过程中计算出的恢复点R’的公式可以通过将pubKey替换为privKey * G来进行转换，如下所示：</p><p>$ R’ = (h \cdot s1) \cdot G + (r \cdot s1 ) \cdot pubKey$</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo>⋅</mo><mi>s</mi><mn>1</mn><mo stretchy="false">)</mo><mo>⋅</mo><mi>G</mi><mo>+</mo><mo stretchy="false">(</mo><mi>r</mi><mo>⋅</mo><mi>s</mi><mn>1</mn><mo stretchy="false">)</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>v</mi><mi>K</mi><mi>e</mi><mi>y</mi><mo>⋅</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">=(h \cdot s1) \cdot G + (r \cdot s1) privKey \cdot G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo>+</mo><mi>r</mi><mo>⋅</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>v</mi><mi>K</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>s</mi><mn>1</mn><mo>⋅</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">=(h + r \cdot privKey) \cdot s1 \cdot G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span></p><p>​如果我们取数字<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><msup><mi>k</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>⋅</mo><mo stretchy="false">(</mo><mi>h</mi><mo>+</mo><mi>r</mi><mo>⋅</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>v</mi><mi>K</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s = k^{-1} \cdot (h + r \cdot privKey)(mod \quad n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，在签名过程中计算，我们可以计算出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mn>1</mn><mo>=</mo><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s1 = s^{-1}(mod \quad n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>如下：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mn>1</mn><mo>=</mo><msup><mi>s</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s1 = s^{-1}(mod \quad n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mo stretchy="false">(</mo><msup><mi>k</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>⋅</mo><mo stretchy="false">(</mo><mi>h</mi><mo>+</mo><mi>r</mi><mo>⋅</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>v</mi><mi>K</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">= (k^{-1} \cdot (h + r \cdot privKey))^{-1}(mod \quad n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mi>k</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>h</mi><mo>+</mo><mi>r</mi><mo>⋅</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>v</mi><mi>K</mi><mi>e</mi><mi>y</mi><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">=k * (h + r \cdot privKey)^{-1}(mod \quad n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><p>现在，在点R’中替换s1。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>R</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo>+</mo><mi>r</mi><mo>⋅</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>v</mi><mi>K</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>s</mi><mn>1</mn><mo>⋅</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">R&#x27; = (h + r \cdot privKey) \cdot s1 \cdot G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo>+</mo><mi>r</mi><mo>⋅</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>v</mi><mi>K</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>k</mi><mo>⋅</mo><mo stretchy="false">(</mo><mi>h</mi><mo>+</mo><mi>r</mi><mo>⋅</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>v</mi><mi>K</mi><mi>e</mi><mi>y</mi><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>n</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">=(h + r \cdot privKey) \cdot k \cdot (h + r \cdot privKey)^{-1}(mod \quad n) \cdot G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mi>k</mi><mo>⋅</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">= k \cdot G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span></p><p>​最后一步是将点R’（由pubKey解码）与点R（由privKey编码）进行比较。 实际上，该算法仅比较R’和R的x坐标：整数r’和r。</p><p>​如果签名有效，则期望r’== r，如果签名或消息或公钥不正确，则期望r’≠r。<br />​</p><h2 id="175-ecdsa从签名中恢复公钥"><a class="markdownIt-Anchor" href="#175-ecdsa从签名中恢复公钥"></a> 17.5 ECDSA：从签名中恢复公钥</h2><p>​知道ECDSA签名方案允许将公钥与签名一起从已签名消息中恢复是非常重要的。 恢复过程基于一些数学计算（在 <a href="http://www.secg.org/sec1-v2.pdf"><strong>SECG: SEC 1</strong></a> 标准中描述）并返回0、1或2个可能的EC点，它们是与签名相对应的有效公钥。为了避免这种歧义，某些ECDSA实现在签名过程中向签名添加了一个额外的位v，并且形式为{r，s，v}。 通过扩展的ECDSA签名{r，s，v} +签名消息，可以放心地恢复签名者的公钥。</p><p>​当无法提供公共密钥的传输或存储时，从ECDSA签名中恢复公共密钥在带宽受限或存储受限的环境（例如区块链系统）中非常有用。 例如，以太坊区块链对链上的已签名交易使用扩展签名{r，s，v}，以节省存储空间和带宽。</p><h4 id="使用ecdsa签名验证消息-示例"><a class="markdownIt-Anchor" href="#使用ecdsa签名验证消息-示例"></a> 使用ECDSA签名/验证消息-示例</h4><p>​在此示例中，我们将使用pycoin package，该软件包使用曲线secp256k1（用于比特币加密）来实现ECDSA签名算法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pycoin</span><br></pre></td></tr></table></figure><p><strong>使用secp256k1曲线和SHA3-256进行ECDSA签名/验证</strong></p><p>首先，定义hash，ECDSA签名和ECDSA签名验证的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pycoin.ecdsa <span class="keyword">import</span> generator_secp256k1, sign, verify</span><br><span class="line"><span class="keyword">import</span> hashlib, secrets</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sha3_256Hash</span>(<span class="params">msg</span>):</span></span><br><span class="line">    hashBytes = hashlib.sha3_256(msg.encode(<span class="string">&quot;utf8&quot;</span>)).digest()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>.from_bytes(hashBytes, byteorder=<span class="string">&quot;big&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">signECDSAsecp256k1</span>(<span class="params">msg, privKey</span>):</span></span><br><span class="line">    msgHash = sha3_256Hash(msg)</span><br><span class="line">    signature = sign(generator_secp256k1, privKey, msgHash)</span><br><span class="line">    <span class="keyword">return</span> signature</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verifyECDSAsecp256k1</span>(<span class="params">msg, signature, pubKey</span>):</span></span><br><span class="line">    msgHash = sha3_256Hash(msg)</span><br><span class="line">    valid = verify(generator_secp256k1, pubKey, msgHash, signature)</span><br><span class="line">    <span class="keyword">return</span> valid</span><br></pre></td></tr></table></figure><p>现在，用上面定义的函数对消息进行签名并验证其签名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ECDSA sign message (using the curve secp256k1 + SHA3-256)</span></span><br><span class="line">msg = <span class="string">&quot;Message for ECDSA signing&quot;</span></span><br><span class="line">privKey = secrets.randbelow(generator_secp256k1.order())</span><br><span class="line">signature = signECDSAsecp256k1(msg, privKey)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Message:&quot;</span>, msg)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Private key:&quot;</span>, <span class="built_in">hex</span>(privKey))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Signature: r=&quot;</span> + <span class="built_in">hex</span>(signature[<span class="number">0</span>]) + <span class="string">&quot;, s=&quot;</span> + <span class="built_in">hex</span>(signature[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ECDSA verify signature (using the curve secp256k1 + SHA3-256)</span></span><br><span class="line">pubKey = (generator_secp256k1 * privKey).pair()</span><br><span class="line">valid = verifyECDSAsecp256k1(msg, signature, pubKey)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nMessage:&quot;</span>, msg)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Public key: (&quot;</span> + <span class="built_in">hex</span>(pubKey[<span class="number">0</span>]) + <span class="string">&quot;, &quot;</span> + <span class="built_in">hex</span>(pubKey[<span class="number">1</span>]) + <span class="string">&quot;)&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Signature valid?&quot;</span>, valid)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ECDSA verify tampered signature (using the curve secp256k1 + SHA3-256)</span></span><br><span class="line">msg = <span class="string">&quot;Tampered message&quot;</span></span><br><span class="line">valid = verifyECDSAsecp256k1(msg, signature, pubKey)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nMessage:&quot;</span>, msg)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Signature (tampered msg) valid?&quot;</span>, valid)</span><br></pre></td></tr></table></figure><p>上面代码的输出是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Message: Message for ECDSA signing</span><br><span class="line">Private key: 0x79afbf7147841fca72b45a1978dd7669470ba67abbe5c220062924380c9c364b</span><br><span class="line">Signature: r&#x3D;0xb83380f6e1d09411ebf49afd1a95c738686bfb2b0fe2391134f4ae3d6d77b78a, s&#x3D;0x6c305afcac930a3ea1721c04d8a1a979016baae011319746323a756fbaee1811</span><br><span class="line"></span><br><span class="line">Message: Message for ECDSA signing</span><br><span class="line">Public key: (0x3804a19f2437f7bba4fcfbc194379e43e514aa98073db3528ccdbdb642e240, 0x6b22d833b9a502b0e10e58aac485aa357bccd1df6ec0fa4d398908c1ac1920bc)</span><br><span class="line">Signature valid? True</span><br><span class="line"></span><br><span class="line">Message: Tampered message</span><br><span class="line">Signature (tampered msg) valid? False</span><br></pre></td></tr></table></figure><p>​从上面的输出中可以看到，随机生成的secp256k1私钥为64个十六进制数字（256位）。 签名后，获得的签名{r，s}由2 * 256位整数组成。 通过将私钥乘以曲线生成器点获得的公钥包含2 * 256位（未压缩）。 签名后，产生的ECDSA数字签名会正确验证。 如果消息被篡改，签名将无法验证。</p><h2 id="176-通过ecdsa签名恢复公钥"><a class="markdownIt-Anchor" href="#176-通过ecdsa签名恢复公钥"></a> 17.6 通过ECDSA签名恢复公钥</h2><p>在ECDSA中，可以从签名中恢复公钥。 让我们通过在上一个示例的末尾添加以下代码来演示这一点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pycoin.ecdsa <span class="keyword">import</span> possible_public_pairs_for_signature</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recoverPubKeyFromSignature</span>(<span class="params">msg, signature</span>):</span></span><br><span class="line">    msgHash = sha3_256Hash(msg)</span><br><span class="line">    recoveredPubKeys = possible_public_pairs_for_signature(</span><br><span class="line">        generator_secp256k1, msgHash, signature)</span><br><span class="line">    <span class="keyword">return</span> recoveredPubKeys</span><br><span class="line"></span><br><span class="line">msg = <span class="string">&quot;Message for ECDSA signing&quot;</span></span><br><span class="line">recoveredPubKeys = recoverPubKeyFromSignature(msg, signature)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nMessage:&quot;</span>, msg)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Signature: r=&quot;</span> + <span class="built_in">hex</span>(signature[<span class="number">0</span>]) + <span class="string">&quot;, s=&quot;</span> + <span class="built_in">hex</span>(signature[<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">for</span> pk <span class="keyword">in</span> recoveredPubKeys:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Recovered public key from signature: (&quot;</span> +</span><br><span class="line">          <span class="built_in">hex</span>(pk[<span class="number">0</span>]) + <span class="string">&quot;, &quot;</span> + <span class="built_in">hex</span>(pk[<span class="number">1</span>]) + <span class="string">&quot;)&quot;</span>)</span><br></pre></td></tr></table></figure><p>​上面的代码使用http://www.secg.org/sec1-v2.pdf中描述的算法从ECDSA签名+签名的消息中恢复所有可能的EC公共密钥。 注意，多个EC公共密钥（0、1或2）可能与消息+签名匹配。 上面的代码（以及前面的代码）的预期输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Message: Message for ECDSA signing</span><br><span class="line">Private key: 0xc374556584db050001c2c9265b546e66d3dbbe8239d17427c176d834a19638dc</span><br><span class="line">Signature: r&#x3D;0xd034c98af3274ad93f3c8ce944bbc17b11b6aa170c5f097ed98687fa0d93347c, s&#x3D;0xa2318ceea2002caba38efbba3bf8ef8d43236a6edc33c040734d8eb2ed77f608</span><br><span class="line"></span><br><span class="line">Message: Message for ECDSA signing</span><br><span class="line">Public key: (0x10b5d9028ec828a0f9111e36f046afa5a0c677357351093426bcec10c663db7d, 0x271763c56fcd87b72d59ceaa5b9c3fd2122788fe344751a9bde373f903e5bb20)</span><br><span class="line">Signature valid? True</span><br><span class="line"></span><br><span class="line">Message: Tampered message</span><br><span class="line">Signature (tampered msg) valid? False</span><br><span class="line"></span><br><span class="line">Message: Message for ECDSA signing</span><br><span class="line">Signature: r&#x3D;0xd034c98af3274ad93f3c8ce944bbc17b11b6aa170c5f097ed98687fa0d93347c, s&#x3D;0xa2318ceea2002caba38efbba3bf8ef8d43236a6edc33c040734d8eb2ed77f608</span><br><span class="line">Recovered public key from signature: (0x1353fd26a6cb6110980cfd2bb5eca3b3cc3e08c930ad5991395dd826a250c79, 0xba6825142e230ee1fa2b406f3f9158a47ee49daca8ac47898c5fd92d805a101e)</span><br><span class="line">Recovered public key from signature: (0x10b5d9028ec828a0f9111e36f046afa5a0c677357351093426bcec10c663db7d, 0x271763c56fcd87b72d59ceaa5b9c3fd2122788fe344751a9bde373f903e5bb20)</span><br></pre></td></tr></table></figure><h4 id="从扩展的ecdsa签名恢复公钥"><a class="markdownIt-Anchor" href="#从扩展的ecdsa签名恢复公钥"></a> 从扩展的ECDSA签名恢复公钥</h4><p>​为了放心地从ECDSA签名 + 消息中恢复公钥，我们需要一个生成扩展的ECDSA签名{r，s，v}并在内部支持公钥恢复的库。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install eth_keys</span><br></pre></td></tr></table></figure><p>​<code>eth_keys</code>是以太坊项目的一部分，并实现基于secp256k1的ECC密码学，私钥和公钥，ECDSA扩展签名{r，s，v}和以太坊区块链地址。 以下示例演示了私钥生成，消息签名，从签名+消息和签名验证中恢复公钥：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> eth_keys, os</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate the private + public key pair (using the secp256k1 curve)</span></span><br><span class="line">signerPrivKey = eth_keys.keys.PrivateKey(os.urandom(<span class="number">32</span>))</span><br><span class="line">signerPubKey = signerPrivKey.public_key</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Private key (64 hex digits):&#x27;</span>, signerPrivKey)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Public key (uncompressed, 128 hex digits):&#x27;</span>, signerPubKey)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ECDSA sign message (using the curve secp256k1 + Keccak-256)</span></span><br><span class="line">msg = <span class="string">b&#x27;Message for signing&#x27;</span></span><br><span class="line">signature = signerPrivKey.sign_msg(msg)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Message:&#x27;</span>, msg)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Signature: [r = &#123;0&#125;, s = &#123;1&#125;, v = &#123;2&#125;]&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">    <span class="built_in">hex</span>(signature.r), <span class="built_in">hex</span>(signature.s), <span class="built_in">hex</span>(signature.v)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ECDSA public key recovery from signature + verify signature</span></span><br><span class="line"><span class="comment"># (using the curve secp256k1 + Keccak-256 hash)</span></span><br><span class="line">msg = <span class="string">b&#x27;Message for signing&#x27;</span></span><br><span class="line">recoveredPubKey = signature.recover_public_key_from_msg(msg)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Recovered public key (128 hex digits):&#x27;</span>, recoveredPubKey)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Public key correct?&#x27;</span>, recoveredPubKey == signerPubKey)</span><br><span class="line">valid = signerPubKey.verify_msg(msg, signature)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Signature valid?&quot;</span>, valid)</span><br></pre></td></tr></table></figure><p>上面代码的输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Private key (64 hex digits): 0x68abc765746a33272e47b0a96a0b4184048f70354221e04219fbc223bfe79794</span><br><span class="line">Public key (uncompressed, 128 hex digits): 0x30a6dc572da312587144e7ccda1e9abd901323adebe7091bb4985e1202c2a10bc25f681b3d2e1a671438f0b125287b473c09ca345c5583cd627232b536b9ca0a</span><br><span class="line">Message: b&#39;Message for signing&#39;</span><br><span class="line">Signature: [r &#x3D; 0x4cddf146c578d20a31fa6128e5d9afe6ac666e5ef5899f2767cacb56a42703cc, s &#x3D; 0x3847036857aa3f077a2e142eee707e5af2653baa99b9d10764a0be3d61595dbb, v &#x3D; 0x0]</span><br><span class="line">Recovered public key (128 hex digits): 0x30a6dc572da312587144e7ccda1e9abd901323adebe7091bb4985e1202c2a10bc25f681b3d2e1a671438f0b125287b473c09ca345c5583cd627232b536b9ca0a</span><br><span class="line">Public key correct? True</span><br><span class="line">Signature valid? True</span><br></pre></td></tr></table></figure><p>​公钥恢复将始终成功，因为扩展的ECDSA签名没有任何歧义。 除非消息，公钥或签名被篡改，否则签名验证将成功。 我们也可以随意使用上述代码，进行更改，篡改签名的消息并查看会发生什么。</p>]]></content>
      
      
      <categories>
          
          <category> CryptoGraphy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CryptoGraphy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16.RSA Signatures, Sign and Verify</title>
      <link href="/2020/03/05/CryptoGraphy/16.%20RSA%20Signatures:%20Sign%20and%20Verify/"/>
      <url>/2020/03/05/CryptoGraphy/16.%20RSA%20Signatures:%20Sign%20and%20Verify/</url>
      
        <content type="html"><![CDATA[<p>RSA签名/验证算法的工作原理如下所述。</p><h2 id="161-密钥生成"><a class="markdownIt-Anchor" href="#161-密钥生成"></a> 16.1 密钥生成</h2><p>​RSA算法使用大小为1024、2048、4096，…，16384位的密钥。 RSA还支持更长的密钥（例如65536位），但是对于实际使用而言，性能太慢（某些操作可能需要几分钟甚至几小时）。 对于128位安全级别，需要3072位密钥。</p><p><strong>​RSA密钥对包括：</strong></p><ul><li>public key {<em><strong>n</strong></em>, <em><strong>e</strong></em>}</li><li>private key {<em><strong>n</strong></em>, <em><strong>d</strong></em>}</li></ul><p>​数字n和d通常是大整数（例如3072位），而e小，通常是65537。</p><p>​根据定义，RSA密钥对具有以下属性：</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msup><mi>m</mi><mi>e</mi></msup><msup><mo stretchy="false">)</mo><mi>d</mi></msup><mo>≡</mo><mo stretchy="false">(</mo><msup><mi>m</mi><mi>d</mi></msup><msup><mo stretchy="false">)</mo><mi>e</mi></msup><mo>≡</mo><mi>m</mi><mspace width="1em"/><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(m^e)^d≡(m^d)^e≡m \quad (mod \quad n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> for all <em><strong>m</strong></em> in the range [0…<em><strong>n</strong></em>)</li></ul><h2 id="162-rsa签名"><a class="markdownIt-Anchor" href="#162-rsa签名"></a> 16.2 RSA签名</h2><p>​<strong>使用私钥指数d签署消息msg：</strong></p><ul><li>计算消息哈希：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>=</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>m</mi><mi>s</mi><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h = hash ( msg )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span></li><li>加密h来计算签名：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><msup><mi>h</mi><mi>d</mi></msup><mspace width="1em"/><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s = h^d \quad (mod \quad n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul><p>​哈希h应当在[0 … n）范围内。 获得的签名s是[0 … n）范围内的整数。</p><h2 id="163-rsa验证签名"><a class="markdownIt-Anchor" href="#163-rsa验证签名"></a> 16.3 RSA验证签名</h2><p>​<strong>使用公开密钥e验证消息msg的签名s：</strong></p><ul><li>计算消息哈希：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>=</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>m</mi><mi>s</mi><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h = hash ( msg )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span></li><li>解密签名：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>h</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><msup><mi>s</mi><mi>e</mi></msup><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h&#x27; = s^e(mod \quad n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li>比较h和h’以查找签名是否有效 s<br />​<br />​如果签名正确，则以下内容为真:<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>h</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><msup><mi>s</mi><mi>e</mi></msup><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msup><mi>h</mi><mi>d</mi></msup><msup><mo stretchy="false">)</mo><mi>e</mi></msup><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">h&#x27;=s^e(mod \quad n) = (h^d)^e(mod \quad n) = h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span></li></ul><h2 id="164-rsa签名验证-示例"><a class="markdownIt-Anchor" href="#164-rsa签名验证-示例"></a> 16.4 RSA：签名/验证-示例</h2><p>​生成密钥后，我们将计算RSA数字签名，并通过简单的模幂运算（通过加密和解密消息哈希）来验证签名。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pycryptodome</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"></span><br><span class="line">keyPair = RSA.generate(bits=<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Public key:  (n=<span class="subst">&#123;<span class="built_in">hex</span>(keyPair.n)&#125;</span>, e=<span class="subst">&#123;<span class="built_in">hex</span>(keyPair.e)&#125;</span>)&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Private key: (n=<span class="subst">&#123;<span class="built_in">hex</span>(keyPair.n)&#125;</span>, d=<span class="subst">&#123;<span class="built_in">hex</span>(keyPair.d)&#125;</span>)&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面代码的输出可能看起来像这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Public key:  (n&#x3D;0xf51518d30754430e4b89f828fd4f1a8e8f44dd10e0635c0e93b7c01802729a37e1dfc8848d7fbbdf2599830268d544c1ecab4f2b19b6164a4ac29c8b1a4ec6930047397d0bb93aa77ed0c2f5d5c90ff3d458755b2367b46cc5c0d83f8f8673ec85b0575b9d1cea2c35a0b881a6d007d95c1cc94892bec61c2e9ed1599c1e605f, e&#x3D;0x10001)</span><br><span class="line">Private key: (n&#x3D;0xf51518d30754430e4b89f828fd4f1a8e8f44dd10e0635c0e93b7c01802729a37e1dfc8848d7fbbdf2599830268d544c1ecab4f2b19b6164a4ac29c8b1a4ec6930047397d0bb93aa77ed0c2f5d5c90ff3d458755b2367b46cc5c0d83f8f8673ec85b0575b9d1cea2c35a0b881a6d007d95c1cc94892bec61c2e9ed1599c1e605f, d&#x3D;0x165ecc9b4689fc6ceb9c3658977686f8083fc2e5ed75644bb8540766a9a2884d1d82edac9bb5d312353e63e4ee68b913f264589f98833459a7a547e0b2900a33e71023c4dedb42875b2dfdf412881199a990dfb77c097ce71b9c8b8811480f1637b85900137231ab47a7e0cbecc0b011c2c341b6de2b2e9c24d455ccd1fc0c21)</span><br></pre></td></tr></table></figure><p>​现在，让我们使用RSA私钥{n，d}签名消息。 计算其哈希值并以私钥加密哈希值。 我们将使用SHA-512哈希。 它将适合当前的RSA密钥大小（1024）。 在Python中，我们具有内置的幂函数pow（x，y，n）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RSA sign the message</span></span><br><span class="line">msg = <span class="string">b&#x27;A message for signing&#x27;</span></span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha512</span><br><span class="line"><span class="built_in">hash</span> = <span class="built_in">int</span>.from_bytes(sha512(msg).digest(), byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">signature = <span class="built_in">pow</span>(<span class="built_in">hash</span>, keyPair.d, keyPair.n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Signature:&quot;</span>, <span class="built_in">hex</span>(signature))</span><br></pre></td></tr></table></figure><p>所获得的数字签名是RSA密钥长度[0 … n）范围内的整数。 对于上面的私钥和上面的消息，获得的签名如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Signature: 0x650c9f2e6701e3fe73d3054904a9a4bbdb96733f1c4c743ef573ad6ac14c5a3bf8a4731f6e6276faea5247303677fb8dbdf24ff78e53c25052cdca87eecfee85476bcb8a05cb9a1efef7cb87dd68223e117ce800ac46177172544757a487be32f5ab8fe0879fa8add78be465ea8f8d5acf977e9f1ae36d4d47816ea6ed41372b</span><br></pre></td></tr></table></figure><p>​签名是1024位整数（128个字节，256个十六进制数字）。 该签名大小对应于RSA密钥大小。</p><p>​现在，让我们验证签名，方法是使用公钥解密签名，然后将获得的哈希值从签名与原始签名消息的哈希值进行比较：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RSA verify signature</span></span><br><span class="line">msg = <span class="string">b&#x27;A message for signing&#x27;</span></span><br><span class="line"><span class="built_in">hash</span> = <span class="built_in">int</span>.from_bytes(sha512(msg).digest(), byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">hashFromSignature = <span class="built_in">pow</span>(signature, keyPair.e, keyPair.n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Signature valid:&quot;</span>, <span class="built_in">hash</span> == hashFromSignature)</span><br></pre></td></tr></table></figure><p>​输出将显示True，因为签名将是有效的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Signature valid: True</span><br></pre></td></tr></table></figure><p>现在，让我们尝试篡改消息并再次验证签名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RSA verify signature (tampered msg)</span></span><br><span class="line">msg = <span class="string">b&#x27;A message for signing (tampered)&#x27;</span></span><br><span class="line"><span class="built_in">hash</span> = <span class="built_in">int</span>.from_bytes(sha512(msg).digest(), byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">hashFromSignature = <span class="built_in">pow</span>(signature, keyPair.e, keyPair.n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Signature valid (tampered):&quot;</span>, <span class="built_in">hash</span> == hashFromSignature)</span><br></pre></td></tr></table></figure><p>​现在，签名将无效，以上代码的输出将是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Signature valid (tampered): False</span><br></pre></td></tr></table></figure><h2 id="165-rsa签名标准pkcs1"><a class="markdownIt-Anchor" href="#165-rsa签名标准pkcs1"></a> 16.5 RSA签名标准PKCS＃1</h2><p>​上面演示了RSA签名的简单用法，但是该行业通常遵循加密标准。 对于RSA签名，最常用的标准是“ PKCS＃1”，它具有多个版本（1.5、2.0、2.1、2.2），这是<a href="https://tools.ietf.org/html/rfc8017#page-15"><strong>RFC 8017</strong></a>中最新描述的版本。PKCS＃1标准定义了RSA签名算法（RSASP1）和RSA签名验证算法（RSAVP1），与上一节中实现的几乎相同。</p><p>​我们将基于pycryptodome库使用以下代码，该库根据PKCS#1 v1.5规范实现RSA签名/验证：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Signature.pkcs1_15 <span class="keyword">import</span> PKCS115_SigScheme</span><br><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> SHA256</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate 1024-bit RSA key pair (private + public key)</span></span><br><span class="line">keyPair = RSA.generate(bits=<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sign the message using the PKCS#1 v1.5 signature scheme (RSASP1)</span></span><br><span class="line">msg = <span class="string">b&#x27;A message for signing&#x27;</span></span><br><span class="line"><span class="built_in">hash</span> = SHA256.new(msg)</span><br><span class="line">signer = PKCS115_SigScheme(keyPair)</span><br><span class="line">signature = signer.sign(<span class="built_in">hash</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Signature:&quot;</span>, binascii.hexlify(signature))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Verify valid PKCS#1 v1.5 signature (RSAVP1)</span></span><br><span class="line">msg = <span class="string">b&#x27;A message for signing&#x27;</span></span><br><span class="line"><span class="built_in">hash</span> = SHA256.new(msg)</span><br><span class="line">signer = PKCS115_SigScheme(keyPair)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    signer.verify(<span class="built_in">hash</span>, signature)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Signature is valid.&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Signature is invalid.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Verify invalid PKCS#1 v1.5 signature (RSAVP1)</span></span><br><span class="line">msg = <span class="string">b&#x27;A tampered message&#x27;</span></span><br><span class="line"><span class="built_in">hash</span> = SHA256.new(msg)</span><br><span class="line">signer = PKCS115_SigScheme(keyPair)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    signer.verify(<span class="built_in">hash</span>, signature)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Signature is valid.&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Signature is invalid.&quot;</span>)</span><br></pre></td></tr></table></figure><p>​上面示例的输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Signature: b&#39;243b9ed6561ab3bddead98508af0ac34b4567b1358011ace24db71ce2bc7f1a2e942b6231aa84cb07bae85b668d7c7cd0bc40cdda6f8162de57f0ee842e589c58f94aa4f96d51355f8aa395d7db950ebb9d375fca3124b6222699a645e93287bc6f5eb5b750fc0b470588f949a887dff75ed42cf01d9642a5d497f609b8cd043&#39;</span><br><span class="line">Signature is valid.</span><br><span class="line">Signature is invalid.</span><br></pre></td></tr></table></figure><p><code>注</code>:在实际应用中，RSA密钥长度至少应为3072位，以提供足够安全的签名。</p>]]></content>
      
      
      <categories>
          
          <category> CryptoGraphy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CryptoGraphy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. Digital Signatures, ECDSA and EdDSA</title>
      <link href="/2020/03/05/CryptoGraphy/15.%20Digital%20Signatures,%20ECDSA%20and%20EdDSA/"/>
      <url>/2020/03/05/CryptoGraphy/15.%20Digital%20Signatures,%20ECDSA%20and%20EdDSA/</url>
      
        <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Digital_signature"><strong>Digital signatures</strong></a> (数字签名)是一种用于签名消息并验证消息签名的加密工具，以便为数字消息或电子文档提供真实性证明。 数字签名提供：</p><ul><li>消息认证：某些已知发件人（密钥所有者）已创建并签名消息的证明。</li><li>信息完整性：签名后消息未更改的证明。</li><li>不可否认：签名一旦创建，签名人就不能拒绝文档的签名。</li></ul><p>​如今，数字签名在商业和金融行业中被广泛使用。 用于授权银行付款（汇款），交换已签名的电子文件，在公共区块链系统中签署交易（例如硬币，代币或其他数字资产的转让），签署数字合同以及许多其他情况。</p><p>​数字签名无法识别到底是哪个人创建了特定的签名。但 可以结合数字证书解决此问题，该证书将公钥所有者与身份（人员，组织，网站或其他）绑定在一起。 按照设计，数字签名会将消息绑定到公钥，而不是数字身份。</p><h2 id="151-签名消息并验证签名如何工作"><a class="markdownIt-Anchor" href="#151-签名消息并验证签名如何工作"></a> 15.1 签名消息并验证签名：如何工作？</h2><p>​数字签名方案通常使用公共密钥密码系统（例如RSA或ECC）并使用公共/私有密钥对。 消息由私钥签名，签名由相应的公钥验证：</p><p><img src="http://qiniu.gogocoding.cn/mweb/digital%20signatures.png" alt="digital signatures -c" /></p><p>​消息由发件人使用私钥（签名密钥）签名。通常对输入消息进行哈希处理，然后通过签名算法计算签名。大多数签名算法都使用消息哈希+签名密钥执行某种计算，而如果没有签名密钥，则无法计算结果。消息签名的结果是数字签名。<br />​<br /><code>signMsg(msg, privKey) 🡒 signature</code></p><p>​消息签名通过相应的公钥（验证密钥）进行验证。 通常对签名的消息进行哈希处理，并且签名算法使用消息哈希+公钥来执行一些计算。 签名的结果是一个布尔值（有效或无效签名）：</p><p><code>verifyMsgSignature(msg, signature, pubKey) 🡒 valid / invalid</code></p><p>​消息签名在数学上保证了某些消息是由某个私钥签名的，该私钥对应于某个公钥。 消息签名后，无法修改消息和签名，因此可以保证消息的身份验证和完整性。 知道消息签名者公钥的任何人都可以验证签名。签名后，签名作者不能拒绝签名行为（这称为不可否认性）。</p><p>​下图显示了大多数签名方案的工作方式：</p><p><img src="http://qiniu.gogocoding.cn/mweb/signature%20schemes.png" alt="signature schemes -c" /></p><p>​签名时，将对输入消息进行哈希处理（单独或与公钥和其他输入参数一起进行哈希处理），然后进行一些计算（基于椭圆曲线，离散对数或其他密码原语）以计算数字签名。 产生的已签名消息由原始消息+计算出的签名组成。</p><p>​在签名验证时，将对验证消息进行散列（单独或与公钥一起进行散列），并在消息散列，数字签名和公钥之间执行一些计算，最后由比较确定签名是否有效 。</p><p>​数字签名与MAC（消息身份验证代码）不同，因为MAC是使用对称算法由同一秘密密钥创建和验证的，而数字签名是由签名密钥创建并由与签名相对应的不同验证密钥进行验证的 使用非对称算法的密钥。 签名和MAC代码都提供消息身份验证和完整性。</p><h2 id="152-数字签名方案和算法"><a class="markdownIt-Anchor" href="#152-数字签名方案和算法"></a> 15.2 数字签名方案和算法</h2><p>​像RSA和ECC这样的大多数非对称加密系统都提供安全的数字签名方案（签名算法）。 众所周知的数字签名方案有： <a href="https://en.wikipedia.org/wiki/Digital_Signature_Algorithm"><strong>DSA</strong></a>, <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm"><strong>ECDSA</strong></a>, <a href="https://en.wikipedia.org/wiki/EdDSA"><strong>EdDSA</strong></a>, <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Signing_messages"><strong>RSA signatures</strong></a>, <a href="https://en.wikipedia.org/wiki/ElGamal_signature_scheme"><strong>ElGamal signatures</strong></a> and <a href="https://en.wikipedia.org/wiki/Schnorr_signature"><strong>Schnorr signatures</strong></a></p><p>​上面提到的签名方案基于DLP（离散对数问题）和ECDLP（椭圆曲线离散对数问题）的难易程度，并且是量子易碎的（足够强大的量子计算机可以从消息签名中计算签名密钥）。 量子安全签名（如SPHINCS，BLISS和XMSS）由于与ECDSA和EdDSA相比具有较长的密钥长度，较长的签名和较慢的性能而未得到广泛使用。</p><p>​最受欢迎的数字签名方案有：<a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Signing_messages"><strong>RSA signatures</strong></a>, <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm"><strong>ECDSA</strong></a> and <a href="https://en.wikipedia.org/wiki/EdDSA"><strong>EdDSA</strong></a>。</p><h3 id="1521-rsa-signatures"><a class="markdownIt-Anchor" href="#1521-rsa-signatures"></a> 15.2.1 RSA Signatures</h3><p>​RSA公钥密码系统基于模幂和离散对数的数学以及整数分解问题（IFP）的难度，提供了一种密码安全的数字签名方案（签名+验证）。<br />​<br />​<strong>RSA签名/验证过程如下：</strong></p><ul><li>RSA签名算法计算消息哈希，然后使用私钥指数加密哈希以获取签名。 获得的签名是整数（RSA加密的消息哈希）。</li><li>RSA验证算法首先计算消息哈希，然后使用公钥指数解密消息签名，然后将获得的解密哈希与签名消息的哈希进行比较，以确保签名有效。</li></ul><p><strong>​RSA签名是确定性的</strong>（相同的消息+相同的私钥会产生相同的签名）。通过在签名之前用一些随机字节填充输入消息，可以很容易地设计出RSA签名的非确定性变体。</p><p>​RSA签名广泛用于现代加密技术中，例如 用于签署数字证书以保护网站。 例如，微软官方网站使用Sha256RSA作为其数字证书。 尽管如此，最近十年的趋势是从RSA和DSA转向基于椭圆曲线的签名（如ECDSA和EdDSA）。现代密码学家和开发人员更喜欢ECC签名，因为它们具有较短的密钥长度，较短的签名，较高的安全性（对于相同的密钥长度）和更好的性能。</p><h3 id="1522-dsa数字签名算法"><a class="markdownIt-Anchor" href="#1522-dsa数字签名算法"></a> 15.2.2 DSA（数字签名算法）</h3><p>​<a href="https://en.wikipedia.org/wiki/Digital_Signature_Algorithm"><strong>DSA (Digital Signature Algorithm)</strong></a> 是用于数字签名（签名消息和签名验证）的加密安全标准。由于RSA的专利限制（到2000年9月），它是RSA的替代品，并且代替了RSA。DSA是<a href="https://en.wikipedia.org/wiki/ElGamal_signature_scheme"><strong>ElGamal</strong></a>签名方案的变体。<br />​<br /><strong>​DSA签名/验证过程如下</strong>：</p><ul><li>DSA签名算法计算消息哈希，然后生成随机整数k并计算签名（整数对{r，s}），其中r是从k计算的，而s是使用 消息哈希 + 私钥指数 + 随机数k计算的。 由于随机性，签名是不确定的。</li><li>DSA签名验证算法涉及基于 消息哈希 + 公钥指数 + 签名{r，s}的计算。</li></ul><p>​随机值k（在计算签名时生成）会带来潜在的漏洞：如果使用相同的k值和相同的私钥对两个不同的消息进行签名，则攻击者可以直接计算签名者的私钥(see <a href="https://github.com/tintinweb/ecdsa-private-key-recovery">https://github.com/tintinweb/ecdsa-private-key-recovery</a>)。</p><p>​<a href="https://tools.ietf.org/html/rfc6979"><strong>RFC 6979</strong></a>中定义了<strong>deterministic-DSA</strong>变体，该变体根据私钥，消息哈希和其他一些参数将随机数k计算为HMAC。 <strong>deterministic-DSA</strong>被认为更安全。</p><h4 id="ecdsa椭圆曲线数字签名算法"><a class="markdownIt-Anchor" href="#ecdsa椭圆曲线数字签名算法"></a> ECDSA（椭圆曲线数字签名算法）</h4><p>​<a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm"><strong>ECDSA</strong></a>（Elliptic Curve Digital Signature Algorithm）椭圆曲线数字签名算法是一种基于椭圆曲线密码（ECC）的密码安全数字签名方案。</p><p>​ECDSA是对经典DSA算法的改编，该算法是从ElGamal签名方案派生的。更准确地说，ECDSA算法是ElGamal签名的一种变体，进行了一些更改和优化，以处理群元素（椭圆曲线的点）的表示形式。ECDSA使用椭圆曲线（如secp256k1），私钥（曲线密钥长度内的随机整数-用于签名消息）和公钥（EC点，通过将私钥乘以曲线生成器点从私钥计算得出的EC点）以验证签名 ）。<br />​<br /><strong>​ECDSA签名/验证过程如下：</strong></p><ul><li>ECDSA签名算法计算消息哈希，然后生成随机整数k并计算签名（一对整数{r，s}），其中r是从k计算的，而s是使用消息哈希 + 私钥 + 随机数k来计算的。 由于随机性，签名是不确定的。</li><li>ECDSA签名验证算法涉及基于 消息哈希 + 公钥 + 签名{r，s}的计算。</li></ul><p>​随机值k（在计算签名时生成）会带来潜在的漏洞：如果使用相同的k值和相同的私钥对两个不同的消息进行签名，则攻击者可以直接计算签名者的私钥(see <a href="https://github.com/tintinweb/ecdsa-private-key-recovery">https://github.com/tintinweb/ecdsa-private-key-recovery</a>).</p><p>​<strong>deterministic-ECDSA</strong> 变体在<a href="https://tools.ietf.org/html/rfc6979"><strong>RFC 6979</strong></a>中定义，该变体根据私钥+消息哈希+其他一些参数将随机数k计算为HMAC。 <strong>deterministic-ECDSA</strong>被认为更安全。</p><p>​ECDSA签名是使用最广泛的签名算法，每天有数百万人使用。 例如，Amazon网站中的数字证书由Sha256ECDSA签名方案签名。</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> CryptoGraphy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CryptoGraphy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14. ECIES (Elliptic Curve Integrated Encryption Scheme)</title>
      <link href="/2020/03/05/CryptoGraphy/14.%20ECIES%20(Elliptic%20Curve%20Integrated%20Encryption%20Scheme)/"/>
      <url>/2020/03/05/CryptoGraphy/14.%20ECIES%20(Elliptic%20Curve%20Integrated%20Encryption%20Scheme)/</url>
      
        <content type="html"><![CDATA[<p>​在许多加密标准如<a href="http://www.secg.org/sec1-v2.pdf">SECG SEC-1</a>, <a href="https://www.shoup.net/iso/std4.pdf">ISO/IEC 18033-2</a>, <a href="http://grouper.ieee.org/groups/1722/contributions/2012/1722a-butterworth-ieee1363.pdf">IEEE 1363a</a> and <a href="ftp://ftp.iks-jena.de/mitarb/lutz/standards/ansi/X9/x963-7-5-98.pdf">ANSI X9.63</a>中，类似于先前演示的代码的混合加密方案都以椭圆曲线集成加密方案（ECIES）的名称进行了标准化。ECIES是一种经过公钥认证的加密方案，其工作原理与上述代码示例相似，但是使用KDF（密钥生成函数）生成各自的MAC密钥，从ECDH共享对称加密密钥。<br />​<br />​简单来说加密时为： 使用发送者的私钥和接受者的公钥生成加密密钥ek和MAC密钥mk，用ek对明文M加密得到密文c，使用mk生成密文c的标签。将发送者的公钥，密文c和标签一起发送给接受者。（也可在生成密钥和标签的步骤加入共享消息）<br />解密时：接受者收到发送者发送的公钥，密文c和标签，加入自己的私钥，即可生成加密密钥ek和MAC密钥mk，使用ek对密文c解密，得到消息M。</p><p>​ECIES标准将基于ECC的非对称加密与对称密码相结合，以通过EC私钥提供数据加密，并通过相应的EC公钥进行解密。整体流程如下：</p><p><img src="http://qiniu.gogocoding.cn/mweb/ecies%20encryption.png" alt="ecies encryption -c" /></p><p>​ECIES加密的输入由收件人的<strong>public key</strong> + <strong>plain text message ** (公钥 + 纯文本消息)组成。 输出包括发件人的</strong>ephemeral public key**  + <strong>encrypted message</strong>  + <strong>authentication tag</strong>  (临时公共密钥 + 密文 + 身份验证标签）：</p><ul><li><code>ECIES-encrypt(recipientPublicKey, plaintextMessage)</code> ➔ <code>&#123; cipherTextPublicKey, encryptedMessage, authTag &#125;</code></li></ul><p>​ECIES解密从加密信息+收件人的私钥中获取输出，并产生原始的纯文本消息或检测到问题。</p><ul><li><code>ECIES-decrypt(cipherTextPublicKey, encryptedMessage, authTag, recipientPrivateKey )</code> ➔  <code>plaintextMessage</code></li></ul><p>​ECIES加密方案是一个框架，而不是一个具体的算法。 它可以通过插入不同的算法来实现，例如 用于公钥计算的secp256k1或P-521椭圆曲线+用于KDF函数的PBKDF2或Scrypt + 用于对称密码和身份验证标签的AES-CTR或AES-GCM或ChaCha20-Poly1305 +MAC 算法 HMAC-SHA512 (对于未经身份验证的加密）。</p><h2 id="141-ecies椭圆曲线集成加密方案-示例"><a class="markdownIt-Anchor" href="#141-ecies椭圆曲线集成加密方案-示例"></a> 14.1 ECIES（椭圆曲线集成加密方案）-示例</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install eciespy</span><br></pre></td></tr></table></figure><p>使用ECIES生成公钥/私钥对并加密和解密消息的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ecies.utils <span class="keyword">import</span> generate_eth_key</span><br><span class="line"><span class="keyword">from</span> ecies <span class="keyword">import</span> encrypt, decrypt</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">privKey = generate_eth_key()</span><br><span class="line">privKeyHex = privKey.to_hex()</span><br><span class="line">pubKeyHex = privKey.public_key.to_hex()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Encryption public key:&quot;</span>, pubKeyHex)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Decryption private key:&quot;</span>, privKeyHex)</span><br><span class="line"></span><br><span class="line">plaintext = <span class="string">b&#x27;Some plaintext for encryption&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Plaintext:&quot;</span>, plaintext)</span><br><span class="line"></span><br><span class="line">encrypted = encrypt(pubKeyHex, plaintext)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Encrypted:&quot;</span>, binascii.hexlify(encrypted))</span><br><span class="line"></span><br><span class="line">decrypted = decrypt(privKeyHex, encrypted)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Decrypted:&quot;</span>, decrypted)</span><br></pre></td></tr></table></figure><p>上面代码的输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Encryption public key: 0x0dc8e06c055b45ecf110258ed5c0261ce2019b1bd0f8f226dcd010dade448b8f304a0915c68cdf7ddded8e4021d28fb92e27d08df695f48a0d2c41ddee750fc7</span><br><span class="line">Decryption private key: 0x487fd8b53c471e3c38484a0fbe4751ace67a9ed28e60ea6b0b44c445b881f99d</span><br><span class="line">Plaintext: b&#39;Some plaintext for encryption&#39;</span><br><span class="line">Encrypted: b&#39;045699078bbd101e270572d0d68e87a8f7b6cc377ebeeffb60d2fcac5dc7bdd86a26d7f79d13b92e923a0e2cdbe418a7856b27157ef150d5c72f4f8f312467d13221ebe7049b7ed2f0ed253bce13117129a7b01bb881b8dfbf004ff11f3ebed4c732744bc49ea03230c2d1b2ec80774e79c075431d2019464d3de97ceb96&#39;</span><br><span class="line">Decrypted: b&#39;Some plaintext for encryption&#39;</span><br></pre></td></tr></table></figure><p>​注意，以上加密的消息包含4个值：{cipherPubKey，AES-nonce，authTag，AES-ciphertext}，它们以二进制形式打包并且不能从上述输出中直接看到。</p>]]></content>
      
      
      <categories>
          
          <category> CryptoGraphy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CryptoGraphy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13. ECC-Based Encryption / Decryption</title>
      <link href="/2020/03/05/CryptoGraphy/13.%20ECC-Based%20Encryption%20-%20Decryption/"/>
      <url>/2020/03/05/CryptoGraphy/13.%20ECC-Based%20Encryption%20-%20Decryption/</url>
      
        <content type="html"><![CDATA[<p>​在本节中，我们将解释如何实现基于椭圆曲线的公钥加密和对应的解密（基于ECC的非对称加密方案）。 这通常涉及混合加密方案的设计，包括ECC密码学，ECDH密钥交换和对称加密算法。</p><p>​假设我们有一个公私钥对。 我们想使用这些密钥来加密和解密数据。 根据定义，非对称加密的工作方式如下：如果我们通过私钥加密数据，则稍后我们将能够通过相应的公钥解密密文：</p><p><img src="http://qiniu.gogocoding.cn/mweb/ecc%20asymmetric%20encryption.png" alt="ecc asymmetric encryption -c400" /></p><p>​上述过程可以直接应用于RSA密码系统，但不能应用于ECC。 椭圆曲线密码学（ECC）不直接提供加密方法。 相反，我们可以通过使用ECDH（椭圆曲线Diffie-Hellman）密钥交换方案来设计混合加密方案，以导出用于对称数据加密和解密的共享密钥。</p><p>​大多数混合加密方案的工作方式如下（加密过程）：</p><p><img src="http://qiniu.gogocoding.cn/mweb/hybrid%20encryption%20schemes.png" alt="hybrid encryption schemes -c" /></p><p>​这是大多数混合加密方案的工作方式（解密过程）：</p><p><img src="http://qiniu.gogocoding.cn/mweb/hybrid%20dencryption%20schemes.png" alt="hybrid dencryption schemes -c" /></p><p>下面让我们详细介绍如何设计和实现基于ECC的混合加密方案。</p><h2 id="131-基于ecc的密钥派生使用ecdh"><a class="markdownIt-Anchor" href="#131-基于ecc的密钥派生使用ecdh"></a> 13.1 基于ECC的密钥派生（使用ECDH）</h2><p>​假设我们在有限域上具有一条加密椭圆曲线及其生成器点G。我们可以使用以下两个函数来计算用于加密和解密的共享秘密密钥（源自ECDH方案）：</p><ul><li><p><strong>calculateEncryptionKey</strong>(pubKey) --&gt; (sharedECCKey, ciphertextPubKey)</p><ol><li><strong>ciphertextPrivKey</strong> = new random private key.</li><li><strong>ciphertextPubKey</strong> = ciphertextPrivKey * G.</li><li>计算共享秘钥 <strong>sharedECCKey</strong> = pubKey * ciphertextPrivKey</li><li>同时返回sharedECCKey + ciphertextPubKey。 使用sharedECCKey进行对称加密。 使用随机生成的ciphertextPubKey稍后计算解密密钥。</li></ol></li><li><p><strong>calculateDecryptionKey</strong>(privKey, ciphertextPubKey) --&gt; sharedECCKey</p><ol><li><strong>sharedECCKey</strong> = ciphertextPubKey * privKey.</li><li>返回sharedECCKey并将其用于解密。</li></ol></li></ul><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>⋅</mo><mi>G</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>b</mi><mo>=</mo><mo stretchy="false">(</mo><mi>b</mi><mo>⋅</mo><mi>G</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">(a \cdot G) \cdot b = (b \cdot G) \cdot a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span></p><p>​现在，对应的a = privKey，a * G = pubKey，b = ciphertextPrivKey，b * G = ciphertextPubKey。</p><p>​这就是上述两个函数的准确计算结果，直接遵循ECDH密钥协商方案。 在混合加密方案中，封装的ciphertextPubKey也称为“临时密钥”，因为使用ECDH密钥协商方案临时使用它来导出对称加密密钥。</p><h2 id="132-基于ecc的密钥派生-示例"><a class="markdownIt-Anchor" href="#132-基于ecc的密钥派生-示例"></a> 13.2 基于ECC的密钥派生-示例</h2><p>​使用tinyec库为消息接收方生成ECC私钥-公钥对（基于brainpoolP256r1曲线），然后结合收件人的公钥，从密钥库中导出共享密钥（用于加密）和临时密文公共密钥（用于ECDH）。收件人再从收件人的私钥和生成的较早的临时密文公钥中得出相同的秘密共享密钥（用于解密）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tinyec <span class="keyword">import</span> registry</span><br><span class="line"><span class="keyword">import</span> secrets</span><br><span class="line"></span><br><span class="line">curve = registry.get_curve(<span class="string">&#x27;brainpoolP256r1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compress_point</span>(<span class="params">point</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hex</span>(point.x) + <span class="built_in">hex</span>(point.y % <span class="number">2</span>)[<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ecc_calc_encryption_keys</span>(<span class="params">pubKey</span>):</span></span><br><span class="line">    ciphertextPrivKey = secrets.randbelow(curve.field.n)</span><br><span class="line">    ciphertextPubKey = ciphertextPrivKey * curve.g</span><br><span class="line">    sharedECCKey = pubKey * ciphertextPrivKey</span><br><span class="line">    <span class="keyword">return</span> (sharedECCKey, ciphertextPubKey)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ecc_calc_decryption_key</span>(<span class="params">privKey, ciphertextPubKey</span>):</span></span><br><span class="line">    sharedECCKey = ciphertextPubKey * privKey</span><br><span class="line">    <span class="keyword">return</span> sharedECCKey</span><br><span class="line"></span><br><span class="line">privKey = secrets.randbelow(curve.field.n)</span><br><span class="line">pubKey = privKey * curve.g</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;private key:&quot;</span>, <span class="built_in">hex</span>(privKey))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;public key:&quot;</span>, compress_point(pubKey))</span><br><span class="line"></span><br><span class="line">(encryptKey, ciphertextPubKey) = ecc_calc_encryption_keys(pubKey)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ciphertext pubKey:&quot;</span>, compress_point(ciphertextPubKey))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;encryption key:&quot;</span>, compress_point(encryptKey))</span><br><span class="line"></span><br><span class="line">decryptKey = ecc_calc_decryption_key(privKey, ciphertextPubKey)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;decryption key:&quot;</span>, compress_point(decryptKey))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private key: 0x2e2921b4cde59cdf01e7a014a322abd530b3015085c31cb6e59502da761d29e9</span><br><span class="line">public key: 0x850d3873cf4ac50ddb54ddbd27f8225fc43bd3f4c2cc0a4f9d1f9ce15fc4eb711</span><br><span class="line">ciphertext pubKey: 0x71586f9999d3ee050005054bc681c1d96c5eb054ca15b080ba245e495627003b0</span><br><span class="line">encryption key: 0x9d13d3f8f9747669432f575731926b5ed99a6883f00146cbd3203ffa7ff8b1ae1</span><br><span class="line">decryption key: 0x9d13d3f8f9747669432f575731926b5ed99a6883f00146cbd3203ffa7ff8b1ae1</span><br></pre></td></tr></table></figure><h2 id="133-基于ecc的混合加密解密-示例"><a class="markdownIt-Anchor" href="#133-基于ecc的混合加密解密-示例"></a> 13.3 基于ECC的混合加密/解密-示例</h2><p>​一旦有了密钥，我们就可以使用对称加密方案（例如AES-GCM或ChaCha20-Poly1305）将其用于对称数据加密。 让我们实现一个功能齐全的非对称ECC加密和解密混合方案。 它将基于BrainpoolP256r1曲线和AES-256-GCM认证的对称密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install tinyec</span><br><span class="line">pip install pycryptodome</span><br></pre></td></tr></table></figure><p>我们来看一下完整的ECC + AES混合加密示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tinyec <span class="keyword">import</span> registry</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> hashlib, secrets, binascii</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt_AES_GCM</span>(<span class="params">msg, secretKey</span>):</span></span><br><span class="line">    aesCipher = AES.new(secretKey, AES.MODE_GCM)</span><br><span class="line">    ciphertext, authTag = aesCipher.encrypt_and_digest(msg)</span><br><span class="line">    <span class="keyword">return</span> (ciphertext, aesCipher.nonce, authTag)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt_AES_GCM</span>(<span class="params">ciphertext, nonce, authTag, secretKey</span>):</span></span><br><span class="line">    aesCipher = AES.new(secretKey, AES.MODE_GCM, nonce)</span><br><span class="line">    plaintext = aesCipher.decrypt_and_verify(ciphertext, authTag)</span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ecc_point_to_256_bit_key</span>(<span class="params">point</span>):</span></span><br><span class="line">    sha = hashlib.sha256(<span class="built_in">int</span>.to_bytes(point.x, <span class="number">32</span>, <span class="string">&#x27;big&#x27;</span>))</span><br><span class="line">    sha.update(<span class="built_in">int</span>.to_bytes(point.y, <span class="number">32</span>, <span class="string">&#x27;big&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> sha.digest()</span><br><span class="line"></span><br><span class="line">curve = registry.get_curve(<span class="string">&#x27;brainpoolP256r1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt_ECC</span>(<span class="params">msg, pubKey</span>):</span></span><br><span class="line">    ciphertextPrivKey = secrets.randbelow(curve.field.n)</span><br><span class="line">    sharedECCKey = ciphertextPrivKey * pubKey</span><br><span class="line">    secretKey = ecc_point_to_256_bit_key(sharedECCKey)</span><br><span class="line">    ciphertext, nonce, authTag = encrypt_AES_GCM(msg, secretKey)</span><br><span class="line">    ciphertextPubKey = ciphertextPrivKey * curve.g</span><br><span class="line">    <span class="keyword">return</span> (ciphertext, nonce, authTag, ciphertextPubKey)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt_ECC</span>(<span class="params">encryptedMsg, privKey</span>):</span></span><br><span class="line">    (ciphertext, nonce, authTag, ciphertextPubKey) = encryptedMsg</span><br><span class="line">    sharedECCKey = privKey * ciphertextPubKey</span><br><span class="line">    secretKey = ecc_point_to_256_bit_key(sharedECCKey)</span><br><span class="line">    plaintext = decrypt_AES_GCM(ciphertext, nonce, authTag, secretKey)</span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br><span class="line"></span><br><span class="line">msg = <span class="string">b&#x27;Text to be encrypted by ECC public key and &#x27;</span> \</span><br><span class="line">      <span class="string">b&#x27;decrypted by its corresponding ECC private key&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;original msg:&quot;</span>, msg)</span><br><span class="line">privKey = secrets.randbelow(curve.field.n)</span><br><span class="line">pubKey = privKey * curve.g</span><br><span class="line"></span><br><span class="line">encryptedMsg = encrypt_ECC(msg, pubKey)</span><br><span class="line">encryptedMsgObj = &#123;</span><br><span class="line">    <span class="string">&#x27;ciphertext&#x27;</span>: binascii.hexlify(encryptedMsg[<span class="number">0</span>]),</span><br><span class="line">    <span class="string">&#x27;nonce&#x27;</span>: binascii.hexlify(encryptedMsg[<span class="number">1</span>]),</span><br><span class="line">    <span class="string">&#x27;authTag&#x27;</span>: binascii.hexlify(encryptedMsg[<span class="number">2</span>]),</span><br><span class="line">    <span class="string">&#x27;ciphertextPubKey&#x27;</span>: <span class="built_in">hex</span>(encryptedMsg[<span class="number">3</span>].x) + <span class="built_in">hex</span>(encryptedMsg[<span class="number">3</span>].y % <span class="number">2</span>)[<span class="number">2</span>:]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;encrypted msg:&quot;</span>, encryptedMsgObj)</span><br><span class="line"></span><br><span class="line">decryptedMsg = decrypt_ECC(encryptedMsg, privKey)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;decrypted msg:&quot;</span>, decryptedMsg)</span><br></pre></td></tr></table></figure><p>上面代码的输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">original msg: b&#39;Text to be encrypted by ECC public key and decrypted by its corresponding ECC private key&#39;</span><br><span class="line">encrypted msg: &#123;&#39;ciphertext&#39;: b&#39;b5953b3082fcefdbde91dd3c03cf83dde0822c19be6ae906a634db65115295e7cbcd7a1a492d69ba5be91990c70d8df9dc84360cf554f155ef81ce1f0ad44bd9fdabbc5f960517089262b3390e61b37610012bee4e6bcae335&#39;, &#39;nonce&#39;: b&#39;9d55f4b5c87fff773d0457f3b23a953e&#39;, &#39;authTag&#39;: b&#39;5c9d339778925aa4e44f43252a28681d&#39;, &#39;ciphertextPubKey&#39;: &#39;0x21dbc985b625f2a42d0f86fc234b49b55477928bae73dfac73bafd9bed50abe70&#39;&#125;</span><br><span class="line">decrypted msg: b&#39;Text to be encrypted by ECC public key and decrypted by its corresponding ECC private key&#39;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CryptoGraphy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CryptoGraphy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12. ECDH Key Exchange (Elliptic Curve Diffie–Hellman Key Exchange)</title>
      <link href="/2020/03/05/CryptoGraphy/12.%20ECDH%20Key%20Exchange%20(Elliptic%20Curve%20Diffie%E2%80%93Hellman%20Key%20Exchange)/"/>
      <url>/2020/03/05/CryptoGraphy/12.%20ECDH%20Key%20Exchange%20(Elliptic%20Curve%20Diffie%E2%80%93Hellman%20Key%20Exchange)/</url>
      
        <content type="html"><![CDATA[<p>​<a href="https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman"><strong>ECDH</strong></a>（椭圆曲线Diffie-Hellman密钥交换）是一种匿名密钥协商方案，该方案允许两个方（每个方都有一个椭圆曲线的公钥-私钥对）在不安全的通道上建立共享秘密。ECDH与经典的DHKE（Diffie-Hellman密钥交换）算法非常相似，但是它使用ECC点乘法而不是模幂。 ECDH基于EC点的以下属性：</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>⋅</mo><mi>G</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>b</mi><mo>=</mo><mo stretchy="false">(</mo><mi>b</mi><mo>⋅</mo><mi>G</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">(a \cdot G) \cdot b = (b \cdot G) \cdot a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span></li></ul><p>​如果我们有两个秘密数字a和b（两个私钥，分别属于Alice和Bob）和带有生成器点G的ECC椭圆曲线，则可以在不安全的通道上交换（a * G）和（b * G）值 （Alice和Bob的公共密钥），然后我们可以得出一个共享的秘密：secret =（a * G）* b =（b * G）* a， 上面的公式采用以下形式：</p><ul><li>alicePubKey * bobPrivKey = bobPubKey * alicePrivKey = <em><strong>secret</strong></em></li></ul><p>ECDH算法（椭圆曲线Diffie-Hellman密钥交换）很简单：</p><ol><li><strong>Alice</strong> generates a <strong>random</strong> ECC key pair: {<strong>alicePrivKey</strong>, <strong>alicePubKey</strong> = alicePrivKey * G}</li><li><strong>Bob</strong> generates a <strong>random</strong> ECC key pair: {<strong>bobPrivKey</strong>, <strong>bobPubKey</strong> = bobPrivKey * G}</li><li>Alice and Bob <strong>exchange their public keys</strong> through the insecure channel (e.g. over Internet)</li><li><strong>Alice</strong> calculates <strong>sharedKey</strong> = bobPubKey * alicePrivKey</li><li><strong>Bob</strong> calculates <strong>sharedKey</strong> = alicePubKey * bobPrivKey</li><li>Now both <strong>Alice</strong> and <strong>Bob</strong> have the same <strong>sharedKey</strong> == bobPubKey * alicePrivKey == alicePubKey * bobPrivKey</li></ol><h4 id="ecdh密钥交换-示例"><a class="markdownIt-Anchor" href="#ecdh密钥交换-示例"></a> ECDH密钥交换-示例</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tinyec</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tinyec <span class="keyword">import</span> registry</span><br><span class="line"><span class="keyword">import</span> secrets</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compress</span>(<span class="params">pubKey</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hex</span>(pubKey.x) + <span class="built_in">hex</span>(pubKey.y % <span class="number">2</span>)[<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line">curve = registry.get_curve(<span class="string">&#x27;brainpoolP256r1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">alicePrivKey = secrets.randbelow(curve.field.n)</span><br><span class="line">alicePubKey = alicePrivKey * curve.g</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Alice public key:&quot;</span>, compress(alicePubKey))</span><br><span class="line"></span><br><span class="line">bobPrivKey = secrets.randbelow(curve.field.n)</span><br><span class="line">bobPubKey = bobPrivKey * curve.g</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Bob public key:&quot;</span>, compress(bobPubKey))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Now exchange the public keys (e.g. through Internet)&quot;</span>)</span><br><span class="line"></span><br><span class="line">aliceSharedKey = alicePrivKey * bobPubKey</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Alice shared key:&quot;</span>, compress(aliceSharedKey))</span><br><span class="line"></span><br><span class="line">bobSharedKey = bobPrivKey * alicePubKey</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Bob shared key:&quot;</span>, compress(bobSharedKey))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Equal shared keys:&quot;</span>, aliceSharedKey == bobSharedKey)</span><br></pre></td></tr></table></figure><p>上面代码的输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Alice public key: 0x66c808e6b5be6d6620934bc6ffa2b8b47f9786c002bfb06d53a0c27535641a5d1</span><br><span class="line">Bob public key: 0x7d15195432d1ac7f38aeb054d07d9b2e1faa913b78ad04d5efdd4a1ee8d9a3191</span><br><span class="line">Now exchange the public keys (e.g. through Internet)</span><br><span class="line">Alice shared key: 0x90f5a1cf2ed1dbb0322178df6bb0dd72c541884618b2989a3e5e663198667a621</span><br><span class="line">Bob shared key: 0x90f5a1cf2ed1dbb0322178df6bb0dd72c541884618b2989a3e5e663198667a621</span><br><span class="line">Equal shared keys: True</span><br></pre></td></tr></table></figure><p>​由于随机性，每次运行上述代码，则密钥将有所不同，但最后计算出的Alice和Bob的共享将始终相同。 生成的共享机密是一个257位整数（256位曲线的压缩EC点，编码为65个十六进制数字）。</p>]]></content>
      
      
      <categories>
          
          <category> CryptoGraphy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CryptoGraphy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. Elliptic Curve Cryptography (ECC) - Concepts</title>
      <link href="/2020/03/05/CryptoGraphy/11.%20Elliptic%20Curve%20Cryptography%20(ECC)%20-%20Concepts/"/>
      <url>/2020/03/05/CryptoGraphy/11.%20Elliptic%20Curve%20Cryptography%20(ECC)%20-%20Concepts/</url>
      
        <content type="html"><![CDATA[<p>​<a href="https://en.wikipedia.org/wiki/Elliptic-curve_cryptography"><strong>Elliptic Curve Cryptography (ECC)</strong></a>是现代的公钥加密系统，它基于有限域上的椭圆曲线的代数结构以及椭圆曲线离散对数问题（ECDLP）的难度。</p><p>​ECC实现了非对称密码系统的所有主要功能：加密，签名和密钥交换。</p><p>​ECC加密被认为是RSA加密的自然的后继产品，因为在相同的安全级别上，ECC使用的密钥和签名比RSA小，并且提供了更高效率的密钥生成，密钥协商和数字签名。</p><h2 id="111-ecc密钥"><a class="markdownIt-Anchor" href="#111-ecc密钥"></a> 11.1 ECC密钥</h2><p>​ECC中的私钥是整数（在曲线区域的范围内，通常为256位整数），如:<br /><code>0x51897b64e85c3f714bba707e867914295a1377a7463a9dae8ea6a8b914246319</code></p><p>​ECC的密钥生成就像安全地生成一定范围内的随机整数一样简单，因此它非常快。 范围内的任何数字都是有效的ECC私钥。</p><p>​ECC中的公钥是EC点-放置在曲线上的成对的整数坐标{x，y}。 由于其特殊的属性，EC点可以压缩为一个坐标+1位，因此，对应于256位ECC私钥的压缩公钥是257位整数。ECC公钥的示例如下（与上述私钥相对应，以太坊格式编码，前缀为02或03的十六进制）：<br /><code>0x02f54ba86dc1ccb5bed0224d23f01ed87e4a443c47fc690d7797a13d41d2340e1a</code></p><p>在这种格式下，公钥实际上占用33个字节（66个十六进制数字），可以将其优化为恰好257位</p><h2 id="112-曲线和秘钥长度"><a class="markdownIt-Anchor" href="#112-曲线和秘钥长度"></a> 11.2 曲线和秘钥长度</h2><p>​ECC加密算法可以使用不同的基础椭圆曲线。 不同的曲线提供不同的安全性（加密强度），不同的性能（速度）和不同的密钥长度，并且可能涉及不同的算法。流行的密码库和安全标准中采用的ECC曲线具有name（命名曲线，例如secp256k1或Curve25519），<strong>field size</strong>（定义密钥长度，例如256位），security <strong>strength</strong>（通常是<strong>field size</strong>/ 2 或 更少），<strong>performance</strong>（操作数/秒）和许多其他参数。</p><p>​ECC密钥的长度直接取决于基础曲线。 在大多数应用程序（如OpenSSL，OpenSSH和Bitcoin）中，ECC私钥的默认密钥长度为256位，但根据曲线，可能有许多不同的ECC密钥大小：192位（curve secp192r1），233位（curve  sect233k1），224位（curve secp224k1），256位（curve secp256k1和curve25519），283位（curve sect283k1），384位（curve p384和secp384r1），409位（curve sect409r1），414位 （curve Curve41417），448位（curve Curve448-Goldilocks），511位（curve M-511），521位（curve P-521），571位（curve sect571k1）等。</p><h2 id="113-ecc算法"><a class="markdownIt-Anchor" href="#113-ecc算法"></a> 11.3 ECC算法</h2><p>ECC 根据有限域上椭圆曲线的数学原理，提供了几组算法：</p><ul><li>ECC数字签名算法： <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm"><strong>ECDSA</strong></a>和<a href="https://en.wikipedia.org/wiki/EdDSA"><strong>EdDSA</strong></a></li><li>ECC加密算法和混合加密方案：<a href="https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme"><strong>ECIES</strong></a>和<a href="https://cse.unl.edu/~ssamal/crypto/EEECC.pdf"><strong>EEECC</strong></a></li><li>ECC密钥协商算法： <a href="https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman"><strong>ECDH</strong></a>, <a href="https://cryptography.io/en/latest/hazmat/primitives/asymmetric/x25519/"><strong>X25519</strong></a> 和 <a href="https://fastd.readthedocs.io/en/v18/crypto/fhmqvc.html"><strong>FHMQV</strong></a></li></ul><h2 id="114-椭圆曲线"><a class="markdownIt-Anchor" href="#114-椭圆曲线"></a> 11.4 椭圆曲线</h2><p>​在数学中，椭圆曲线（<strong><a href="http://mathworld.wolfram.com/EllipticCurve.html">elliptic curves</a></strong>）是平面代数曲线，由所有点{x，y}组成，由等式描述：</p><ul><li>$Ax^3 + Bx^2y + Cxy^2 + Dy^3 + Ex^2 + Fxy + Gy^2 + Hx + Iy + J = 0 $</li></ul><p>​密码学使用简化形式（Weierstras形式）的椭圆曲线，其定义为：</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>y</mi><mn>2</mn></msup><mo>=</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">y^2 = x^3 + ax + b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span></li></ul><p>​例如， <a href="https://en.bitcoin.it/wiki/Secp256k1">NIST curve <code>secp256k1</code></a>（在比特币中使用）基于以下形式的椭圆曲线：</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>y</mi><mn>2</mn></msup><mo>=</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">y^2 = x^3 + 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span></li></ul><p>这是上述椭圆曲线的图形：</p><p><img src="http://qiniu.gogocoding.cn/mweb/secp256k1.png" alt="secp256k1 -c" /></p><p><code>注</code>:要了解有关椭圆曲线方程式及其外观的更多信息，请使用在线椭圆曲线可视化工具: <a href="https://www.desmos.com/calculator/ialhd71we3">https://www.desmos.com/calculator/ialhd71we3</a>.</p><h3 id="1141-有限域上的椭圆曲线"><a class="markdownIt-Anchor" href="#1141-有限域上的椭圆曲线"></a> 11.4.1 有限域上的椭圆曲线</h3><p>​椭圆曲线加密（ECC）在有限域 (<strong><a href="https://en.wikipedia.org/wiki/Finite_field">finite field</a></strong> ) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>𝔽</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">𝔽p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.88333em;vertical-align:-0.19444em;"></span><span class="mord mathbb">F</span><span class="mord mathdefault">p</span></span></span></span>（其中p是素数且p&gt; 3）或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>𝔽</mi><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">𝔽2^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">F</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span></span></span></span>（其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>=</mo><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">p = 2^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span></span></span></span>）上使用椭圆曲线。即该域是大小为p x p的方阵，并且仅限于曲线上的在该域内的整数坐标。域内的所有代数运算（例如点加法和乘法）都会得到域内另一个点。有限域<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>𝔽</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">𝔽p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.88333em;vertical-align:-0.19444em;"></span><span class="mord mathbb">F</span><span class="mord mathdefault">p</span></span></span></span>上的椭圆曲线方程采用以下模块化形式：</p><ul><li>$ y^2 ≡ x^3 + ax + b \quad (mod \quad p)$</li></ul><p>“比特币曲线” secp256k1采用以下形式：</p><ul><li>$ y^2 ≡ x^3 + 7 \quad (mod \quad p)$</li></ul><p>​与RSA不同，RSA的密钥空间使用[0 … p-1]范围内的整数（域<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Z</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">ℤp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.88333em;vertical-align:-0.19444em;"></span><span class="mord amsrm">Z</span><span class="mord mathdefault">p</span></span></span></span>）；ECC使用Galois域<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>𝔽</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">𝔽p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.88333em;vertical-align:-0.19444em;"></span><span class="mord mathbb">F</span><span class="mord mathdefault">p</span></span></span></span>中的点{x，y}（其中x和y是[0 … p-1]范围内的整数）。</p><p>​有限域<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>𝔽</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">𝔽p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.88333em;vertical-align:-0.19444em;"></span><span class="mord mathbb">F</span><span class="mord mathdefault">p</span></span></span></span>上的椭圆曲线包括：</p><ul><li>一组整数坐标{x，y}，使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>&lt;</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">0≤x, y &lt;p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></li><li>保持在椭圆曲线上：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>y</mi><mn>2</mn></msup><mo>≡</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mspace width="1em"/><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y^2≡x^3 + ax + b \quad (mod \quad p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></li></ul><p>有限域<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>𝔽</mi><mn>17</mn></mrow><annotation encoding="application/x-tex">𝔽17</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">F</span><span class="mord">1</span><span class="mord">7</span></span></span></span>上的椭圆曲线示例：</p><ul><li>$ y^2 ≡ x^3 + 7 \quad (mod \quad 17)$</li></ul><p>其曲线如下图所示：</p><p><img src="http://qiniu.gogocoding.cn/mweb/f17.png" alt="f17 -c" /></p><p>​有限域$ y^2 ≡ x^3 + 7 \quad (mod \quad 17)$上的椭圆曲线由上图的蓝点组成，即在实践中，密码学中使用的“椭圆曲线”是“方阵中的点集”，不是经典的 “曲线”。并且上面的曲线是“学习使用的”。 它只提供了非常小的密钥长度（4-5位）。在现实中，开发人员通常使用256位或更多位的曲线。</p><h3 id="1142-有限域上的椭圆曲线的计算"><a class="markdownIt-Anchor" href="#1142-有限域上的椭圆曲线的计算"></a> 11.4.2 有限域上的椭圆曲线的计算</h3><p>​计算某个点是否属于有限域上的某些椭圆曲线非常容易。 例如，当且仅当以下情况时，点{x，y}属于曲线$ y^2 ≡ x^3 + 7 \quad (mod \quad 17)$：</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>7</mn><mo>−</mo><msup><mi>y</mi><mn>2</mn></msup><mo>≡</mo><mn>0</mn><mspace width="1em"/><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mn>17</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x^3 + 7 - y^2 ≡ 0 \quad (mod \quad 17)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mclose">)</span></span></span></span></li></ul><p>点P {5，8}属于曲线，因为<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \％ at position 19: …^ 3 + 7-8 ^ 2) \̲％̲ 17 == 0'>(5 ^ 3 + 7-8 ^ 2) \％ 17 == 0</span>；点{9，15}不属于曲线，因为<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \％ at position 22: … + 7 - 15 ^ 2) \̲％̲ 17 \quad != 0'>(9 ^ 3 + 7 - 15 ^ 2) \％ 17 \quad != 0</span></p><p>上面提到的椭圆曲线和点{5，8}和{9，15}如下所示：</p><p><img src="http://qiniu.gogocoding.cn/mweb/ecc%20calc.png" alt="ecc cal -c" /></p><h3 id="1143-整数乘以ecc点"><a class="markdownIt-Anchor" href="#1143-整数乘以ecc点"></a> 11.4.3 整数乘以ECC点</h3><p>​椭圆曲线上两个点（EC点）可以相加，结果是另一个点。 此操作称为EC点加法。 如果将点G添加到自身G，则结果为$ G + G = 2 \cdot G $ 。如果再次将G添加到结果，则将获得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>⋅</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">3 \cdot G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>，依此类推。 这就是EC点乘法的定义。</p><p>​可以将有限域上的椭圆曲线上的点G（EC点）乘以整数k，结果是同一条曲线上的另一个EC点P，此操作很快：</p><ul><li><strong>P</strong> = <strong>k</strong> * <strong>G</strong></li></ul><p>​上面的操作涉及一些公式和转换，但是为简单起见，我们将跳过它们。 要知道的重要一点是，将EC点乘以整数会在同一条曲线上返回另一个EC点，并且此操作很快。 将EC点乘以0将返回一个称为“无穷大”的特殊EC点。</p><p><code>注</code>:  <a href="https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication">read more about EC point multiplication</a></p><p><a href="http://blog.51cto.com/11821908/2057726">http://blog.51cto.com/11821908/2057726</a><br />讲解了受限域的曲线下的加法实现计算<br /><a href="https://www.jianshu.com/p/2e6031ac3d50">https://www.jianshu.com/p/2e6031ac3d50</a><br />只讲解了无受限域下曲线的加法<br /><a href="https://wenku.baidu.com/view/6f2879cca1c7aa00b52acb5f.html">https://wenku.baidu.com/view/6f2879cca1c7aa00b52acb5f.html</a><br />分数求模原理介绍<br /><a href="https://www.pediy.com/kssd/pediy06/pediy6014.htm">https://www.pediy.com/kssd/pediy06/pediy6014.htm</a><br />看雪论坛上的详细介绍，提供了加法运算的验证集<br /><a href="https://blog.csdn.net/baidu_38271024/article/details/78881031">https://blog.csdn.net/baidu_38271024/article/details/78881031</a><br />乘法逆元求解的python实现</p><p><strong>示例：将EC点乘以整数</strong></p><p>​EC乘法的公式针对曲线的不同表示形式而有所不同。 在此示例中，我们将使用经典Weierstrass形式的椭圆曲线。在有限域<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>y</mi><mn>2</mn></msup><mo>≡</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>7</mn><mspace width="1em"/><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mn>17</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y^2≡x^3 + 7 \quad(mod \quad 17)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mclose">)</span></span></span></span>上的椭圆曲线上获取EC点G = {15，13}并将其乘以k = 6。我们将获得EC点P = {5，8 }：</p><p><img src="http://qiniu.gogocoding.cn/mweb/k%20e%206.png" alt="k e 6 -c" /></p><h3 id="1144-椭圆曲线的序和余子式"><a class="markdownIt-Anchor" href="#1144-椭圆曲线的序和余子式"></a> 11.4.4 椭圆曲线的序和余子式</h3><p>​有限域上的一个椭圆曲线可以形成一个由曲线上的所有点组成的有限循环代数群（<strong><a href="https://en.wikipedia.org/wiki/Cyclic_group">cyclic algebraic group</a></strong>），在有限循环代数群中，如果将两个EC点相加或将一个EC点乘以一个整数，则结果是同一有限循环代数群（在同一条曲线上）的另一个EC点。曲线的序是曲线上所有EC点的总数。该总点数还包括称为“<a href="https://en.wikipedia.org/wiki/Point_at_infinity"><strong>point at infinity</strong></a>”的特殊点，该特殊点是将一个点乘以0得到的。</p><p>​一些曲线形成单个循环组（保存所有EC点），而另一些曲线形成几个不重叠的循环子群（每个子集中包含曲线EC点的子集）。在第二种情况下，曲线上的点被划分为h个循环子群，每个子群的序为r（每个子群拥有相等数量的点）。整个群的序为$ n = h \cdot r $ ，拥有EC点的子群h的数量称为余子式。</p><p><img src="http://qiniu.gogocoding.cn/mweb/cofactor.png" alt="cofacto -c" /></p><ul><li><p>$ h = n / r$</p></li><li><p><strong>n</strong> 曲线的序（所有点的数量）</p></li><li><p><strong>h</strong> 曲线的余子式（点的非重叠子群的数量，它们共同保存所有曲线点）</p></li><li><p><strong>r</strong> 子群的数量（每个子群中的点数，包括每个子群的无穷远点）</p></li></ul><p>​换句话说，椭圆曲线上的点位于一个或几个不重叠的子集中，称为子群。 子群的数量称为“余子式”（<strong>cofactor</strong>）。所有子群中的总点数称为曲线的“数量”，通常用n表示。 如果曲线仅包含一个循环子群，则其余子式 h =1。如果曲线包含多个子群，则其余子式 h &gt; 1。</p><ul><li>Example of elliptic curve having <strong>cofactor</strong> = <strong>1</strong> is <code>secp256k1</code>.</li><li>Example of elliptic curve having <strong>cofactor</strong> = <strong>8</strong> is <code>Curve25519</code>.</li><li>Example of elliptic curve having <strong>cofactor</strong> = <strong>4</strong> is <code>Curve448</code>.</li></ul><h3 id="1145-ecc中的生成器点"><a class="markdownIt-Anchor" href="#1145-ecc中的生成器点"></a> 11.4.5 ECC中的“生成器”点</h3><p>​对于有限域上的椭圆曲线，ECC密码系统定义了一个特殊的预定义（恒定）EC点，称为生成器点G（<strong><a href="https://en.wikipedia.org/wiki/Generating_set_of_a_group">generator point G</a></strong>，<strong>base point</strong>），该点可以通过将G乘以某个整数来生成其在椭圆曲线上的子群中在[0 … r]范围内的任何其他点。这个数字 <strong>r</strong> 称为循环子群的“序”(子群中所有点的总数)。</p><p>​对于余子式 <code>h</code> = 1 的曲线，只有一个子群，曲线的序 <code>n</code>（曲线上不同点的总数，包括无穷大）等于数r。</p><p>​当选择好 G 和 n，且 cofactor = 1时，可以通过将生成器点G乘以[1 … n]范围内的整数，从生成器点G生成曲线上所有可能的EC点（包括特殊点无穷大）。该整数<code>n</code>被称为“曲线的序”。</p><p>​从某个EC生成器点G（可能与曲线的 序不同）获得的子群的序 <code>r</code> 定义了该曲线所有可能的私钥的总数：$ r = n / h$</p><p>​密码学家精心选择椭圆曲线域参数（曲线方程，生成器点，余子式等），以确保密钥空间足够大，足以保证一定的密码强度。</p><p>​<strong>总而言之</strong>，在ECC密码学中，EC点与生成器点G一起形成循环群（或循环子群），这意味着存在数 r（r&gt; 1），从而r * G = 0 * G = <strong>infinity</strong> 子群中的所有点都可以通过将G乘以[1 … r]范围内的整数来获得。数字 r 称为组（或子群）的“序”。</p><p>​椭圆曲线子群通常具有许多生成器点，但是密码学家会仔细选择其中的一个，从而生成整个群（或子群），并且适合于计算中的性能优化。</p><p>​众所周知，对于某些曲线，不同的生成器点会生成不同“序”的子群。 更准确地说，如果组序为n，则对于每个除以n的素数d，都会存在一个点Q，使得d * Q =<strong>infinity</strong>。 这意味着用作同一条曲线的生成器的某些点将比其他点生成更小的子群。 如果 <code>r</code> 较小，则安全性较弱。这就是所谓的 <strong><a href="https://tools.ietf.org/html/rfc2785">“small-subgroup” attacks</a></strong>。这就是密码学家通常选择子群序 r 为质数的原因。</p><p>​对于余子式 h &gt; 1的椭圆曲线，不同的基点可以在曲线上生成EC点的不同子群。 通过选择某个生成器点，我们选择在曲线上的某个子群上进行操作，使得大多数EC点操作和ECC加密算法很好地工作。应该特别注意，应该仅使用经过验证的ECC实现，算法和软件包。</p><h3 id="1146-生成器点示例"><a class="markdownIt-Anchor" href="#1146-生成器点示例"></a> 11.4.6 “生成器”点示例</h3><p>​在上面的示例（有限域 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>y</mi><mn>2</mn></msup><mo>≡</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>7</mn><mspace width="1em"/><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mn>17</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y^2≡x^3 + 7 \quad(mod \quad 17)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mclose">)</span></span></span></span>上的EC点）上，如果我们将点G = {15，13}作为生成器点，则曲线上的任何其他点都可以通过将G乘以 range[1 … 18]。 因此，此EC的 序 n = 18，其余子式 h = 1。曲线具有17个正常EC点（如上图所示）+ 一个特殊的“无穷远点”，全部位于一个子群中，并且曲线顺序为18（而不是17）。</p><p>​如果我们将点{5，9}作为生成器，它将仅生成3个EC点：{5，8}，{5，9}和无穷大点。 由于曲线 序 不是素数，因此不同的生成器可能会生成不同 序 的子群。 这是一个 “为什么我们不应该出于加密目的而“发明”自己的椭圆曲线，而应该使用经过验证的曲线”的例子，。</p><h3 id="1147-ecc中的私钥公钥和生成器点"><a class="markdownIt-Anchor" href="#1147-ecc中的私钥公钥和生成器点"></a> 11.4.7 ECC中的私钥，公钥和生成器点</h3><p>​在ECC中，当将固定的EC点G（生成器点）乘以某个整数k（k可以视为私钥）时，我们获得EC点P（即k对应的公钥）。</p><p>因此，在ECC中，我们具有：</p><ul><li>有限域<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>𝔽</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">𝔽p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.88333em;vertical-align:-0.19444em;"></span><span class="mord mathbb">F</span><span class="mord mathdefault">p</span></span></span></span>上的椭圆曲线（EC）</li><li>$ G == generator \quad point $ (EC的基点);</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mo>=</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>v</mi><mi>a</mi><mi>t</mi><mi>e</mi><mspace width="1em"/><mi>k</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">k ==private \quad key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>  整数</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>=</mo><mo>=</mo><mi>p</mi><mi>u</mi><mi>b</mi><mi>l</mi><mi>i</mi><mi>c</mi><mspace width="1em"/><mi>k</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">P == public \quad key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 点</li></ul><p>​通过的ECC乘法算法<a href="https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication">ECC multiplication algorithms</a>，可以很快地计算出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>=</mo><mi>k</mi><mo>⋅</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">P = k \cdot G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> ，时间复杂度为： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\log _2 (k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，</p><p>计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mi>P</mi><mi mathvariant="normal">/</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">k = P / G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord">/</span><span class="mord mathdefault">G</span></span></span></span>非常慢（对于大k而言，这是不可行的）。</p><p>这种不对称性（快速乘法和不可行的慢速相反操作）是ECC密码学背后的安全强度的基础，也称为ECDLP问题。</p><h3 id="1148-椭圆曲线离散对数问题ecdlp"><a class="markdownIt-Anchor" href="#1148-椭圆曲线离散对数问题ecdlp"></a> 11.4.8 椭圆曲线离散对数问题（ECDLP）</h3><p>​计算机科学中的椭圆曲线离散对数问题（ECDLP）定义如下：</p><ul><li>通过在有限域<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>𝔽</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">𝔽p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.88333em;vertical-align:-0.19444em;"></span><span class="mord mathbb">F</span><span class="mord mathdefault">p</span></span></span></span>上给定椭圆曲线，并已知在曲线上生成点G和在曲线上点P，求出整数k（如果存在），使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>=</mo><mi>k</mi><mo>⋅</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">P = k \cdot G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> ；</li></ul><p>​对于（由密码学家精心选择的）有限域和椭圆曲线，ECDLP问题没有有效的解决方案。</p><p>​<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>𝔽</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">𝔽p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.88333em;vertical-align:-0.19444em;"></span><span class="mord mathbb">F</span><span class="mord mathdefault">p</span></span></span></span>群中椭圆曲线点的乘法类似于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Z</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">ℤp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.88333em;vertical-align:-0.19444em;"></span><span class="mord amsrm">Z</span><span class="mord mathdefault">p</span></span></span></span> 组中整数的幂（这就是乘法符号），这就是ECDLP问题与DLP问题（<a href="https://wizardforcel.gitbooks.io/practical-cryptography-for-developers-book/key-exchange/diffie-hellman-key-exchange.html#discrete-logarithm-problem-dlp"><strong>DLP problem</strong></a>，离散对数问题）的相似之处。</p><h3 id="1149-ec点的乘法-示例"><a class="markdownIt-Anchor" href="#1149-ec点的乘法-示例"></a> 11.4.9 EC点的乘法-示例</h3><p>​首先，安装软件包tinec：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tinyec</span><br></pre></td></tr></table></figure><p>​我们将使用前面示例<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>y</mi><mn>2</mn></msup><mo>≡</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>7</mn><mspace width="1em"/><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mn>17</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y^2≡x^3 + 7 \quad(mod \quad 17)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mclose">)</span></span></span></span> 对应的曲线，生成点G = {15，13}，其序为n =18。我们将其命名为p1707。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tinyec.ec <span class="keyword">import</span> SubGroup, Curve</span><br><span class="line"></span><br><span class="line">field = SubGroup(p=<span class="number">17</span>, g=(<span class="number">15</span>, <span class="number">13</span>), n=<span class="number">18</span>, h=<span class="number">1</span>)</span><br><span class="line">curve = Curve(a=<span class="number">0</span>, b=<span class="number">7</span>, field=field, name=<span class="string">&#x27;p1707&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;curve:&#x27;</span>, curve)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">25</span>):</span><br><span class="line">    p = k * curve.g</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;k&#125;</span> * G = (<span class="subst">&#123;p.x&#125;</span>, <span class="subst">&#123;p.y&#125;</span>)&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">curve: &quot;p1707&quot; &#x3D;&gt; y^2 &#x3D; x^3 + 0x + 7 (mod 17)</span><br><span class="line">0 * G &#x3D; (None, None)</span><br><span class="line">1 * G &#x3D; (15, 13)</span><br><span class="line">2 * G &#x3D; (2, 10)</span><br><span class="line">3 * G &#x3D; (8, 3)</span><br><span class="line">4 * G &#x3D; (12, 1)</span><br><span class="line">5 * G &#x3D; (6, 6)</span><br><span class="line">6 * G &#x3D; (5, 8)</span><br><span class="line">7 * G &#x3D; (10, 15)</span><br><span class="line">8 * G &#x3D; (1, 12)</span><br><span class="line">9 * G &#x3D; (3, 0)</span><br><span class="line">10 * G &#x3D; (1, 5)</span><br><span class="line">11 * G &#x3D; (10, 2)</span><br><span class="line">12 * G &#x3D; (5, 9)</span><br><span class="line">13 * G &#x3D; (6, 11)</span><br><span class="line">14 * G &#x3D; (12, 16)</span><br><span class="line">15 * G &#x3D; (8, 14)</span><br><span class="line">16 * G &#x3D; (2, 7)</span><br><span class="line">17 * G &#x3D; (15, 4)</span><br><span class="line">18 * G &#x3D; (None, None)</span><br><span class="line">19 * G &#x3D; (15, 13)</span><br><span class="line">20 * G &#x3D; (2, 10)</span><br><span class="line">21 * G &#x3D; (8, 3)</span><br><span class="line">22 * G &#x3D; (12, 1)</span><br><span class="line">23 * G &#x3D; (6, 6)</span><br><span class="line">24 * G &#x3D; (5, 8)</span><br></pre></td></tr></table></figure><p>​可见0 * G =无穷大。 同样清楚可见，EC群是循环的，EC群的序是n = 18，因为从k = 18开始，接下来的点重复第一个点：</p><ul><li><strong>18</strong> * <strong>G</strong> = <strong>0</strong> * <strong>G</strong> = <em>infinity</em></li><li><strong>19</strong> * <strong>G</strong> = <strong>1</strong> * <strong>G</strong> = {15, 13}</li><li><strong>20</strong> * <strong>G</strong> = <strong>2</strong> * <strong>G</strong> = {2, 10}</li><li><strong>21</strong> * <strong>G</strong> = <strong>3</strong> * <strong>G</strong> = {8, 3}</li><li>etc.</li></ul><p>​下图显示了通过将生成器点G乘以2、3、4，…，17生成的EC点：</p><p><img src="http://qiniu.gogocoding.cn/mweb/G.png" alt="G -c" /></p><p>​让我们对上面的示例进行一些修改，并将生成器点更改为G’= {5，9}。 这将显着改变输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tinyec.ec <span class="keyword">import</span> SubGroup, Curve</span><br><span class="line"></span><br><span class="line">field = SubGroup(p=<span class="number">17</span>, g=(<span class="number">5</span>, <span class="number">9</span>), n=<span class="number">18</span>, h=<span class="number">1</span>)</span><br><span class="line">curve = Curve(a=<span class="number">0</span>, b=<span class="number">7</span>, field=field, name=<span class="string">&#x27;p1707&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;curve:&#x27;</span>, curve)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">25</span>):</span><br><span class="line">    p = k * curve.g</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;k&#125;</span> * G&#x27; = (<span class="subst">&#123;p.x&#125;</span>, <span class="subst">&#123;p.y&#125;</span>)&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curve: &quot;p1707&quot; &#x3D;&gt; y^2 &#x3D; x^3 + 0x + 7 (mod 17)</span><br><span class="line">0 * G&#39; &#x3D; (None, None)</span><br><span class="line">1 * G&#39; &#x3D; (5, 9)</span><br><span class="line">2 * G&#39; &#x3D; (5, 8)</span><br><span class="line">3 * G&#39; &#x3D; (None, None)</span><br><span class="line">4 * G&#39; &#x3D; (5, 9)</span><br><span class="line">5 * G&#39; &#x3D; (5, 8)</span><br><span class="line">6 * G&#39; &#x3D; (None, None)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>​上面的示例再次确认，为加密设计椭圆曲线应该由密码学家而不是开发人员完成。 开发人员应依赖完善的加密标准和经过验证的加密库。</p><h3 id="11410-ec点的乘法-真实示例"><a class="markdownIt-Anchor" href="#11410-ec点的乘法-真实示例"></a> 11.4.10 EC点的乘法-真实示例</h3><p>​我们使用192位密码曲线secp192r1（192位，p = 6277101735386680763835789423207666416083908700390324961279）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tinyec <span class="keyword">import</span> registry</span><br><span class="line"></span><br><span class="line">curve = registry.get_curve(<span class="string">&#x27;secp192r1&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;curve:&#x27;</span>, curve)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">    p = k * curve.g</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;k&#125;</span> * G = (<span class="subst">&#123;p.x&#125;</span>, <span class="subst">&#123;p.y&#125;</span>)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Cofactor =&quot;</span>, curve.field.h)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Cyclic group order =&#x27;</span>, curve.field.n)</span><br><span class="line"></span><br><span class="line">nG = curve.field.n * curve.g</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n * G = (<span class="subst">&#123;nG.x&#125;</span>, <span class="subst">&#123;nG.y&#125;</span>)&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">curve: &quot;secp192r1&quot; &#x3D;&gt; y^2 &#x3D; x^3 + 6277101735386680763835789423207666416083908700390324961276x + 2455155546008943817740293915197451784769108058161191238065 (mod 6277101735386680763835789423207666416083908700390324961279)</span><br><span class="line">0 * G &#x3D; (None, None)</span><br><span class="line">1 * G &#x3D; (602046282375688656758213480587526111916698976636884684818, 174050332293622031404857552280219410364023488927386650641)</span><br><span class="line">2 * G &#x3D; (5369744403678710563432458361254544170966096384586764429448, 5429234379789071039750654906915254128254326554272718558123)</span><br><span class="line">3 * G &#x3D; (2915109630280678890720206779706963455590627465886103135194, 2946626711558792003980654088990112021985937607003425539581)</span><br><span class="line">4 * G &#x3D; (1305994880430903997305943738697779408316929565234787837114, 3981863977451150342116987835776121688410789618551673306674)</span><br><span class="line">5 * G &#x3D; (410283251116784874018993562136566870110676706936762660240, 1206654674899825246688205669651974202006189255452737318561)</span><br><span class="line">6 * G &#x3D; (4008504146453526025173196900303594155799995627910231899946, 3263759301305176906990806636587838100022690095020155627760)</span><br><span class="line">7 * G &#x3D; (3473339081378406123852871299395262476289672479707038350589, 2152713176906603604200842901176476029776544337891569565621)</span><br><span class="line">8 * G &#x3D; (1167950611014894512313033362696697441497340081390841490910, 4002177906111215127148483369584652296488769677804145538752)</span><br><span class="line">9 * G &#x3D; (3176317450453705650283775811228493626776489433309636475023, 44601893774669384766793803854980115179612118075017062201)</span><br><span class="line">Cofactor &#x3D; 1</span><br><span class="line">Cyclic group order &#x3D; 6277101735386680763835789423176059013767194773182842284081</span><br><span class="line">n * G &#x3D; (None, None)</span><br></pre></td></tr></table></figure><p>现在，让我们生成一个随机的私钥<code>privKey</code>（范围为[0 … n-1]的整数）及其对应的公钥<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>u</mi><mi>b</mi><mi>K</mi><mi>e</mi><mi>y</mi><mo>=</mo><mi>p</mi><mi>r</mi><mi>i</mi><mi>v</mi><mi>K</mi><mi>e</mi><mi>y</mi><mo>⋅</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">pubKey = privKey \cdot G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tinyec <span class="keyword">import</span> registry</span><br><span class="line"><span class="keyword">import</span> secrets</span><br><span class="line"></span><br><span class="line">curve = registry.get_curve(<span class="string">&#x27;secp192r1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">privKey = secrets.randbelow(curve.field.n)</span><br><span class="line">pubKey = privKey * curve.g</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;private key:&quot;</span>, privKey)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;public key:&quot;</span>, pubKey)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private key: 4225655318977962031264230130242180748818603147467615868902</span><br><span class="line">public key: (5396030834456770190396776530938374882273836179487834152291, 3422160588166914010077732710830109086004758012634997793937) on &quot;secp192r1&quot; &#x3D;&gt; y^2 &#x3D; x^3 + 6277101735386680763835789423207666416083908700390324961276x + 2455155546008943817740293915197451784769108058161191238065 (mod 6277101735386680763835789423207666416083908700390324961279)</span><br></pre></td></tr></table></figure><p>稍后，我们将使用此ECC密钥对（私钥，公钥）对数据进行加密，签名消息并验证签名。</p><h3 id="11411-ecc的椭圆曲线域参数"><a class="markdownIt-Anchor" href="#11411-ecc的椭圆曲线域参数"></a> 11.4.11 ECC的椭圆曲线域参数</h3><p>​ECC椭圆曲线由一组椭圆曲线域参数来描述，例如曲线方程参数，场参数和生成器点坐标。 这些参数在加密标准中指定，例如：</p><ul><li><a href="http://www.secg.org/sec2-v2.pdf">SEC 2: Recommended Elliptic Curve Domain Parameters</a></li><li><a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf">NIST FIPS PUB 186-4 Digital Signature Standard (DSS)</a></li><li><a href="https://tools.ietf.org/html/rfc5639">Brainpool ECC Standard (RFC-5639)</a></li></ul><p>​这些标准定义了一组命名曲线的参数，例如<code>secp256k1</code>，<code>P-521</code>和<code>brainpoolP512t1</code>。 这些密码标准中描述的有限域上的椭圆曲线已受到密码学家的充分研究和分析，并被认为具有一定的安全强度，这些标准中也对此进行了描述。</p><h4 id="114111-为ecc选择椭圆曲线"><a class="markdownIt-Anchor" href="#114111-为ecc选择椭圆曲线"></a> 11.4.11.1 为ECC选择椭圆曲线</h4><p>​使用ECC前，所有通信方都应就EC域参数（定义椭圆曲线的所有元素）达成一致。 强烈建议使用上述标准中至少256位的命名曲线，以确保其安全性。不要使用自己的椭圆曲线（带有非标准的域参数），除非您是经验丰富的密码专家并且非常清楚自己在做什么！ 许多曲线都有弱点，这使ECDLP问题变得不那么困难并损害了安全性。 如果您担心后门曲线，请使用“安全曲线”列表（ <a href="https://safecurves.cr.yp.to/">SafeCurves list</a>）中的标准安全曲线。</p><h4 id="114112-secp256k1曲线的示例"><a class="markdownIt-Anchor" href="#114112-secp256k1曲线的示例"></a> 11.4.11.2 “ secp256k1”曲线的示例</h4><p>​让我们对secp256k1曲线执行上述域参数。 让我们定义EC并计算某些私钥的公钥：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tinyec.ec <span class="keyword">import</span> SubGroup, Curve</span><br><span class="line"></span><br><span class="line"><span class="comment"># Domain parameters for the `secp256k1` curve</span></span><br><span class="line"><span class="comment"># (as defined in http://www.secg.org/sec2-v2.pdf)</span></span><br><span class="line">name = <span class="string">&#x27;secp256k1&#x27;</span></span><br><span class="line">p = <span class="number">0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f</span></span><br><span class="line">n = <span class="number">0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141</span></span><br><span class="line">a = <span class="number">0x0000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line">b = <span class="number">0x0000000000000000000000000000000000000000000000000000000000000007</span></span><br><span class="line">g = (<span class="number">0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798</span>,</span><br><span class="line">     <span class="number">0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8</span>)</span><br><span class="line">h = <span class="number">1</span></span><br><span class="line">curve = Curve(a, b, SubGroup(p, g, n, h), name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;curve:&#x27;</span>, curve)</span><br><span class="line"></span><br><span class="line">privKey = <span class="built_in">int</span>(<span class="string">&#x27;0x51897b64e85c3f714bba707e867914295a1377a7463a9dae8ea6a8b914246319&#x27;</span>, <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;privKey:&#x27;</span>, <span class="built_in">hex</span>(privKey)[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">pubKey = curve.g * privKey</span><br><span class="line">pubKeyCompressed = <span class="string">&#x27;0&#x27;</span> + <span class="built_in">str</span>(<span class="number">2</span> + pubKey.y % <span class="number">2</span>) + <span class="built_in">str</span>(<span class="built_in">hex</span>(pubKey.x)[<span class="number">2</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;pubKey:&#x27;</span>, pubKeyCompressed)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curve: &quot;secp256k1&quot; &#x3D;&gt; y^2 &#x3D; x^3 + 0x + 7 (mod 115792089237316195423570985008687907853269984665640564039457584007908834671663)</span><br><span class="line">privKey: 51897b64e85c3f714bba707e867914295a1377a7463a9dae8ea6a8b914246319</span><br><span class="line">pubKey: 02f54ba86dc1ccb5bed0224d23f01ed87e4a443c47fc690d7797a13d41d2340e1a</span><br></pre></td></tr></table></figure><p>公钥以标准格式进行压缩和编码（将y坐标编码为前缀02或03）。</p>]]></content>
      
      
      <categories>
          
          <category> CryptoGraphy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CryptoGraphy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10. The RSA Cryptosystem - Concepts</title>
      <link href="/2020/03/05/CryptoGraphy/10.%20The%20RSA%20Cryptosystem%20-%20Concepts/"/>
      <url>/2020/03/05/CryptoGraphy/10.%20The%20RSA%20Cryptosystem%20-%20Concepts/</url>
      
        <content type="html"><![CDATA[<p>​<a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)"><strong>RSA cryptosystem</strong></a> 是最早的公钥密码系统之一，基于模幂的数学理论（ <a href="https://en.wikipedia.org/wiki/Modular_exponentiation"><strong>modular exponentiations</strong></a>）以及RSA问题( <a href="https://en.wikipedia.org/wiki/RSA_problem"><strong>RSA problem</strong></a>)和紧密相关的整数分解问题( <a href="https://en.wikipedia.org/wiki/Integer_factorization"><strong>integer factorization problem</strong> (<strong>IFP</strong>)</a>)的计算难度。<strong>RSA</strong>算法以其作者的首字母命名（Rivest–Shamir–Adleman），在计算机密码学的早期被广泛使用。</p><p>​后来，随着<strong>ECC</strong>密码学的发展，由于ECC比RSA更高的安全性和ECC在相同安全级别下密钥长度更短，ECC在非对称密码系统中逐渐占主导地位。</p><p><strong>RSA算法提供：</strong></p><ul><li><strong>Key-pair generation</strong>：生成随机私钥（通常大小为1024-4096位）和相应的公钥。</li><li><strong>Encryption</strong>：使用公钥加密秘密消息（范围为[0 … key_length]的整数），然后使用私钥将其解密。</li><li><strong>Digital signatures</strong>：使用私钥签名消息，并使用公钥验证消息签名。</li><li><strong>Key exchange</strong>：安全地传输密钥，该密钥稍后用于加密通信。</li></ul><p>​RSA可以使用以下长度不同的密钥：1024、2048、3072、4096、8129、16384或更多位。 3072位及以上的密钥长度被认为是安全的。较长的密钥可提供更高的安全性，但会消耗更多的计算时间，因此在安全性和速度之间要进行权衡。太长的RSA密钥（例如50000位或65536位）对于实际使用而言可能太慢，密钥生成可能需要几分钟到几小时。</p><h2 id="101-rsa密钥生成"><a class="markdownIt-Anchor" href="#101-rsa密钥生成"></a> 10.1 RSA密钥生成</h2><p>​生成RSA公钥和私钥对涉及以下内容：</p><p>​使用数论中的一些非平凡数学计算，找到三个非常大的整数<strong>e</strong>，<strong>d</strong>和<strong>n</strong>，满足：</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msup><mi>m</mi><mi>e</mi></msup><msup><mo stretchy="false">)</mo><mi>d</mi></msup><mo>≡</mo><mi>m</mi><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(m^e)^d ≡ m(mod \quad n )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 对于m取值范围为[0 … n）；</li></ul><p>整数n被称为“<strong>模数</strong>”，它定义了RSA密钥长度。 它通常是非常大的素数（例如2048位）。</p><p>{n，e}是公用密钥。 它旨在与所有人共享。 数字e称为“公钥指数”。 通常为65537（0x010001）。</p><p>{n，d}是私钥。 它被设计为保密的。 从公钥{n，e}计算私钥实际上是不可行的。 数字d称为“私钥指数”（秘密指数）</p><h3 id="1011-rsa-public-key"><a class="markdownIt-Anchor" href="#1011-rsa-public-key"></a> 10.1.1 RSA Public Key</h3><p>2048位RSA公钥的示例（表示为2048位十六进制整数模数n和24位公钥指数e）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; 0xa709e2f84ac0e21eb0caa018cf7f697f774e96f8115fc2359e9cf60b1dd8d4048d974cdf8422bef6be3c162b04b916f7ea2133f0e3e4e0eee164859bd9c1e0ef0357c142f4f633b4add4aab86c8f8895cd33fbf4e024d9a3ad6be6267570b4a72d2c34354e0139e74ada665a16a2611490debb8e131a6cffc7ef25e74240803dd71a4fcd953c988111b0aa9bbc4c57024fc5e8c4462ad9049c7f1abed859c63455fa6d58b5cc34a3d3206ff74b9e96c336dbacf0cdd18ed0c66796ce00ab07f36b24cbe3342523fd8215a8e77f89e86a08db911f237459388dee642dae7cb2644a03e71ed5c6fa5077cf4090fafa556048b536b879a88f628698f0c7b420c4b7</span><br><span class="line">e &#x3D; 0x010001</span><br></pre></td></tr></table></figure><p>相同的RSA公钥，以传统的RSA格式<a href="https://en.wikipedia.org/wiki/PKCS_8">PKCS#8</a> <a href="https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail">PEM</a> <a href="https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One">ASN.1</a> 编码，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEApwni+ErA4h6wyqAYz39p</span><br><span class="line">f3dOlvgRX8I1npz2Cx3Y1ASNl0zfhCK+9r48FisEuRb36iEz8OPk4O7hZIWb2cHg</span><br><span class="line">7wNXwUL09jO0rdSquGyPiJXNM&#x2F;v04CTZo61r5iZ1cLSnLSw0NU4BOedK2mZaFqJh</span><br><span class="line">FJDeu44TGmz&#x2F;x+8l50JAgD3XGk&#x2F;NlTyYgRGwqpu8TFcCT8XoxEYq2QScfxq+2FnG</span><br><span class="line">NFX6bVi1zDSj0yBv90uelsM226zwzdGO0MZnls4AqwfzayTL4zQlI&#x2F;2CFajnf4no</span><br><span class="line">agjbkR8jdFk4je5kLa58smRKA+ce1cb6UHfPQJD6+lVgSLU2uHmoj2KGmPDHtCDE</span><br><span class="line">twIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure><h3 id="1012-rsa-private-key"><a class="markdownIt-Anchor" href="#1012-rsa-private-key"></a> 10.1.2 RSA Private Key</h3><p>与上述给定公钥相对应的2048位RSA私钥示例（表示为十六进制的2048位整数模数n和2048位秘密指数d）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; 0xa709e2f84ac0e21eb0caa018cf7f697f774e96f8115fc2359e9cf60b1dd8d4048d974cdf8422bef6be3c162b04b916f7ea2133f0e3e4e0eee164859bd9c1e0ef0357c142f4f633b4add4aab86c8f8895cd33fbf4e024d9a3ad6be6267570b4a72d2c34354e0139e74ada665a16a2611490debb8e131a6cffc7ef25e74240803dd71a4fcd953c988111b0aa9bbc4c57024fc5e8c4462ad9049c7f1abed859c63455fa6d58b5cc34a3d3206ff74b9e96c336dbacf0cdd18ed0c66796ce00ab07f36b24cbe3342523fd8215a8e77f89e86a08db911f237459388dee642dae7cb2644a03e71ed5c6fa5077cf4090fafa556048b536b879a88f628698f0c7b420c4b7</span><br><span class="line">d &#x3D; 0x10f22727e552e2c86ba06d7ed6de28326eef76d0128327cd64c5566368fdc1a9f740ad8dd221419a5550fc8c14b33fa9f058b9fa4044775aaf5c66a999a7da4d4fdb8141c25ee5294ea6a54331d045f25c9a5f7f47960acbae20fa27ab5669c80eaf235a1d0b1c22b8d750a191c0f0c9b3561aaa4934847101343920d84f24334d3af05fede0e355911c7db8b8de3bf435907c855c3d7eeede4f148df830b43dd360b43692239ac10e566f138fb4b30fb1af0603cfcf0cd8adf4349a0d0b93bf89804e7c2e24ca7615e51af66dccfdb71a1204e2107abbee4259f2cac917fafe3b029baf13c4dde7923c47ee3fec248390203a384b9eb773c154540c5196bce1</span><br></pre></td></tr></table></figure><p>相同的RSA私钥，以传统的RSA格式<a href="https://en.wikipedia.org/wiki/PKCS_8">PKCS#8</a> <a href="https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail">PEM</a> <a href="https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One">ASN.1</a> 编码，看上去更长一些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">MIIEowIBAAKCAQEApwni+ErA4h6wyqAYz39pf3dOlvgRX8I1npz2Cx3Y1ASNl0zf</span><br><span class="line">hCK+9r48FisEuRb36iEz8OPk4O7hZIWb2cHg7wNXwUL09jO0rdSquGyPiJXNM&#x2F;v0</span><br><span class="line">4CTZo61r5iZ1cLSnLSw0NU4BOedK2mZaFqJhFJDeu44TGmz&#x2F;x+8l50JAgD3XGk&#x2F;N</span><br><span class="line">lTyYgRGwqpu8TFcCT8XoxEYq2QScfxq+2FnGNFX6bVi1zDSj0yBv90uelsM226zw</span><br><span class="line">zdGO0MZnls4AqwfzayTL4zQlI&#x2F;2CFajnf4noagjbkR8jdFk4je5kLa58smRKA+ce</span><br><span class="line">1cb6UHfPQJD6+lVgSLU2uHmoj2KGmPDHtCDEtwIDAQABAoIBABDyJyflUuLIa6Bt</span><br><span class="line">ftbeKDJu73bQEoMnzWTFVmNo&#x2F;cGp90CtjdIhQZpVUPyMFLM&#x2F;qfBYufpARHdar1xm</span><br><span class="line">qZmn2k1P24FBwl7lKU6mpUMx0EXyXJpff0eWCsuuIPonq1ZpyA6vI1odCxwiuNdQ</span><br><span class="line">oZHA8MmzVhqqSTSEcQE0OSDYTyQzTTrwX+3g41WRHH24uN479DWQfIVcPX7u3k8U</span><br><span class="line">jfgwtD3TYLQ2kiOawQ5WbxOPtLMPsa8GA8&#x2F;PDNit9DSaDQuTv4mATnwuJMp2FeUa</span><br><span class="line">9m3M&#x2F;bcaEgTiEHq77kJZ8srJF&#x2F;r+OwKbrxPE3eeSPEfuP+wkg5AgOjhLnrdzwVRU</span><br><span class="line">DFGWvOECgYEAyIk7F0S0AGn2aryhw9CihDfimigCxEmtIO5q7mnItCfeQwYPsX72</span><br><span class="line">1fLpJNgfPc9DDfhAZ2hLSsBlAPLUOa0Cuny9PCBWVuxi1WjLVaeZCV2bF11mAgW2</span><br><span class="line">fjLkAXT34IX+HZl60VoetSWq9ibfkJHeCAPnh&#x2F;yjdB3Vs+2wxNkU8m8CgYEA1Tzm</span><br><span class="line">mjJq7M6f+zMo7DpRwFazGMmrLKFmHiGBY6sEg7EmoeH2CkAQePIGQw&#x2F;Rk16gWJR6</span><br><span class="line">DtUZ9666sjCH6&#x2F;79rx2xg+9AB76XTFFzIxOk9cm49cIosDMk4mogSfK0Zg8nVbyW</span><br><span class="line">5nEb&#x2F;&#x2F;9JCrZ18g4lD3IrT5VJoF4MhfdBUjAS1jkCgYB+RDIpv3+bNx0KLgWpFwgN</span><br><span class="line">Omb667B6SW2ya4x227KdBPFkwD9HYosnQZDdOxvIvmUZObPLqJan1aaDR2Krgi1S</span><br><span class="line">oNJCNpZGmwbMGvTU1Pd+Nys9NfjR0ykKIx7&#x2F;b9fXzman2ojDovvs0W&#x2F;pF6bzD3V&#x2F;</span><br><span class="line">FH5HWKLOrS5u4X3JJGqVDwKBgQCd953FwW&#x2F;gujld+EpqpdGGMTRAOrXqPC7QR3X5</span><br><span class="line">Beo0PPonlqOUeF07m9&#x2F;zsjZJfCJBPM0nS8sO54w7ESTAOYhpQBAPcx&#x2F;2HMUsrnIj</span><br><span class="line">HBxqUOQKe6l0zo6WhJQi8&#x2F;+cU8GKDEmlsUlS3iWYIA9EICJoTOW08R04BjQ00jS7</span><br><span class="line">1A1AUQKBgHlHrV&#x2F;6S&#x2F;4hjvMp+30hX5DpZviUDiwcGOGasmIYXAgwXepJUq0xN6aa</span><br><span class="line">lnT+ykLGSMMY&#x2F;LABQiNZALZQtwK35KTshnThK6zB4e9p8JUCVrFpssJ2NCrMY3SU</span><br><span class="line">qw87K1W6engeDrmunkJ&#x2F;PmvSDLYeGiYWmEKQbLQchTxx1IEddXkK</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure><h2 id="102-rsa加密数据"><a class="markdownIt-Anchor" href="#102-rsa加密数据"></a> 10.2 RSA加密数据</h2><p>通过以下转换，使用相应的RSA公钥{n，e}对消息进行加密：</p><ul><li>$ encryptedMsg = (msg)^e \quad mod \quad n$</li></ul><p>​此处的<strong>msg</strong>为[0 … n）范围内的数字， 加密前数据应编码为[0 … n）范围内的整数（<a href="https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding">EAOP</a>）。对于较大的文本，应使用混合加密（加密一个密钥，并使用对称加密来加密文本，请参阅 <a href="https://tools.ietf.org/html/rfc5990">RSA-KEM</a>）</p><p>​上面的操作无法逆转：没有有效的算法可以根据<strong>encryptedMsg</strong>，<strong>e</strong> 和 <strong>n</strong>（请参阅<a href="https://en.wikipedia.org/wiki/RSA_problem">the RSA problem</a>）来计算msg，这值在设计上都是可以公开的（非秘密的）。</p><h2 id="103-rsa解密数据"><a class="markdownIt-Anchor" href="#103-rsa解密数据"></a> 10.3 RSA解密数据</h2><p>通过以下转换，使用相应的RSA私钥{n，d}对加密的消息进行解密：</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>c</mi><mi>r</mi><mi>y</mi><mi>p</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>M</mi><mi>s</mi><mi>g</mi><mo>=</mo><mo stretchy="false">(</mo><mi>e</mi><mi>n</mi><mi>c</mi><mi>r</mi><mi>y</mi><mi>p</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>M</mi><mi>s</mi><mi>g</mi><msup><mo stretchy="false">)</mo><mi>d</mi></msup><mspace width="1em"/><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>n</mi></mrow><annotation encoding="application/x-tex">decryptedMsg = (encryptedMsg)^d \quad  mod \quad n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">n</span></span></span></span></li></ul><p>为什么这是正确的？ 回想一下，按照定义，RSA密钥对具有以下属性：</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msup><mi>m</mi><mi>e</mi></msup><msup><mo stretchy="false">)</mo><mi>d</mi></msup><mo>≡</mo><mi>m</mi><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(m^e)^d ≡ m(mod \quad n )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 对于m取值范围为[0 … n）；</li></ul><p>通过加密转换，我们可以知道</p><ul><li>$ encryptedMsg = (msg)^e \quad mod \quad n$</li></ul><p>因此：</p><ul><li>$ decryptedMsg = (encryptedMsg)^d \quad mod \quad n = ((msg)^e \quad mod \quad n)^d = ((msg)<sup>e)</sup>d \quad mod \quad n = (msg) \quad mod \quad n = msg $</li></ul><h2 id="104-rsa加密和解密-示例"><a class="markdownIt-Anchor" href="#104-rsa加密和解密-示例"></a> 10.4 RSA加密和解密-示例</h2><p>​根据上述公式，让我们研究一下RSA加密和解密的示例以及计算方法。 假设我们已经生成了RSA公钥-私钥对：</p><ul><li>modulus <strong>n</strong> = 143</li><li>public exponent <strong>e</strong> = 7</li><li>private exponent <strong>d</strong> = 103</li><li>public key = {<strong>n</strong>, <strong>e</strong>} = {143, 7}</li><li>private key = {<strong>n</strong>, <strong>d</strong>} = {143, 103}</li></ul><p>让我们加密一条秘密消息<strong>msg</strong> =83。只需遵循以下公式：</p><ul><li>$ encryptedMsg = msg^e \quad mod \quad n = 83^7 \quad mod \quad 143 = 27136050989627 \quad mod \quad 143 = 8 $</li></ul><p>现在，让我们将加密的消息解密回其原始值：</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>c</mi><mi>r</mi><mi>y</mi><mi>p</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>M</mi><mi>s</mi><mi>g</mi><mo>=</mo><mi>e</mi><mi>n</mi><mi>c</mi><mi>r</mi><mi>y</mi><mi>p</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>M</mi><mi>s</mi><msup><mi>g</mi><mi>d</mi></msup><mspace width="1em"/><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>n</mi><mo>=</mo><msup><mn>8</mn><mn>1</mn></msup><mn>03</mn><mspace width="1em"/><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mn>143</mn><mo>=</mo><mn>1042962419883256876169444192465601618458351817556959360325703910069443225478828393565899456512</mn><mspace width="1em"/><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mn>143</mn><mo>=</mo><mn>83</mn></mrow><annotation encoding="application/x-tex">decryptedMsg = encryptedMsg^d \quad mod \quad n = 8^103 \quad mod \quad 143 = 1042962419883256876169444192465601618458351817556959360325703910069443225478828393565899456512 \quad mod \quad 143 = 83</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mord">0</span><span class="mord">3</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">4</span><span class="mord">2</span><span class="mord">9</span><span class="mord">6</span><span class="mord">2</span><span class="mord">4</span><span class="mord">1</span><span class="mord">9</span><span class="mord">8</span><span class="mord">8</span><span class="mord">3</span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span><span class="mord">8</span><span class="mord">7</span><span class="mord">6</span><span class="mord">1</span><span class="mord">6</span><span class="mord">9</span><span class="mord">4</span><span class="mord">4</span><span class="mord">4</span><span class="mord">1</span><span class="mord">9</span><span class="mord">2</span><span class="mord">4</span><span class="mord">6</span><span class="mord">5</span><span class="mord">6</span><span class="mord">0</span><span class="mord">1</span><span class="mord">6</span><span class="mord">1</span><span class="mord">8</span><span class="mord">4</span><span class="mord">5</span><span class="mord">8</span><span class="mord">3</span><span class="mord">5</span><span class="mord">1</span><span class="mord">8</span><span class="mord">1</span><span class="mord">7</span><span class="mord">5</span><span class="mord">5</span><span class="mord">6</span><span class="mord">9</span><span class="mord">5</span><span class="mord">9</span><span class="mord">3</span><span class="mord">6</span><span class="mord">0</span><span class="mord">3</span><span class="mord">2</span><span class="mord">5</span><span class="mord">7</span><span class="mord">0</span><span class="mord">3</span><span class="mord">9</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">6</span><span class="mord">9</span><span class="mord">4</span><span class="mord">4</span><span class="mord">3</span><span class="mord">2</span><span class="mord">2</span><span class="mord">5</span><span class="mord">4</span><span class="mord">7</span><span class="mord">8</span><span class="mord">8</span><span class="mord">2</span><span class="mord">8</span><span class="mord">3</span><span class="mord">9</span><span class="mord">3</span><span class="mord">5</span><span class="mord">6</span><span class="mord">5</span><span class="mord">8</span><span class="mord">9</span><span class="mord">9</span><span class="mord">4</span><span class="mord">5</span><span class="mord">6</span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">3</span></span></span></span></li></ul><p>​RSA计算正确运行。 这是因为密钥对满足了上述RSA属性。在现实世界中，通常RSA模数n和私有指数d是3072位或4096位整数，公钥指数e是65537。</p><p><code>注</code>：<a href="http://doctrina.org/How-RSA-Works-With-Examples.html">http://doctrina.org/How-RSA-Works-With-Examples.html</a>.</p><p>​由于RSA加密是确定性的（没有随机成分），攻击者可以通过使用公钥加密可能的明文并测试它们是否等于密文，从而成功发起针对所选明文的攻击（<strong><a href="https://en.wikipedia.org/wiki/Chosen-plaintext_attack">chosen plaintext attack</a></strong>）。这可能不是问题，但是一个弱点，在开发人员选择加密方案时应予以考虑。像<strong>RSA-KEM</strong>这样的混合加密方案可以解决此漏洞，并允许对较长的文本进行加密。</p><h2 id="105-rsa加密解密-代码示例"><a class="markdownIt-Anchor" href="#105-rsa加密解密-代码示例"></a> 10.5  RSA加密/解密-代码示例</h2><p>​以下代码将使用<a href="https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding"><strong>RSA-OAEP</strong></a>填充方案生成随机的RSA密钥对，将加密短消息并将其解密回其原始形式。</p><p>​首先，安装pycryptodome软件包，这是一个强大的Python库，包含低级密码基元（哈希，MAC，密钥派生，对称和非对称密码，数字签名）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pycryptodome</span><br></pre></td></tr></table></figure><h3 id="1051-rsa-密钥生成"><a class="markdownIt-Anchor" href="#1051-rsa-密钥生成"></a> 10.5.1 RSA 密钥生成</h3><p>生成RSA密钥（1024位）并将其打印在控制台上（以十六进制数字和PKCS#8 PEM ASN.1格式显示）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> PKCS1_OAEP</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">keyPair = RSA.generate(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">pubKey = keyPair.publickey()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Public key:  (n=<span class="subst">&#123;<span class="built_in">hex</span>(pubKey.n)&#125;</span>, e=<span class="subst">&#123;<span class="built_in">hex</span>(pubKey.e)&#125;</span>)&quot;</span>)</span><br><span class="line">pubKeyPEM = pubKey.exportKey()</span><br><span class="line"><span class="built_in">print</span>(pubKeyPEM.decode(<span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Private key: (n=<span class="subst">&#123;<span class="built_in">hex</span>(pubKey.n)&#125;</span>, d=<span class="subst">&#123;<span class="built_in">hex</span>(keyPair.d)&#125;</span>)&quot;</span>)</span><br><span class="line">privKeyPEM = keyPair.exportKey()</span><br><span class="line"><span class="built_in">print</span>(privKeyPEM.decode(<span class="string">&#x27;ascii&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="1052-rsa-加密"><a class="markdownIt-Anchor" href="#1052-rsa-加密"></a> 10.5.2 RSA 加密</h3><p>使用带有RSA公钥的RSA-OAEP加密方案（带有PKCS＃1 OAEP填充的RSA）对消息进行加密：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">b&#x27;A message for encryption&#x27;</span></span><br><span class="line">encryptor = PKCS1_OAEP.new(pubKey)</span><br><span class="line">encrypted = encryptor.encrypt(msg)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Encrypted:&quot;</span>, binascii.hexlify(encrypted))</span><br></pre></td></tr></table></figure><h3 id="1053-rsa解密"><a class="markdownIt-Anchor" href="#1053-rsa解密"></a> 10.5.3 RSA解密</h3><p>使用带有RSA私钥的RSA-OAEP解密消息:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">decryptor = PKCS1_OAEP.new(keyPair)</span><br><span class="line">decrypted = decryptor.decrypt(encrypted)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Decrypted:&#x27;</span>, decrypted)</span><br></pre></td></tr></table></figure><h3 id="1054-输出"><a class="markdownIt-Anchor" href="#1054-输出"></a> 10.5.4 输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Public key: (n&#x3D;0x9a11485bccb9569410a848fb1afdf2a81b17c1fa9f9eb546fd1deb873b49b693a4edf20eb8362c085cd5b28ba109dbad2bd257a013f57f745402e245b0cc2d553c7b2b8dbba57ebda7f84cfb32b7d9c254f03dbd0188e4b8e40c47b64c1bd2572834b936ffc3da9953657ef8bee80c49c2c12933c8a34804a00eb4c81248e01f, e&#x3D;0x10001)</span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCaEUhbzLlWlBCoSPsa&#x2F;fKoGxfB</span><br><span class="line">+p+etUb9HeuHO0m2k6Tt8g64NiwIXNWyi6EJ260r0legE&#x2F;V&#x2F;dFQC4kWwzC1VPHsr</span><br><span class="line">jbulfr2n+Ez7MrfZwlTwPb0BiOS45AxHtkwb0lcoNLk2&#x2F;8PamVNlfvi+6AxJwsEp</span><br><span class="line">M8ijSASgDrTIEkjgHwIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br><span class="line">Private key: (n&#x3D;0x9a11485bccb9569410a848fb1afdf2a81b17c1fa9f9eb546fd1deb873b49b693a4edf20eb8362c085cd5b28ba109dbad2bd257a013f57f745402e245b0cc2d553c7b2b8dbba57ebda7f84cfb32b7d9c254f03dbd0188e4b8e40c47b64c1bd2572834b936ffc3da9953657ef8bee80c49c2c12933c8a34804a00eb4c81248e01f, d&#x3D;0x318ab12be3cf0d4a1b7921cead454fcc42ba070462639483394d6fb9529547827e9c8d23b294a8e01f8a1019da34e350f2307740e06a270bef1fe646e6ad213e31b528fdd5f5d03e633c07c44755ed622a629d79e822c095ebdf9cc80e517b5566dd3d3e5b16ec737987337a0e497fdba4b5ad97af41c1c3cdd87542a4637d81)</span><br><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">MIICXAIBAAKBgQCaEUhbzLlWlBCoSPsa&#x2F;fKoGxfB+p+etUb9HeuHO0m2k6Tt8g64</span><br><span class="line">NiwIXNWyi6EJ260r0legE&#x2F;V&#x2F;dFQC4kWwzC1VPHsrjbulfr2n+Ez7MrfZwlTwPb0B</span><br><span class="line">iOS45AxHtkwb0lcoNLk2&#x2F;8PamVNlfvi+6AxJwsEpM8ijSASgDrTIEkjgHwIDAQAB</span><br><span class="line">AoGAMYqxK+PPDUobeSHOrUVPzEK6BwRiY5SDOU1vuVKVR4J+nI0jspSo4B+KEBna</span><br><span class="line">NONQ8jB3QOBqJwvvH+ZG5q0hPjG1KP3V9dA+YzwHxEdV7WIqYp156CLAlevfnMgO</span><br><span class="line">UXtVZt09PlsW7HN5hzN6Dkl&#x2F;26S1rZevQcHDzdh1QqRjfYECQQDGDUIQXlOiAcGo</span><br><span class="line">d5YqAGpWe0wzJ0UypeqZcqS9MVe9OkjjopCkkYntifdN&#x2F;1oG7S&#x2F;1KUMtLoGHqntb</span><br><span class="line">c428zOO&#x2F;AkEAxyV0cmuJbFdfM0x2XhZ+ge&#x2F;7putIx76RHDOjBpM6VQXpLEFj54kB</span><br><span class="line">qGLAB7SXr7P4AFrEjfckJOp2YMI5BreboQJAb3EUZHt&#x2F;WeDdJLutzpKPQ3x7oykM</span><br><span class="line">wfQkbxXYZvD16u96BkT6WO&#x2F;gCb6hXs05zj32x1&#x2F;hgfHyRvGCGjKKZdtwpwJBAJ74</span><br><span class="line">y0g7h+wwoxJ0S1k4Y6yeQikxUVwCSBxXLCCnjr0ohsaJPJMrz2L30YtVInFkHOlL</span><br><span class="line">i&#x2F;Q4AWZmtDDxWkx+bYECQG8e6bGoszuX5xjvhEBslIws9+nMzMuYBR8HvhLo58B5</span><br><span class="line">N8dk3nIsLs3UncKLiiWubMAciU5jUxZoqWpRXXwECKE&#x3D;</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br><span class="line">Encrypted: b&#39;99b331c4e1c8f3fa227aacd57c85f38b7b7461574701b427758ee4f94b1e07d791ab70b55d672ff55dbe133ac0bea16fc23ea84636365f605a9b645e0861ee11d68a7550be8eb35e85a4bde6d73b0b956d000866425511c7920cdc8a3786a4f1cb1986a875373975e158d74e11ad751594de593a35de765fe329c0d3dfbbfedc&#39;</span><br><span class="line">Decrypted: b&#39;A message for encryption&#39;</span><br></pre></td></tr></table></figure><p><code>注</code>：</p><ol><li>如果运行上面的示例，您的输出将有所不同，因为它在每次执行时都会生成不同的随机RSA密钥对。</li><li>即使您使用相同的公共密钥多次加密同一条消息，您也会获得不同的输出。 这是因为OAEP填充算法会给填充注入一些随机性。</li><li>如果尝试加密较大的消息，则可能产生异常，因为1024位密钥限制了最大消息长度。</li></ol>]]></content>
      
      
      <categories>
          
          <category> CryptoGraphy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CryptoGraphy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09. Asymmetric Key Ciphers and Public-Key Cryptography - Overview</title>
      <link href="/2020/03/05/CryptoGraphy/09.%20Asymmetric%20Key%20Ciphers%20and%20Public-Key%20Cryptography%20-%20Overview/"/>
      <url>/2020/03/05/CryptoGraphy/09.%20Asymmetric%20Key%20Ciphers%20and%20Public-Key%20Cryptography%20-%20Overview/</url>
      
        <content type="html"><![CDATA[<p>​非对称密钥密码系统/公共密钥密码系统（ <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)"><strong>RSA</strong></a>, <a href="https://en.wikipedia.org/wiki/Elliptic-curve_cryptography"><strong>elliptic curve cryptography (ECC)</strong></a>, <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange"><strong>Diffie-Hellman</strong></a>, <a href="https://en.wikipedia.org/wiki/ElGamal_encryption"><strong>ElGamal</strong></a>, <a href="https://en.wikipedia.org/wiki/McEliece_cryptosystem"><strong>McEliece</strong></a>, <a href="https://en.wikipedia.org/wiki/NTRU"><strong>NTRU</strong></a> 等）使用一对数学上关联的密钥：公钥（加密密钥）和私钥（解密） 。</p><p>​非对称密钥系统提供<strong>密钥对生成</strong>（私钥和公钥），<strong>加密算法</strong>（非对称密钥和加密方案，例如<code>RSA-OAEP</code>和<code>ECIES</code>），<strong>数字签名算法</strong>（例如<code>DSA</code>，<code>ECDSA</code>和<code>EdDSA</code>）和<strong>密钥交换算法</strong>（例如 <code>DHKE</code>和<code>ECDH</code>）。</p><p>​由公钥加密的消息随后将由私钥解密。 由私钥签名的消息随后将由公钥验证。 公钥通常与所有人共享，而私钥则保密。 通过设计，从其对应的公钥计算私钥是不可行的。</p><h2 id="91-公钥密码系统-public-key-cryptosystems"><a class="markdownIt-Anchor" href="#91-公钥密码系统-public-key-cryptosystems"></a> 9.1 公钥密码系统 Public-Key Cryptosystems</h2><p>​众所周知的公钥密码系统是： <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)"><strong>RSA</strong></a>, <a href="https://en.wikipedia.org/wiki/Elliptic-curve_cryptography"><strong>ECC</strong></a>, <a href="https://en.wikipedia.org/wiki/ElGamal_encryption"><strong>ElGamal</strong></a>, <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange"><strong>DHKE</strong></a>, <a href="https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman"><strong>ECDH</strong></a>, <a href="https://en.wikipedia.org/wiki/Digital_Signature_Algorithm"><strong>DSA</strong></a>, <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm"><strong>ECDSA</strong></a>, <a href="https://en.wikipedia.org/wiki/EdDSA"><strong>EdDSA</strong></a>, <a href="https://en.wikipedia.org/wiki/Schnorr_signature"><strong>Schnorr signatures</strong></a>。<br />​<br />​<strong>不同的公共密钥密码系统可以提供以下一项或多项功能：</strong></p><ul><li><strong>Key-pair generation</strong>： 生成一对随机的私钥+公钥；</li><li><strong>Encryption</strong> / <strong>decryption</strong>：通过公钥加密数据，并通过私钥解密数据（通常使用混合加密方案）；</li><li><strong>Digital signatures</strong> (message authentication)：通过私钥对消息签名，并通过公钥验证签名；</li><li><strong>Key-exchange algorithms</strong>：通过不安全的通道在两方之间安全地交换加密密钥。</li></ul><p>​最重要和最常用的公钥密码系统是<strong>RSA</strong>和<strong>ECC</strong>。 椭圆曲线加密算法（ECC）是推荐的也是最可取的现代公钥密码系统，尤其是高度优化和安全的曲线（例如Curve25519和Curve448），因为它具有较小的密钥，较短的签名和更好的性能。</p><p>​<a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)"><strong>RSA public-key cryptosystem</strong></a> 基于<a href="https://en.wikipedia.org/wiki/Modular_exponentiation"><strong>modular exponentiation</strong></a>（模幂运算）、<a href="https://en.wikipedia.org/wiki/RSA_problem"><strong>integer factorization problem</strong></a> （整数分解问题）的数学概念。</p><p>​<a href="https://en.wikipedia.org/wiki/Elliptic-curve_cryptography"><strong>elliptic-curve cryptography (ECC) cryptosystem</strong></a>基于有限域上椭圆曲线的代数结构的数学理论和椭圆曲线离散对数问题（<a href="https://en.wikipedia.org/wiki/Elliptic-curve_cryptography#Rationale"><strong>elliptic curve discrete logarithm problem,  ECDLP</strong></a>。</p><h2 id="92-非对称加密方案"><a class="markdownIt-Anchor" href="#92-非对称加密方案"></a> 9.2 非对称加密方案</h2><p>​非对称加密比对称加密更复杂，不仅因为它使用公钥和私钥，而且因为非对称加密只能加密/解密较小的消息。在<code>RSA</code>系统中，应将输入消息转换为大整数（例如，使用OAEP填充），而在ECC中，基于椭圆曲线Diffie-Hellman密钥交换，不能直接对消息进行加密，而应使用更复杂的加密方案（ECDH）。稍后将对此进行详细说明。 此外，非对称密码比对称密码要慢得多（例如RSA加密要比AES慢1000倍）。</p><p>​为了克服上述限制并允许对任意大小的消息进行加密，现代加密技术使用了非对称加密方案（也称为公钥加密方案/非对称加密结构/混合加密方案），例如密钥封装机制（<strong>key encapsulation mechanisms</strong>，KEM）和集成加密方案， 结合了非对称加密和对称密钥密码。</p><p>​这是通过组合公钥加密和对称加密算法来加密大型文档或文件的方式：</p><p><img src="http://qiniu.gogocoding.cn/mweb/pkc.png" alt="pk -c" /></p><p>​在上图中，加密的对称密钥称为KEM块（公钥加密的密钥），加密的数据文件称为DEM块（对称加密的数据）。 加密的消息由这两个块组成（封装的密钥+封装的数据）。</p><p>​这是相应的解密过程（使用公钥和对称加密算法解密加密的大文档）：</p><p><img src="http://qiniu.gogocoding.cn/mweb/pkdc.png" alt="pkd -c" /></p><p>采用这种非对称加密方案的有： <a href="https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding"><strong>RSA-OAEP</strong></a>, <a href="https://tools.ietf.org/html/rfc5990#appendix-A"><strong>RSA-KEM</strong></a> and <a href="https://www.w3.org/TR/xmlsec-generic-hybrid/#sec-ecies-kem"><strong>ECIES-KEM</strong></a>。</p><h2 id="93-综合加密方案"><a class="markdownIt-Anchor" href="#93-综合加密方案"></a> 9.3 综合加密方案</h2><p>​<a href="https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme"><strong>Integrated encryption schemes (IES)</strong></a> 是现代的公共密钥加密方案，它结合了对称加密，非对称加密和密钥生成算法，以提供安全的基于公共密钥的加密（PKE）。在IES方案中，非对称加密算法（例如RSA或ECC）用于加密或封装对称密钥，稍后由对称加密（例如AES或ChaCha20）使用该对称密钥来加密输入消息。 一些EIS方案还提供消息身份验证。 使用EIS方案的有 <a href="https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme"><strong>DLIES</strong></a> (Discrete Logarithm Integrated Encryption Scheme) and <a href="https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme"><strong>ECIES</strong></a> (Elliptic Curve Integrated Encryption Scheme)</p><h2 id="94-秘钥封装机制-key-encapsulation-mechanisms-kems"><a class="markdownIt-Anchor" href="#94-秘钥封装机制-key-encapsulation-mechanisms-kems"></a> 9.4 秘钥封装机制（ Key Encapsulation Mechanisms, KEMs）</h2><p>​<a href="https://en.wikipedia.org/wiki/Key_encapsulation"><strong>key encapsulation mechanisms (KEM)</strong></a> 是用于加密和封装密钥（称为“临时对称密钥”）的非对称加密技术，该密钥用于使用对称加密算法对输入消息进行加密。KEM通过使用收件人的公钥对临时对称加密密钥进行加密，作为加密消息的一部分。 在密码学中，此过程称为<strong>密钥封装</strong>。</p><p>​基于KEM的混合加密方案的输出由<strong>KEM</strong>块（保存封装的加密对称密钥，或用于导出它的某些参数）和DEM块组成，DEM块保存封装的对称加密数据（加密参数 + 密文 + 可选的身份验证码）。</p><p>​密钥封装机制（KEM）在混合加密方案和集成加密方案中使用。其中在公钥加密系统中生成随机元素，并通过Hash从该随机元素中获得对称密钥。这种方法简化了将非对称和对称加密相结合的过程。使用现代密钥封装机制的方案有： <a href="https://tools.ietf.org/html/rfc5990"><strong>RSA-KEM</strong></a>, <a href="https://www.cosic.esat.kuleuven.be/nessie/reports/phase2/evalv2.pdf"><strong>ECIES-KEM</strong></a> and <a href="https://www.cryptrec.go.jp/cryptrec_03_spec_cypherlist_files/PDF/02_03e_jspec.pdf"><strong>PSEC-KEM</strong></a></p><p>​密钥封装（<strong>Key encapsulation</strong> ）不应与密钥包装（<strong>key wrapping</strong>）混淆：</p><ul><li><strong>Key encapsulation</strong> (KEM) ：指另一个密钥（对称或非对称）使用公钥加密。 它用于创建可证明安全的混合加密方案，例如： 通过给定的ECC公钥来加密AES密钥。</li><li><strong>Key wrapping</strong>：指另一密钥（可以是对称密钥或非对称密钥）的对称密钥加密。它用于加密，完整性保护和传输密钥。密钥包装可为专用数据（如加密密钥）提供隐私和完整性保护。有关详细信息，请参见<a href="https://tools.ietf.org/html/rfc3394.html">RFC 3394</a>。</li></ul><h2 id="95-数字签名"><a class="markdownIt-Anchor" href="#95-数字签名"></a> 9.5 数字签名</h2><p>​在密码学中，数字签名为数字文档提供<strong>消息身份验证</strong>，<strong>完整性</strong>和<strong>不可否认性</strong>。使用私钥进行消息签名，相应的公钥执行消息验证。消息签名在数学上保证了某些消息是由某些（保密的）私钥签名的，该私钥对应于特定的（非秘密）公钥。 消息签名后，无法修改消息和签名，因此可以提供这条被签名消息的身份验证和完整性。知道消息签名者公钥的任何人都可以验证签名。 签名后，签名作者无法否认签名行为。</p><p>​如今，数字签名已广泛用于签署数字合同，授权银行付款以及在公共区块链系统中签署交易以转移数字资产。</p><h2 id="96-密钥交换算法"><a class="markdownIt-Anchor" href="#96-密钥交换算法"></a> 9.6 密钥交换算法</h2><p>​<a href="https://en.wikipedia.org/wiki/Key_exchange"><strong>key exchange algorithms</strong></a> (<a href="https://en.wikipedia.org/wiki/Key-agreement_protocol"><strong>key agreement protocols</strong></a> / <strong>key negotiation schemes</strong>)允许在两方之间交换加密密钥，从而允许使用加密算法，在大多数情况下交换的是对称加密秘钥。例如，当笔记本电脑连接到家用WiFi路由器时，双方都同意使用会话密钥，该会话密钥用于对称地加密它们之间的网络流量。</p><p>​大多数密钥交换算法都基于公共密钥密码学和该系统背后的数学：离散对数，椭圆曲线或其他理论。<br />​<br />​像Diffie-Hellman（DHKE和ECDH）这样的匿名密钥交换不提供各方的身份验证，因此容易受到中间人攻击（ <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">man-in-the-middle attacks</a>），但可以防止流量拦截（嗅探）攻击（<a href="https://en.wikipedia.org/wiki/Sniffing_attack">traffic interception (sniffing) attacks</a>）。</p><p>​经过身份验证的密钥协议方案可以对参与密钥交换的各方的身份进行身份验证，从而通过使用数字签名 (例如， <a href="https://en.wikipedia.org/wiki/Public_key_certificate">PKI certificate</a>)、<a href="https://en.wikipedia.org/wiki/Password-authenticated_key_agreement"><strong>password-authenticated key agreemen</strong></a>或者其他方法来防止中间人攻击</p>]]></content>
      
      
      <categories>
          
          <category> CryptoGraphy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CryptoGraphy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08. Popular Symmetric Encryption Algorithms</title>
      <link href="/2020/03/05/CryptoGraphy/08.%20Popular%20Symmetric%20Encryption%20Algorithms/"/>
      <url>/2020/03/05/CryptoGraphy/08.%20Popular%20Symmetric%20Encryption%20Algorithms/</url>
      
        <content type="html"><![CDATA[<p>​对称密钥加密算法（如AES）是由数学家和密码学家设计的，其思想是在没有加密密钥的情况下解密密文应该是不可行的。一些流行的对称加密算法有：<code>AES</code>，<code>ChaCha20</code>，<code>CAST</code>，<code>Twofish</code>，<code>IDEA</code>，<code>Serpent</code>，<code>RC5</code>，<code>RC6</code>，<code>Camellia</code>和<code>ARIA</code>。 所有这些算法在正确配置和使用时都被认为是安全的。</p><h2 id="81-aes"><a class="markdownIt-Anchor" href="#81-aes"></a> 8.1 AES</h2><p>​<a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard"><strong>AES</strong></a>  (<strong>A</strong>dvanced <strong>E</strong>ncryption <strong>S</strong>tandard,又被称为 <strong>Rijndael</strong>)是现代IT行业中最流行和使用最广泛的对称加密算法。这是因为事实证明，AES是高度安全，快速且标准化良好的，并且几乎在所有平台上都得到很好的支持。</p><p>​当今，大多数Internet网站在内部使用AES来提供https：//内容，这是TLS（Transport Layer Security，安全传输层协议）和SSL（Secure Sockets Layer，安全套接层）标准的一部分，用于安全主机在Web上承载通信。</p><p>​由于AES在Internet安全通信中的广泛使用，现代CPU硬件在微处理器级别实现AES指令，以加快AES加密和解密的速度。</p><h3 id="81-aes算法参数"><a class="markdownIt-Anchor" href="#81-aes算法参数"></a> 8.1 AES算法参数</h3><p>​AES算法可以使用不同的密钥长度进行操作，但是块大小始终为128位。 对于大多数应用程序，128位AES加密（AES-128）足够了，但是对于更高的加密级别，建议使用AES-256（256位密钥长度）。</p><p>​像任何其他分组加密一样，AES可以使用几种操作模式（CBC，ECB，CTR等）之一来允许对任意长度的数据进行加密。 对于一般情况和加密区块链钱包，推荐的模式是“ CTR”。</p><p>​大多数操作模式都需要初始向量（IV）。当使用计数器模式（CTR），例如AES-128-CTR或AES-256-CTR时，首先应生成非机密的随机salt（IV）并与加密的密文输出保存在一起。 IV的大小始终与块的大小相同，即128位（16字节）。</p><p>​AES加密与CTR块模式和随机IV相结合，使得每次加密相同的输入数据时，加密算法都会生成不同的加密密文。这样可以确保没有人可以构造字典来逆转加密的密文。</p><h3 id="812-集成消息验证码mac"><a class="markdownIt-Anchor" href="#812-集成消息验证码mac"></a> 8.1.2 集成消息验证码（MAC）</h3><p>​AES算法可以使用MAC（消息验证码）来检查密码的有效性，例如 <code>HMAC(text, key)</code>。MAC代码通常集成在算法的输出中( <a href="https://en.wikipedia.org/wiki/Authenticated_encryption#Approaches_to_authenticated_encryption"><strong>integrated encryption</strong></a>)。它是根据输入消息以及加密密钥计算得出的。从计算出的MAC中，不可能暴露输入消息或密钥，因此MAC本身不用保密。一些分组加密模式（例如AES-GCM）将消息身份验证集成到所获得的密文中，作为其工作的一部分，因此您无需显式添加MAC。<br />​<br />​<strong>通常，MAC的计算和使用方式如下：</strong></p><ol><li>加密之前，MAC计算为mac = HMAC-SHA256(input_msg, key)；</li><li>输入数据被加密，密文与随机盐 salt（IV）和MAC一起存储。</li><li>解密后，将再次计算MAC，并将其与与加密消息一起存储的MAC进行比较。</li></ol><ul><li>如果MAC相同，则解密成功：正确的密文+解密密钥+算法设置（IV，块模式，填充算法）。</li><li>如果MAC不同，则解密不成功：错误的密钥/密码或密文破解，错误的MAC或不同的算法设置（IV，块模式，填充等）</li></ul><p>​可以使用多种集成加密方法来计算和验证MAC（<a href="https://en.wikipedia.org/wiki/Authenticated_encryption#Approaches_to_authenticated_encryption">approaches to integrated encryption</a>）： <strong>Encrypt-then-MAC</strong>, <strong>Encrypt-and-MAC</strong>, <strong>MAC-then-Encrypt</strong>.</p><h2 id="82-aes加密过程"><a class="markdownIt-Anchor" href="#82-aes加密过程"></a> 8.2 AES加密过程</h2><p>​整个AES加密过程（基于密码的身份验证加密）如下所示：</p><ol><li><p>选择算法参数（例如AES，128位，CTR模式+ Scrypt + Scrypt参数+ MAC算法）。 这些参数可以硬编码在AES算法实现源代码中，或者可以指定为AES加密和解密的输入。 始终使用相同的参数进行加密和解密。</p></li><li><p>加密密钥是使用密钥导出函数（KDF）从加密密码中导出的，例如 Scrypt（根据特定参数）：<img src="http://qiniu.gogocoding.cn/mweb/P2K.png" alt="P2K -c" /></p></li><li><p>AES加密方案将<strong>输入消息msg</strong> + <strong>加密密钥</strong>作为输入。 它产生<strong>密文</strong> + <strong>随机生成的IV</strong>（128位salt）+ <strong>MAC码</strong> 作为输出：<br /><img src="http://qiniu.gogocoding.cn/mweb/AES.png" alt="AES -c" /></p><ul><li><p>对于自带身份验证的加密（例如AES-GCM），在AES加密过程中已经自动计算了MAC；</p></li><li><p>如果加密方案本身没有身份验证（例如AER-CTR），则AES加密过程不会自动计算出MAC码，应另外进行计算。 可以使用加密密钥（或其某种转换）和某些MAC函数（例如HMAC-SHA-256）从输入消息中计算出MAC代码：<img src="http://qiniu.gogocoding.cn/mweb/HMAC.png" alt="HMA -c" /></p></li><li><p>密文是通过AES加密算法计算的。 它首先生成一个随机盐salt（IV），并使用它通过AES和加密密钥来加密输入消息：<img src="http://qiniu.gogocoding.cn/mweb/AES-IV.png" alt="AES-IV -c" /></p></li></ul></li><li><p>最后，生成加密的输出。 它包含密文+ IV + MAC。 （可选）它还保存算法设置。</p></li></ol><h2 id="83-aes解密过程"><a class="markdownIt-Anchor" href="#83-aes解密过程"></a> 8.3 AES解密过程</h2><p>整个AES解密过程（基于密码的身份验证解密）如下所示：</p><ol><li>初始化与加密过程相同的AES算法参数以进行解密。</li><li>使用解密密钥和加密消息中的IV，使用AES算法对密文进行解密。 输出是原始消息：<img src="http://qiniu.gogocoding.cn/mweb/AES%20decrypt.png" alt="AES decrypt -c" /><ul><li>对于经过身份验证的加密（如AES-GCM），将在解密过程中验证集成的MAC代码。</li><li>如果未经身份验证的加密（如AES-CTR），应如下面的步骤中所述，另外计算和验证MAC代码，</li></ul></li><li>计算原始消息的HMAC：<img src="http://qiniu.gogocoding.cn/mweb/AES%20HMAC.png" alt="AES HMA -c" /></li><li>将加密MAC（加密之前输入消息的MAC）与解密MAC（解密后恢复的原始消息的MAC）进行比较：<img src="http://qiniu.gogocoding.cn/mweb/Hmac%20compare.png" alt="Hmac compare -c" /><ul><li>如果MAC码相同，则解密正确，并获得原始消息；</li><li>如果MAC代码不同，则解密失败，并且原始消息不是获得的消息。 发生这种情况的原因可能有很多，最有可能是“密码错误”。 其他原因：密文不正确，IV错误，算法设置错误，KDF函数或KDF参数错误等。</li></ul></li></ol><h2 id="84-aes加密解密aes-ctraes-gcm示例"><a class="markdownIt-Anchor" href="#84-aes加密解密aes-ctraes-gcm示例"></a> 8.4 AES加密/解密（AES-CTR，AES-GCM）示例</h2><p>​下面的第一个示例将说明一个简单的基于密码的AES加密（PBKDF2 + AES-CTR），没有消息身份验证。 第二个示例将添加消息身份验证（使用AES-GCM模式），并且使用密钥生成函数 (AES-256-GCM + Scrypt)。</p><p>​首先，安装实现AES对称密钥加密算法的Python库Pyaes：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyaes</span><br></pre></td></tr></table></figure><p>​接下来，安装实现PBKDF2密钥生成算法的Python库pbkdf2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pbkdf2</span><br></pre></td></tr></table></figure><p>​<strong>KDF</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyaes, pbkdf2, binascii, os, secrets</span><br><span class="line"></span><br><span class="line"><span class="comment"># Derive a 256-bit AES encryption key from the password</span></span><br><span class="line">password = <span class="string">&quot;s3cr3t*c0d3&quot;</span></span><br><span class="line">passwordSalt = os.urandom(<span class="number">16</span>)</span><br><span class="line">key = pbkdf2.PBKDF2(password, passwordSalt).read(<span class="number">32</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;AES encryption key:&#x27;</span>, binascii.hexlify(key))</span><br></pre></td></tr></table></figure><p>​上面的代码使用PBKDF2密钥派生算法从密码<code>s3cr3t*c0d3</code>派生256位密钥，它使用随机密码派生盐（salt 128位），该salt应与密文一起存储在输出中。</p><p>​<strong>AES Encryption (CTR Block Mode)</strong></p><p>​接下来，为AES CTR 生成一个随机的256位初始向量（IV），然后执行AES-256-CTR加密：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Encrypt the plaintext with the given key:</span></span><br><span class="line"><span class="comment">#   ciphertext = AES-256-CTR-Encrypt(plaintext, key, iv)</span></span><br><span class="line">iv = secrets.randbits(<span class="number">256</span>)</span><br><span class="line">plaintext = <span class="string">&quot;Text for encryption&quot;</span></span><br><span class="line">aes = pyaes.AESModeOfOperationCTR(key, pyaes.Counter(iv))</span><br><span class="line">ciphertext = aes.encrypt(plaintext)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Encrypted:&#x27;</span>, binascii.hexlify(ciphertext))</span><br></pre></td></tr></table></figure><p>​密文由38个十六进制数字（19个字节，152位）组成。 这是输入数据<code>Text for encryption</code>的大小；</p><p>​请注意，在AES-CTR加密之后，初始向量（IV）应该与密文一起存储，因为没有它，解密将是不可能的。 应该为每种AES加密（非硬编码）随机生成IV，以提高安全性。</p><p>​还要注意，如果您多次使用相同的加密密钥对相同的纯文本进行加密，由于IV中的随机性，每次输出都会有所不同。 这是预期的结果，会增加安全性，例如：抵抗字典攻击。</p><p>​<strong>AES Decryption (CTR Block Mode)</strong></p><p>​现在，让我们看看如何使用AES-CTR-256算法解密密文。 输入内容包括密文+加密密钥+ CTR计数器的IV。 输出为原始明文。 代码很简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Decrypt the ciphertext with the given key:</span></span><br><span class="line"><span class="comment">#   plaintext = AES-256-CTR-Decrypt(ciphertext, key, iv)</span></span><br><span class="line">aes = pyaes.AESModeOfOperationCTR(key, pyaes.Counter(iv))</span><br><span class="line">decrypted = aes.decrypt(ciphertext)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Decrypted:&#x27;</span>, decrypted)</span><br></pre></td></tr></table></figure><p>​请注意，应再次初始化AES对象，因为CTR密码块模式算法会保持内部状态随时间变化。</p><p>​还请注意，以上代码无法检测到错误的密钥，错误的密文或错误的IV。 如果您使用不正确的密钥来解密密文，则会得到错误的不可读文本。 下面的代码清楚地显示了这一点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key = os.urandom(<span class="number">32</span>)   <span class="comment"># random decryption key</span></span><br><span class="line">aes = pyaes.AESModeOfOperationCTR(key, pyaes.Counter(iv))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Wrongly decrypted:&#x27;</span>, aes.decrypt(ciphertext))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wrongly decrypted: b&#39;\xe6!\n\x9a\xa9\x15\x12\xd9\xcb\x9cS\x86\xcc\xe1\x1d\x1a\x8blw&#39;</span><br></pre></td></tr></table></figure><h3 id="841-aes-256-gcm示例"><a class="markdownIt-Anchor" href="#841-aes-256-gcm示例"></a> 8.4.1 AES-256-GCM示例</h3><p>​现在我们给出一个完整的示例，说明如何使用<code>AES-256-GCM</code>对称加密。 我们将为AES使用另一个Python库，称为<code>pycryptodome</code>，该库支持AES-256-GCM构造：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pycryptodome</span><br></pre></td></tr></table></figure><p>接下来，该示例生成一个随机加密密钥，并使用它来加密文本消息，然后将其解密回原始的纯文本消息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> binascii, os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt_AES_GCM</span>(<span class="params">msg, secretKey</span>):</span></span><br><span class="line">    aesCipher = AES.new(secretKey, AES.MODE_GCM)</span><br><span class="line">    ciphertext, authTag = aesCipher.encrypt_and_digest(msg)</span><br><span class="line">    <span class="keyword">return</span> (ciphertext, aesCipher.nonce, authTag)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt_AES_GCM</span>(<span class="params">encryptedMsg, secretKey</span>):</span></span><br><span class="line">    (ciphertext, nonce, authTag) = encryptedMsg</span><br><span class="line">    aesCipher = AES.new(secretKey, AES.MODE_GCM, nonce)</span><br><span class="line">    plaintext = aesCipher.decrypt_and_verify(ciphertext, authTag)</span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br><span class="line"></span><br><span class="line">secretKey = os.urandom(<span class="number">32</span>)  <span class="comment"># 256-bit random encryption key</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Encryption key:&quot;</span>, binascii.hexlify(secretKey))</span><br><span class="line"></span><br><span class="line">msg = <span class="string">b&#x27;Message for AES-256-GCM + Scrypt encryption&#x27;</span></span><br><span class="line">encryptedMsg = encrypt_AES_GCM(msg, secretKey)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;encryptedMsg&quot;</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;ciphertext&#x27;</span>: binascii.hexlify(encryptedMsg[<span class="number">0</span>]),</span><br><span class="line">    <span class="string">&#x27;aesIV&#x27;</span>: binascii.hexlify(encryptedMsg[<span class="number">1</span>]),</span><br><span class="line">    <span class="string">&#x27;authTag&#x27;</span>: binascii.hexlify(encryptedMsg[<span class="number">2</span>])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">decryptedMsg = decrypt_AES_GCM(encryptedMsg, secretKey)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;decryptedMsg&quot;</span>, decryptedMsg)</span><br></pre></td></tr></table></figure><p>​AES-GCM加密将消息<strong>msg</strong> + 加密密钥<strong>secretKey</strong>作为输入，并产生一组值：{ <strong>ciphertext</strong> + <strong>nonce</strong> + <strong>authTag</strong> }。</p><ul><li><strong>ciphertext</strong>是加密后的消息；</li><li><strong>nonce</strong>是用于GCM构建的随机生成的初始向量（IV）；</li><li><strong>authTag</strong>是加密过程中计算出的消息身份验证代码（MAC）；</li></ul><p>​上面代码中生成的加密密钥大小为256位（32字节），并将AES-GCM配置为AES-256-GCM。 如果将密钥大小更改为128位或192位，则应分别使用AES-128-GCM或AES-192-GCM。</p><h3 id="842-aes-256-gcm-scrypt-示例"><a class="markdownIt-Anchor" href="#842-aes-256-gcm-scrypt-示例"></a> 8.4.2 AES-256-GCM + Scrypt 示例</h3><p>​现在让我们给出一个更复杂的示例：我们将使用经过身份验证的加密结构AES-256-GCM，并结合Scrypt密钥推导：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> scrypt, os, binascii</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt_AES_GCM</span>(<span class="params">msg, password</span>):</span></span><br><span class="line">    kdfSalt = os.urandom(<span class="number">16</span>)</span><br><span class="line">    secretKey = scrypt.<span class="built_in">hash</span>(password, kdfSalt, N=<span class="number">16384</span>, r=<span class="number">8</span>, p=<span class="number">1</span>, buflen=<span class="number">32</span>)</span><br><span class="line">    aesCipher = AES.new(secretKey, AES.MODE_GCM)</span><br><span class="line">    ciphertext, authTag = aesCipher.encrypt_and_digest(msg)</span><br><span class="line">    <span class="keyword">return</span> (kdfSalt, ciphertext, aesCipher.nonce, authTag)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt_AES_GCM</span>(<span class="params">encryptedMsg, password</span>):</span></span><br><span class="line">    (kdfSalt, ciphertext, nonce, authTag) = encryptedMsg</span><br><span class="line">    secretKey = scrypt.<span class="built_in">hash</span>(password, kdfSalt, N=<span class="number">16384</span>, r=<span class="number">8</span>, p=<span class="number">1</span>, buflen=<span class="number">32</span>)</span><br><span class="line">    aesCipher = AES.new(secretKey, AES.MODE_GCM, nonce)</span><br><span class="line">    plaintext = aesCipher.decrypt_and_verify(ciphertext, authTag)</span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br><span class="line"></span><br><span class="line">msg = <span class="string">b&#x27;Message for AES-256-GCM + Scrypt encryption&#x27;</span></span><br><span class="line">password = <span class="string">b&#x27;s3kr3tp4ssw0rd&#x27;</span></span><br><span class="line">encryptedMsg = encrypt_AES_GCM(msg, password)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;encryptedMsg&quot;</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;kdfSalt&#x27;</span>: binascii.hexlify(encryptedMsg[<span class="number">0</span>]),</span><br><span class="line">    <span class="string">&#x27;ciphertext&#x27;</span>: binascii.hexlify(encryptedMsg[<span class="number">1</span>]),</span><br><span class="line">    <span class="string">&#x27;aesIV&#x27;</span>: binascii.hexlify(encryptedMsg[<span class="number">2</span>]),</span><br><span class="line">    <span class="string">&#x27;authTag&#x27;</span>: binascii.hexlify(encryptedMsg[<span class="number">3</span>])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">decryptedMsg = decrypt_AES_GCM(encryptedMsg, password)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;decryptedMsg&quot;</span>, decryptedMsg)</span><br></pre></td></tr></table></figure><p>上面的代码使用给定的文本密码生成秘钥，使用AES-256-GCM给文本消息进行加密。</p><ul><li>在加密过程中，使用Scrypt KDF函数（具有一些固定参数）根据密码生成密钥。 用于密钥派生的随机生成的KDF盐与加密的消息一起存储，解密时将会使用到。 然后，使用私钥对输入消息进行AES加密，并且输出由<strong>ciphertext</strong>（密文）+ <strong>IV</strong>（随机数）+ <strong>authTag</strong>（HMAC）+ <strong>salt</strong>（KDF salt） 组成的结果 。</li><li>在解密过程中，Scrypt密钥派生（具有相同的参数）用于根据加密密码以及KDF盐（salt在加密过程中随机生成）得出相同的解密密钥。 然后，使用密钥，IV（随机数）和authTag（HMAC）对密文进行AES解密。 如果成功，则结果是解密的原始明文。 如果发生错误，则身份验证标签将无法对解密过程进行身份验证，并且将引发异常。</li></ul><h3 id="843-以太坊utc-json钱包加密aes-scrypt-mac"><a class="markdownIt-Anchor" href="#843-以太坊utc-json钱包加密aes-scrypt-mac"></a> 8.4.3 以太坊UTC / JSON钱包加密（AES + Scrypt + MAC）</h3><p>​演示AES密码在实际中的应用，我们将看一个真实的例子：以太坊区块链的标准加密钱包文件格式。我们将看到AES-128-CTR密码如何与Scrypt和MAC结合使用，以通过基于文本的密码安全地实现经过身份验证的对称密钥加密。</p><h3 id="844-ethereum-utc-json-wallets"><a class="markdownIt-Anchor" href="#844-ethereum-utc-json-wallets"></a> 8.4.4 Ethereum UTC / JSON Wallets</h3><p>​在公共区块链网络（如比特币和以太坊）中，区块链资产持有人的私钥存储在称为加密钱包的特殊密钥库中。 通常，这些加密钱包是本地硬盘上的文件，由密码加密。<br />​在以太坊中，区块链加密货币钱包以一种特殊的加密格式在内部存储，称为&quot;<a href="https://theethereum.wiki/w/index.php/Accounts,_Addresses,_Public_And_Private_Keys,_And_Tokens#UTC_JSON_Keystore_File"><strong>UTC / JSON Wallet (Keystore File)</strong></a>&quot; 或者 “<a href="https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition"><strong>Web3 Secret Storage Definition</strong></a>”。这是<a href="https://geth.ethereum.org/"><strong>geth</strong></a> 和 <a href="https://www.parity.io/ethereum"><strong>Parity</strong></a> （两个主要的以太坊协议的实现）、<a href="https://www.myetherwallet.com/"><strong>MyEtherWallet</strong></a>（流行的在线客户端以太坊钱包）、<a href="https://metamask.io/"><strong>MetaMask</strong></a> （广泛用于浏览器内的以太坊钱包）、<a href="https://github.com/ethers-io/ethers.js/"><strong>ethers.js</strong></a> and <a href="https://github.com/Nethereum/Nethereum"><strong>Nethereum</strong></a> libraries以及许多其他与以太坊相关的技术和工具中使用的钱包文件格式。</p><p>​以太坊 <strong>UTC / JSON keystores</strong>将加密的私钥保存为JSON文本文档，指定加密的数据，加密算法及其参数。</p><h3 id="845-utc-json-keystores-示例"><a class="markdownIt-Anchor" href="#845-utc-json-keystores-示例"></a> 8.4.5 UTC / JSON keystores 示例</h3><p>​UTC / JSON keystores文件，其中包含受密码保护的256位私钥。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;07a9f767-93c5-4842-9afd-b3b083659f04&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;address&quot;</span>: <span class="string">&quot;aef8cad64d29fcc4ed07629b9e896ebc3160a8d0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Crypto&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;ciphertext&quot;</span>: <span class="string">&quot;99d0e66c67941a08690e48222a58843ef2481e110969325db7ff5284cd3d3093&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;cipherparams&quot;</span>: &#123; <span class="attr">&quot;iv&quot;</span>: <span class="string">&quot;7d7fabf8dee2e77f0d7e3ff3b965fc23&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">&quot;cipher&quot;</span>: <span class="string">&quot;aes-128-ctr&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;kdf&quot;</span>: <span class="string">&quot;scrypt&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;kdfparams&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;dklen&quot;</span>: <span class="number">32</span>,</span><br><span class="line">      <span class="attr">&quot;salt&quot;</span>: <span class="string">&quot;85ad073989d461c72358ccaea3551f7ecb8e672503cb05c2ee80cfb6b922f4d4&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;n&quot;</span>: <span class="number">8192</span>,</span><br><span class="line">      <span class="attr">&quot;r&quot;</span>: <span class="number">8</span>,</span><br><span class="line">      <span class="attr">&quot;p&quot;</span>: <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">    <span class="attr">&quot;mac&quot;</span>: <span class="string">&quot;06dcf1cc4bffe1616fafe94a2a7087fd79df444756bb17c93af588c3ab02a913&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面的JSON文档是经过身份验证的对称加密的经典示例。通常，UTC / JSON keystores存储区包含以下数据：</p><ul><li><strong>cipher</strong>：对称 <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES 算法</a>的名称 <strong>AES-128-CTR</strong>;</li><li><strong>cipherparams</strong>：上述 <em>cipher</em> 算法需要的参数;</li><li><strong>ciphertext</strong>：你的以太坊私钥使用上述 <em>cipher</em> 算法进行加密;</li><li><strong>kdf</strong>：<a href="https://en.wikipedia.org/wiki/Key_derivation_function">密钥生成函数</a>，用于让你用密码加密 keystore 文件;</li><li><strong>kdfparams</strong>：上述 kdf 算法需要的参数;</li><li><strong>Mac</strong>：用于验证密码的<a href="https://en.wikipedia.org/wiki/Message_authentication_code">代码</a>。</li><li>其他元数据：钱包格式version（版本），钱包唯一id（uuid）和由该钱包控制的address(区块链地址)。</li></ul><p><code>注</code>：<a href="https://ethfans.org/posts/what-is-an-ethereum-keystore-file">什么是以太坊私钥储存（Keystore）文件</a></p>]]></content>
      
      
      <categories>
          
          <category> CryptoGraphy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CryptoGraphy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07. Symmetric Key Ciphers - Overview</title>
      <link href="/2020/03/05/CryptoGraphy/07.%20Symmetric%20Key%20Ciphers%20-%20Overview/"/>
      <url>/2020/03/05/CryptoGraphy/07.%20Symmetric%20Key%20Ciphers%20-%20Overview/</url>
      
        <content type="html"><![CDATA[<p>​对称加密（例如<code>AES</code>，<code>ChaCha20</code>，<code>RC6</code>，<code>Twofish</code>，<code>CAST</code>等）使用相同的密钥（或密码）来加密和解密数据。 它们通常与其他算法结合使用以形成对称加密方案（例如<code>ChaCha20-Poly1305</code>和<code>AES-128-GCM</code>和<code>AES-256-CTR-HMAC-SHA256</code>）。对称密钥密码具有抗量子性，这意味着功能强大的量子计算机也无法破坏其安全性（使用足够长的密钥长度时）。</p><p>​对称加密可以加密以固定大小的块形式出现的数据（<strong>block ciphers</strong>，块密码）或以字节序列形式出现的数据（<strong>stream ciphers</strong>，流密码）。可以通过某些构造将<strong>block ciphers</strong>转换为<strong>stream ciphers</strong>，这种构造称为“<strong>block cipher modes</strong> of operation”</p><h2 id="71-分组密码流密码分组模式和填充-block-ciphers-stream-ciphers-block-modes-and-padding"><a class="markdownIt-Anchor" href="#71-分组密码流密码分组模式和填充-block-ciphers-stream-ciphers-block-modes-and-padding"></a> 7.1 分组密码，流密码，分组模式和填充( Block Ciphers, Stream Ciphers, Block Modes and Padding)</h2><p>​在密码学中，块密码（例如AES）被设计为对固定大小（例如128位）的数据块进行加密。输入块的大小通常与加密输出块的大小相同，而密钥长度可能不同。</p><p>​<a href="https://en.wikipedia.org/wiki/Stream_cipher"><strong>Stream ciphers</strong></a> 则更加灵活：它们旨在加密任意大小的数据（例如PDF文档），这些数据有时可能以流的形式出现（字节或帧的序列，例如视频流）。大多数流行的对称密钥加密算法都是块密码，但是密码学家提出了几种方案，可以将块密码转换为流密码并加密任意大小的数据。这些方案被称为“<a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation"><strong>block cipher modes of operation</strong></a>”，并且适用于大多数分组密码，例如<strong>AES</strong>，<strong>RC6</strong>，<strong>Camellia</strong>，<strong>Serpent</strong>等。</p><p>​当对称密码与分组操作模式结合使用时，所获得的密码结构由密码名称，分组模式和密钥大小表示。 例如：</p><ul><li><strong>AES-256-GCM</strong> ： the AES cipher with a 256-bit encryption key and GCM block mode</li><li><strong>AES-128-CTR</strong> - the AES cipher with a 128-bit encryption key and CTR block mode</li><li><strong>Serpent-128-CBC</strong> - the Serpent cipher with 128-bit encryption key and CBC block mode</li></ul><h2 id="72-分组加密模式cbc-ctr-gcm"><a class="markdownIt-Anchor" href="#72-分组加密模式cbc-ctr-gcm"></a> 7.2 分组加密模式(CBC, CTR, GCM，…)</h2><p>​分组加密模式（ <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation"><strong>block cipher modes</strong></a>，例如CBC，CFB，OFB，CTR，EAX，CCM和GCM）背后的主要思想是重复应用密码的单块加密/解密，以安全地加密/解密大于块的数据量。</p><p>​某些块模式（例如CBC）要求将输入拆分为块，并使用填充算法（例如添加特殊的填充字符）将最终块填充为固定的块大小。其他块模式（例如CTR，CFB，OFB，CCM，EAX和GCM）根本不需要填充，因为它们在每一步都执行明文部分与内部密码状态之间的XOR（异或）。</p><p>​基本上，对大型输入数据进行加密的工作方式如下：初始化加密算法状态（使用加密密钥+随机盐salt），然后对数据的第一部分（例如块或块的一部分）进行加密，然后加密状态 转换（使用加密密钥和其他参数），然后对下一部分进行加密，然后再次转换加密状态，然后对下一部分进行加密，依此类推，直到处理完所有输入数据为止。 解密的工作方式非常相似。</p><p>​为了正确使用它们，开发人员应该了解“<a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation"><strong>block cipher modes of operation</strong></a>”：</p><ul><li>常用的安全块模式是CBC（密码块链接），CTR（计数器）和GCM（Galois /计数器模式），它们需要一个随机的（不可预测的）初始化向量（IV），开始时也称为随机数（<strong>nonce</strong>）或盐（<strong>salt</strong>）。</li><li>“<a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Counter_(CTR)"><strong>Counter (CTR)</strong></a>”块模式是一个不错的选择。在大多数情况下，具有强大的安全性和并行处理能力，可以任意的输入数据长度（无填充）。 它不提供身份验证和完整性，仅提供加密。</li><li><a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode"><strong>GCM</strong></a> (Galois/Counter Mode) 块模式利用了CTR模式的所有优点，并添加了消息身份验证（生成密码消息身份验证标签）。 GCM是在对称密码中实现身份验证加密的快速而有效的方法，在一般情况下，强烈建议使用GCM。</li><li>CBC模式以固定大小的块工作。 因此，在将输入数据拆分为块之后，应使用填充算法（<a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Padding"><strong>padding algorithm</strong></a> ）使最后一个块具有相同的长度。 大多数应用程序使用PKCS7填充方案（<a href="https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS#5_and_PKCS#7"><strong>PKCS7 padding scheme</strong></a> ）或ANSI X.923（<a href="https://en.wikipedia.org/wiki/Padding_(cryptography)#ANSI_X.923"><strong>ANSI X.923</strong></a>）。 在某些情况下，CBC阻止模式可能容易受到“填充预言”攻击（<a href="https://en.wikipedia.org/wiki/Padding_oracle_attack"><strong>&quot;padding oracle&quot; attack</strong></a>,），因此最好避免使用CBC模式。</li><li>众所周知的不安全块模式是<a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_(ECB)"><strong>ECB</strong></a> （电子密码本），它会将相等的输入块加密为相等的输出块（不提供密码扩散，<a href="https://en.wikipedia.org/wiki/Confusion_and_diffusion">cryptographic diffusion</a>）。 <strong>不要使用它！</strong> 它可能会破坏整个加密系统。</li><li>诸如CBC，CTR和GCM模式之类的大多数块均支持“随机访问”解密（例如，在视频播放器中的任意时间偏移处搜索，播放加密的视频流）。</li></ul><p><strong>CTR (Counter) Block Mode</strong></p><p>​下图说明了如何在CTR块操作模式下使用块密码对明文的部分（块）进行逐个加密：</p><p><img src="http://qiniu.gogocoding.cn/mweb/CTR.png" alt="CT" /></p><p>​对于CTR模式下的每个块，将基于初始向量（IV，有时称为“ nonce”）+当前计数器（01，02，03，…）+ 加密密钥和输入来生成新的不可预测的密钥流块与当前密钥流块 XOR合并以生成输出块。在CTR模式下，输入数据的最后部分可以短于密码块大小，因此不需要填充。 输入数据（加密之前）和输出数据（加密之后）具有相同的长度。</p><p><strong>GCM (Galois/Counter) Block Mode</strong></p><p>下图直观地说明了GCM块模式（Galois /Counter）的工作方式：</p><p><img src="http://qiniu.gogocoding.cn/mweb/GCM.png" alt="GC" /></p><p>GCM模式使用一个计数器，该计数器针对每个块增加，并在每个已处理的块之后计算消息身份验证标签（MAC代码）。 最终的身份验证标签是从最后一个块计算得出的。 与所有计数器模式一样，GCM用作流密码，因此对于每个加密的流，在开始时使用不同的IV至关重要。</p><p><code>注</code>：请注意，GCM，CTR和其他分组模式会显示原始消息的长度， 因为明文消息的长度与密文长度相同。 如果您想避免暴露原始的纯文本长度，可以在加密之前向纯文本添加一些随机字节，并在解密之后将其删除。</p><h2 id="73-初始化向量iv"><a class="markdownIt-Anchor" href="#73-初始化向量iv"></a> 7.3 初始化向量（IV）</h2><p>​对每个加密消息使用随机且不可预测的初始化向量 （Initialization Vector，IV)。 用相同的对称密钥和相同的IV加密多个消息是一个常见的错误。 这为大多数块模式引入了各种被攻击的可能。 IV的大小应与密码块的大小相同，例如 AES，Serpent和Camellia的128位。</p><p>对于GCM模式，IV可能不是秘密且不可预测的，但对于每个消息，IV应当不同。</p><h2 id="74-认证加密"><a class="markdownIt-Anchor" href="#74-认证加密"></a> 7.4 认证加密</h2><p>​在密码学中，“认证加密”（<a href="https://en.wikipedia.org/wiki/Authenticated_encryption"><strong>authenticated encryption</strong></a>，AE）的概念是指加密数据的同时计算用于提供消息真实性和完整性的认证码（认证标签/ MAC）的方案。 如果使用认证的加密方案，则在解密时将知道解密是否成功（即解密密钥/密码是否正确以及加密数据是否被篡改）。</p><p>​身份验证加密（AE）与带有关联数据的认证加密（<a href="https://en.wikipedia.org/wiki/Authenticated_encryption#Authenticated_encryption_with_associated_data_(AEAD)"><strong>authenticated encryption with associated data</strong></a>，<strong>AEAD</strong>）类似概念有关，AEAD是AE的一种更安全的变体。AEAD会将关联数据（AD）绑定到密文以及应该出现的上下文中，以便可以检测到并拒绝将有效密文“剪切并粘贴”到其他上下文中的尝试。AEAD用于加密和未加密的数据一起使用的场景（例如在加密的网络协议中），并确保整个数据流都经过身份验证和完整性保护。</p><p>​一些加密方案（如ChaCha20-Poly1305和AES-GCM）提供集成的身份验证加密（AEAD），而另一些方案（如AES-CBC和AES-CTR）则需要额外添加身份验证（如果需要）。</p>]]></content>
      
      
      <categories>
          
          <category> CryptoGraphy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CryptoGraphy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06. Symmetric and Asymmetric Encryption - Overview</title>
      <link href="/2020/03/05/CryptoGraphy/06.%20Symmetric%20and%20Asymmetric%20Encryption%20-%20Overview/"/>
      <url>/2020/03/05/CryptoGraphy/06.%20Symmetric%20and%20Asymmetric%20Encryption%20-%20Overview/</url>
      
        <content type="html"><![CDATA[<p>​在密码学中，广泛使用了两种主要的加密方案：<code>对称加密</code>（使用单个密钥来加密和解密数据）和<code>非对称加密</code>（使用公钥加密，并且使用公钥对应的私钥进行解密），下面详细解释这些基本的加密概念。<br />​</p><h2 id="61-对称加密-概念和算法"><a class="markdownIt-Anchor" href="#61-对称加密-概念和算法"></a> 6.1 对称加密-概念和算法</h2><p>对称加密方案使用相同的密钥（或密码）来加密数据并将数据解密回其原始形式：</p><p><img src="http://qiniu.gogocoding.cn/mweb/symmetric%20key%20ciphers.png" alt="symmetric key ciphers -c400" /></p><p>对称加密通常将几种密码算法组合成一个对称加密方案，例如 <code>AES-256-CTR-HMAC-SHA256</code>。</p><p><strong>加密方案可能包括：</strong></p><ol><li>password to <strong>key derivation</strong> algorithm</li><li><strong>symmetric cipher</strong> algorithm</li><li><strong>cipher block mode</strong> algorithm</li><li><strong>message authentication</strong> (MAC) algorithm</li></ol><p>这意味着上面显示的图是简化的，并不完全代表该过程。</p><h3 id="611-秘钥"><a class="markdownIt-Anchor" href="#611-秘钥"></a> 6.1.1 秘钥</h3><p>​用于加密（加密）和解密（解密）数据的秘密密钥通常大小为128、192或256位，有时被称为“加密密钥”或“共享密钥”，因为发送方和接收方都应该知道它。大多数应用程序都使用 <a href="https://wizardforcel.gitbooks.io/practical-cryptography-for-developers-book/content/part-1-blockchain-networks-concepts/blockchain-cryptography/blockchain-cryptography-overview/hmac-and-key-derivation.html"><strong>password-to-key-derivation</strong></a>生方案从某些密码中提取秘钥，因为用户相比二进制数据更容易记住密码。此外，消息身份验证通常与加密结合在一起以提供完整性和真实性验证。</p><p><strong>256-bit secret key</strong> ：<code>02c324648931b89e3e8a0fc42c96e8e3be2e42812986573a40d46563bceaf75110</code></p><p><strong>base58</strong>:<code>pbPRqYDxnKZfs8j4KKiqYmx6nzipAjTJf1oCD1WKgy99</code></p><p><strong>base64</strong>:<code>AsMkZIkxuJ4+ig/ELJbo474uQoEphlc6QNRlY7zq91EQ</code></p><p>在许多系统中（例如，公共区块链，PGP，OpenSSL等），密钥被编码为base58或base64，以便于用较短的字符串表示。</p><h3 id="612-现代对称加密算法"><a class="markdownIt-Anchor" href="#612-现代对称加密算法"></a> 6.1.2 现代对称加密算法</h3><p>​在现代密码学中，广泛使用的对称加密算法有：</p><ol><li><a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard"><strong>AES</strong></a> (AES-128, AES-192, AES-256)；</li><li><a href="https://legacy.gitbook.com/book/svetlin-nakov/practical-blockchain-for-developers-the-big-book/edit#"><strong>ChaCha20</strong></a>；</li><li><a href="https://en.wikipedia.org/wiki/Twofish"><strong>Twofish</strong></a>；</li><li><a href="https://en.wikipedia.org/wiki/International_Data_Encryption_Algorithm"><strong>IDEA</strong></a>；</li><li><a href="https://en.wikipedia.org/wiki/Serpent_(cipher)"><strong>Serpent</strong></a>；</li><li><a href="https://en.wikipedia.org/wiki/Camellia_(cipher)"><strong>Camelia</strong></a>；</li></ol><p>​它们中的大多数是块密码（通过固定大小的块（例如128位）加密数据），而另一些是流密码（将字节作为数据流逐字节加密）。</p><p><code>注</code>：在线对称加密工具 <a href="https://aesencryption.net/"><strong>https://aesencryption.net</strong></a>.</p><h2 id="62-公钥密码-概念"><a class="markdownIt-Anchor" href="#62-公钥密码-概念"></a> 6.2 公钥密码-概念</h2><p>​在介绍非对称密钥加密方案和算法之前，我们应该首先了解公钥加密（<a href="https://en.wikipedia.org/wiki/Public-key_cryptography"><strong>public key cryptography</strong></a>，非对称秘钥）的概念。 他使用不同的密钥来加密和解密数据（或签名和验证消息）。密钥总是以公钥+私钥对的形式出现。非对称密码处理使用公钥/私钥对消息进行加密和解密，对消息签名，验证签名和安全地交换<code>密钥</code>。</p><p>​流行的公钥密码系统（非对称密码算法），例如<strong>RSA</strong>（Rivest–Shamir–Adleman），<strong>ECC</strong>（椭圆曲线加密），<strong>Diffie-Hellman</strong>，<strong>ECDH</strong>，<strong>ECDSA</strong>和<strong>EdDSA</strong>，已广泛用于现代密码学中。</p><p>​非对称加密方案使用一对与密码相关的公钥和私钥对数据进行加密解密，其中公钥用于加密，私钥用于解密。</p><p><img src="http://qiniu.gogocoding.cn/mweb/public%20key%20encryption%20and%20decryption.png" alt="public key encryption and decryption -c400" /></p><p>​作为加密结果而获得的加密数据被称为“<strong>密文</strong>”。 密文是一个二进制序列，人类不可读，并且设计上如果没有对应私钥就无法解密。</p><p><img src="http://qiniu.gogocoding.cn/mweb/asymmetric%20encryption.png" alt="asymmetric encryption -c400" /></p><blockquote><p>​注意，上面显示的图是高度简化的，并不完全代表非对称加密/解密过程。通常，非对称加密系统只能加密有限长度的消息，并且比对称加密慢。 为了加密较长的文件（例如PDF文档），通常使用<strong>公钥加密方案</strong>（也称为混合加密方案），该方案结合了对称和非对称加密，如下所示：</p></blockquote><ol><li>为了进行加密，将生成随机对称密钥<code>sk</code>，消息将由<code>sk</code>对称加密，然后使用收件人的公钥对<code>sk</code>进行非对称加密。</li><li>对于解密，首先使用接收者的私钥对<code>sk</code>密钥进行非对称解密，然后后续的密文使用<code>sk</code>对称秘钥对密文进行解密。</li></ol><p>以上过程称为 <a href="https://en.wikipedia.org/wiki/Key_encapsulation"><strong>key encapsulation mechanism (KEM)</strong></a>。</p><p>​公钥加密也可以在相反的情况下工作：通过私钥加密数据，并通过公钥解密数据。 因此，某人可以证明自己是某些私钥的所有者。一些数字签名方案使用此方法。</p><h2 id="63-签名不对称签名验证"><a class="markdownIt-Anchor" href="#63-签名不对称签名验证"></a> 6.3 签名：不对称签名/验证</h2><p>​<a href="https://en.wikipedia.org/wiki/Digital_signature"><strong>digital signatures</strong></a>：由私钥签名的消息（数字签名）随后将由相应的公钥验证。</p><p><img src="http://qiniu.gogocoding.cn/mweb/signatures.png" alt="signatures -c400" /></p><p>​签名后不能更改已签名的消息。 消息签名证明某些消息（例如区块链交易）是由某些私钥的所有者创建的。 数字签名提供消息身份验证，消息完整性和不可否认性。<br />​<br />​数字签名在金融行业中广泛用于授权付款。 在操作系统中，操作系统组件和设备驱动程序通常经过数字签名，以避免在操作系统中注入不安全的代码，木马或病毒。在区块链系统中，交易通常由某些区块链地址的所有者签名。</p><h2 id="64-密钥对"><a class="markdownIt-Anchor" href="#64-密钥对"></a> 6.4 密钥对</h2><p>​公钥加密使用一对密钥：<code>公钥</code> + <code>私钥</code>。 这些密钥在数学上是相关的，并且要成对使用。</p><p>在某些公钥密码系统（例如，椭圆曲线密码-ECC）中，可以根据私钥来计算出公钥。 而在其他密码系统（如RSA）中，公钥和私钥是一起生成的，但不能直接相互计算。</p><h3 id="641-私钥"><a class="markdownIt-Anchor" href="#641-私钥"></a> 6.4.1 私钥</h3><p>​消息加密和签名是通过私钥完成的。私钥始终像密码一样由其所有者保密。在服务器基础结构中，私钥通常驻留在加密和受保护的密钥库中。在区块链系统中，私钥通常位于特定的软件或硬件应用程序中，称为“加密钱包”，这些应用安全地存储一组私钥。</p><h3 id="642-公钥"><a class="markdownIt-Anchor" href="#642-公钥"></a> 6.4.2 公钥</h3><p>​消息解密和签名验证由公用密钥完成。 公钥在设计上就是可以被共享的信息（不是秘密）。 从相应的公钥来计算私钥在数学上是不可行的。在许多系统中，公钥被封装在数字证书中，该证书将某些身份（例如人或互联网域名）绑定到公钥上。在区块链系统中，公钥通常作为区块链交易的一部分发布，以帮助识别谁签署了这个交易。在PGP和SSH之类的系统中，公钥是从服务器下载一次的（在手动用户验证之后），并且会被记住以备将来使用。在大多数区块链系统中，区块链地址是从公钥派生的（通过哈希和其他转换），因此，如果您拥有某人的公钥，则假定您也拥有他的区块链地址。</p><p>​某个公钥可以连接到某个人或组织，也可以匿名使用。除非您有其他证明，否则您永远不会知道谁是与某些公钥相对应的私钥的所有者，证明如 数字证书 <a href="https://en.wikipedia.org/wiki/Public_key_certificate"><strong>digital certificate</strong></a>。</p><h3 id="643-流行的非对称加密系统"><a class="markdownIt-Anchor" href="#643-流行的非对称加密系统"></a> 6.4.3 流行的非对称加密系统</h3><p>​众所周知的非对称加密系统有：<a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)"><strong>RSA</strong></a>, <a href="https://en.wikipedia.org/wiki/Elliptic-curve_cryptography"><strong>ECC</strong></a> and <a href="https://en.wikipedia.org/wiki/ElGamal_encryption"><strong>ElGamal</strong></a>。</p><p><a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">**RSA **</a> ：基于模幂的数学运算（数字乘以模的幂）和一些其他假设以及整数分解问题的计算难度。</p><p><a href="https://en.wikipedia.org/wiki/Elliptic-curve_cryptography"><strong>elliptic-curve cryptography (ECC) public-key cryptosystem</strong></a> ：基于有限域上椭圆曲线的代数结构的数学模型和椭圆曲线离散对数问题（ <a href="https://en.wikipedia.org/wiki/Elliptic-curve_cryptography#Rationale"><strong>elliptic curve discrete logarithm problem ，ECDLP</strong></a>）的难度。</p><p><code>注</code>：一般情况下建议使用<code>ECC</code>，<code>ECC</code>使用的密钥，密文和签名比RSA小。 在数学上已证明3072位<code>RSA</code>密钥具有与256位<code>ECC</code>密钥相似的加密强度。 <code>ECC</code>中的密钥效率显著高于<code>RSA</code>。由于上述原因，大多数区块链网络（如比特币和以太坊）都使用基于椭圆曲线的密码学（ECC）来保护交易。注意，<code>RSA</code>和<code>ECC</code>密码系统都不是量子安全的，这意味着，如果某人拥有足够强大的量子计算机，则他将能够在短短几秒钟内从给定的公钥中导出私钥。</p>]]></content>
      
      
      <categories>
          
          <category> CryptoGraphy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CryptoGraphy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05 Key Exchange / Key Establishment Schemes</title>
      <link href="/2020/03/05/CryptoGraphy/05%20Key%20Exchange%20-%20Key%20Establishment%20Schemes/"/>
      <url>/2020/03/05/CryptoGraphy/05%20Key%20Exchange%20-%20Key%20Establishment%20Schemes/</url>
      
        <content type="html"><![CDATA[<p><a href="http://cacr.uwaterloo.ca/hac/about/chap12.pdf"><strong>key establishment</strong></a> (<strong>key exchange</strong>, <strong>key negotiation</strong>) 是一个过程或协议，从而使共享的秘密可供两方随后的加密通信使用，建立技术可以是秘钥协商或秘钥传输方案。</p><ul><li>在秘钥协商方案中，双方都参与共享密钥的协商。 秘钥协商方案典型的有<strong>Diffie-Hellman</strong>(DHKE) 和<strong>Elliptic-Curve Diffie-Hellman</strong> (ECDH)。</li><li>在秘钥传输方案中，只有一方参与生产共享密钥，另一方从他获取密钥。密钥传输方案通常通过公钥密码术实现，例如 在<strong>RSA</strong>密钥交换中，客户端使用其私钥对随机会话密钥进行加密，然后将其发送到服务器，在服务器中使用客户端的公钥对其进行解密。</li></ul><p>​通过设计密钥交换方案，可以安全地在两方之间交换加密密钥，而其他任何人都无法获得密钥的副本。通常，在加密对话的开始时（例如在TLS握手阶段），各方首先协商要在对话中使用的共享秘钥。</p><p>每当便携式计算机连接到Wi-Fi网络或Web浏览器通过https：//协议打开网站时，都会执行密钥协商（密钥建立）方案。密钥协商可以基于匿名密钥交换协议（例如<code>DHKE</code>），密码或预共享密钥（PSK），数字证书或许多元素的组合。 一些通信协议仅建立一次共享密钥，而另一些则随时间不断更改密钥。</p><p>​身份验证密钥交换（AKE）是密钥交换协议中会话密钥的交换，该协议还对有关各方的身份进行身份验证（例如通过密码，公钥或数字证书）。例如，如果您连接到受密码保护的WiFi网络，则使用经过身份验证的密钥协商协议，在大多数情况下，将使用经过密码认证的密钥协商（PAKE）。 如果您连接到公共WiFi网络，则会执行匿名密钥协议。</p><h2 id="51-diffiehellman-key-exchange-dhke"><a class="markdownIt-Anchor" href="#51-diffiehellman-key-exchange-dhke"></a> 5.1 Diffie–Hellman Key Exchange (DHKE)</h2><p>​<a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange"><strong>Diffie–Hellman Key Exchange</strong></a> (DHKE) 是一种通过公共（不安全的）渠道也可以安全地交换加密密钥的方案。交换的密钥稍后用于加密通信（例如，使用诸如AES之类的对称密码）。Diffie-Hellman（DH）方法是匿名密钥协商方案：它允许彼此不具有先验知识的两方通过不安全的信道共同建立共享密钥。DHKE方法可以抵抗<a href="https://en.wikipedia.org/wiki/Sniffing_attack"><strong>sniffing attacks</strong></a> (数据拦截)，但它容易受到<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack"><strong>man-in-the-middle attacks</strong></a> （中间人攻击，攻击者会偷偷中继并可能改变双方的通信）。</p><p>​Diffie-Hellman密钥交换协议可以使用离散对数（经典 <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange"><strong>DHKE</strong></a>算法）或椭圆曲线加密算法（ <a href="https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman"><strong>ECDH</strong></a>算法）实现。</p><h2 id="52-通过混合颜色mixing-colors进行密钥交换"><a class="markdownIt-Anchor" href="#52-通过混合颜色mixing-colors进行密钥交换"></a> 5.2 通过混合颜色(Mixing Colors)进行密钥交换</h2><p><code>​Diffie-Hellman</code>密钥交换协议与“<strong>通过混合颜色交换密钥</strong>”的概念非常相似，该协议具有良好的视觉表示，从而简化了对其的理解。这就是为什么我们将首先解释如何通过颜色混合来交换秘密颜色的原因。</p><p>​颜色混合密钥交换方案的设计假定，如果我们有两种不同颜色的液体，我们可以轻松地混合颜色并获得新的颜色，但是反向操作几乎是不可能的：无法将混合后的颜色分离回其原始颜色。</p><p><strong>具体操作步骤如下：</strong></p><ol><li><strong>Alice</strong>和<strong>Bob</strong>使用一个无需保密的任意起始（共享）颜色（例如黄色）。</li><li><strong>Alice</strong>和<strong>Bob</strong>分别选择自己保留的私密颜色（例如红色和海绿色）。</li><li><strong>Alice</strong>和<strong>Bob</strong>将他们的私密颜色与共享的颜色混合在一起， 获得用于公开交换的混合色（在我们的示例中为橙色和浅天蓝色）。</li></ol><p><img src="http://qiniu.gogocoding.cn/mweb/Mixed%20color%201.png" alt="Mixed color 1 -c400" /></p><p><strong>后续步骤如下：</strong></p><ol><li><strong>Alice</strong>和<strong>Bob</strong>公开交换他们的两种混合色。</li><li>最后，<strong>Alice</strong>和<strong>Bob</strong>将他们从对方那里得到的颜色与自己的私密颜色混合在一起，得到最终的颜色。</li></ol><p><img src="http://qiniu.gogocoding.cn/mweb/Mixed%20color%202.png" alt="Mixed color 2-c400" /></p><p>​Diffie-Hellman密钥交换协议基于相似的概念，但是使用 <a href="https://en.wikipedia.org/wiki/Discrete_logarithm"><strong>discrete logarithms</strong></a>（离散对数）和 <a href="https://en.wikipedia.org/wiki/Modular_exponentiation"><strong>modular exponentiations</strong></a> （模化指数）而不是颜色混合。</p><h2 id="53-dhke背后的数学理论"><a class="markdownIt-Anchor" href="#53-dhke背后的数学理论"></a> 5.3 DHKE背后的数学理论</h2><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msup><mi>g</mi><mi>a</mi></msup><msup><mo stretchy="false">)</mo><mi>b</mi></msup><mspace width="1em"/><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>p</mi><mo>=</mo><mo stretchy="false">(</mo><msup><mi>g</mi><mi>b</mi></msup><msup><mo stretchy="false">)</mo><mi>a</mi></msup><mspace width="1em"/><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mspace width="1em"/><mi>p</mi></mrow><annotation encoding="application/x-tex">(g^a)^b \quad mod \quad p = (g^b)^a \quad mode \quad p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">p</span></span></span></span></span></p><p><strong>g</strong>, <strong>a</strong>, <strong>b</strong> 和 <strong>p</strong>都是正整数；<br />当我们已知 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><msup><mi>g</mi><mi>a</mi></msup><mspace width="1em"/><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>p</mi></mrow><annotation encoding="application/x-tex">A = g^a \quad mod \quad p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">p</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>=</mo><msup><mi>g</mi><mi>b</mi></msup><mspace width="1em"/><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>p</mi></mrow><annotation encoding="application/x-tex">B = g^b \quad mod \quad p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">p</span></span></span></span>，我们可以在不知道 a 或 b 的情况下计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msup><mi>g</mi><mi>a</mi></msup><msup><mo stretchy="false">)</mo><mi>b</mi></msup><mspace width="1em"/><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>p</mi></mrow><annotation encoding="application/x-tex">(g^a)^b \quad mod \quad p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">p</span></span></span></span></p><p><code>注</code>: 如果$ m = g^s \quad mod \quad p $, 即使<strong>m</strong> 、<strong>g</strong>、<strong>p</strong>已知的情况下，也没有有效的（快速）算法来找到私密指数<strong>s</strong>，<a href="https://en.wikipedia.org/wiki/Discrete_Logarithm_Problem_(DLP)">Discrete Logartihm Problem (DLP)</a>。</p><p><strong>离散对数问题（ Discrete Logarithm Problem，DLP）</strong></p><p>计算机科学中的离散对数问题（DLP）定义如下：</p><ul><li>通过给定元素<strong>b</strong>和值<strong>a</strong> = $ b^x $来找到指数 <strong>x</strong>（如果存在）</li></ul><p>指数<strong>x</strong>称为离散对数，即<strong>x</strong> =$ \log_ba$</p><p><strong>The DHKE Protocol</strong></p><p><img src="http://qiniu.gogocoding.cn/mweb/The%20DHKE%20Protocol.png" alt="The DHKE Protoco -c400" /></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><msup><mi>A</mi><mi>b</mi></msup><mspace width="1em"/><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>p</mi><mo>=</mo><mo stretchy="false">(</mo><msup><mi>g</mi><mi>a</mi></msup><mspace width="1em"/><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>p</mi><msup><mo stretchy="false">)</mo><mi>b</mi></msup><mspace width="1em"/><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>p</mi><mo>=</mo><mo stretchy="false">(</mo><msup><mi>g</mi><mi>a</mi></msup><msup><mo stretchy="false">)</mo><mi>b</mi></msup><mspace width="1em"/><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>p</mi><mo>=</mo><mo stretchy="false">(</mo><msup><mi>g</mi><mi>b</mi></msup><mspace width="1em"/><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>p</mi><msup><mo stretchy="false">)</mo><mi>a</mi></msup><mspace width="1em"/><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>p</mi><mo>=</mo><msup><mi>B</mi><mi>a</mi></msup><mspace width="1em"/><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"/><mi>p</mi></mrow><annotation encoding="application/x-tex">S=A^b \quad mod \quad p = (g^a \quad mod \quad p)^b \quad mod \quad p = (g^a)^b \quad mod  \quad p = (g^b \quad mod \quad p)^a \quad mod \quad p = B^a \quad mod \quad p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.093548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9088319999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">p</span></span></span></span></span></p><h2 id="54-ecdh-基于椭圆曲线的diffie-hellman密钥交换协议"><a class="markdownIt-Anchor" href="#54-ecdh-基于椭圆曲线的diffie-hellman密钥交换协议"></a> 5.4 ECDH-基于椭圆曲线的Diffie-Hellman密钥交换协议</h2><p>​**<a href="https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman">Elliptic-Curve Diffie–Hellman (ECDH)</a>** 是一个匿名密钥协商协议，该协议允许两方（每方都有一个椭圆曲线的公私钥对）在不安全的通道上建立共享秘钥。ECDH是经典DHKE协议的一种变体，其中模化指数计算被椭圆曲线计算代替以提高安全性。稍后我们将详细解释椭圆曲线密码学（ECC）部分。</p><h2 id="55-dhke-使用示例"><a class="markdownIt-Anchor" href="#55-dhke-使用示例"></a> 5.5 DHKE 使用示例</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyDHE</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyDHE</span><br><span class="line"></span><br><span class="line">alice = pyDHE.new()</span><br><span class="line">alicePubKey = alice.getPublicKey()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Alice public key:&quot;</span>, <span class="built_in">hex</span>(alicePubKey))</span><br><span class="line"></span><br><span class="line">bob = pyDHE.new()</span><br><span class="line">bobPubKey = bob.getPublicKey()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Bob public key:&quot;</span>, <span class="built_in">hex</span>(bobPubKey))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Now exchange the public keys (e.g. through Internet)&quot;</span>)</span><br><span class="line"></span><br><span class="line">aliceSharedKey = alice.update(bobPubKey)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Alice shared key:&quot;</span>, <span class="built_in">hex</span>(aliceSharedKey))</span><br><span class="line"></span><br><span class="line">bobSharedKey = bob.update(alicePubKey)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Bob shared key:&quot;</span>, <span class="built_in">hex</span>(bobSharedKey))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Equal shared keys:&quot;</span>, aliceSharedKey == bobSharedKey)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Alice public key: 0xa26c2f1354a8f58abbf78172730595c4de8277962ebe92100793f99ea80f66abe5e75a14a52e86ce1c086c1ca2e1662b3900510346d848b425d34279ceea92661fb1166b9438589c0b57eb4ebb69e0c3844ebe5ad4c0e316b637d47148d69dc2387c2968c82d198114a6c0f14a605a9e85110d24a9db4f11963b9b13dc788c0538096cadffd258364c63621f6bb1a3e515d3741af4619e62452a394fab9d84be7cee255fdd7216401cafee6471b4adbb77e93f878f1bb4df633e0632522b51fe70fc154e7d3e60a69f815a4e2a84506f05b1ccfce01e873cd7dc51fba0b6eac66af1c0a7500f71af405a6c34ffd27a1239180c22fbddf8dc15d30c821c57307d</span><br><span class="line">Bob public key: 0x822660dfff1af80c237402263dda9e0e417fa04547a4e36041a35a152df28b0ac66b059d9e0034c7cd58b6b7edbc8a20bf1bdc2af6534bd6f2dbcffeb9a4aa9f038461994622f786258beb8f6493594e1559e5ebf5a92ba60335f668a9ccbf8d6d87460f21d94938ac40cfd78d062571f68aa7e7fbabed4ba582e8e831288670004ae64be113a2c7b5b9a472ba4733ea4f29c1b1f30ead3729908d9bb54278a499b2c16cc62d4f330a28cdd302bf655f3d724b6d5b0655c9299ada183d8bed4e98c2f0d93339eb3c22c88c9d000de4ea3286b6be5b96e7d7cccb7b8d6a079264e155c5b25b5aca21ccfed7d21d5dce79845fe5456419504ec9c2a896448572e7</span><br><span class="line">Now exchange the public keys (e.g. through Internet)</span><br><span class="line">Alice shared key: 0x60d96187ae1db8e8acac7795837a2964e4972ebf666eaecfa09135371a2de5287db18c1a30f2af840f04cac42fea21e42369af5ffbeb235faa42da6bed24cd922ea4637ad146558f2d8b07b19a0084c19f041af5456a5826dd836d0c9c4f32ca0a5877da9493af36f66949e76af12e45a20b20c222a37a49b658066bd7b1f79bcf81d1083e79c62c43e3ee11f8727e798e310a2683939c06b75ab80c531743d6c03c90007ab8a36af45b3573f4e41a2a41c9fdde962493f9ed860597ee527d978e41a413d13198aaac2b27e70aac5be15fd695592350c56b6d74b3427dcf6888ee11cef4b4d8f5b3acbfbda1d9b8d7425bc9446e1a6424a929d9136590161cfe</span><br><span class="line">Bob shared key: 0x60d96187ae1db8e8acac7795837a2964e4972ebf666eaecfa09135371a2de5287db18c1a30f2af840f04cac42fea21e42369af5ffbeb235faa42da6bed24cd922ea4637ad146558f2d8b07b19a0084c19f041af5456a5826dd836d0c9c4f32ca0a5877da9493af36f66949e76af12e45a20b20c222a37a49b658066bd7b1f79bcf81d1083e79c62c43e3ee11f8727e798e310a2683939c06b75ab80c531743d6c03c90007ab8a36af45b3573f4e41a2a41c9fdde962493f9ed860597ee527d978e41a413d13198aaac2b27e70aac5be15fd695592350c56b6d74b3427dcf6888ee11cef4b4d8f5b3acbfbda1d9b8d7425bc9446e1a6424a929d9136590161cfe</span><br><span class="line">Equal shared keys: True</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CryptoGraphy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CryptoGraphy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04. Secure Random Number Generators, PRNG and CSPRNG</title>
      <link href="/2020/03/05/CryptoGraphy/04.%20Secure%20Random%20Number%20Generators,%20PRNG%20and%20CSPRNG/"/>
      <url>/2020/03/05/CryptoGraphy/04.%20Secure%20Random%20Number%20Generators,%20PRNG%20and%20CSPRNG/</url>
      
        <content type="html"><![CDATA[<p>​在密码学中，随机性（熵）起着非常重要的作用。 在许多算法中，我们需要随机（即不可预测）。 如果这些数字不是不可预测的，则算法将会更容易被攻破。</p><p>​例如，假设我们需要一个密钥，它将保护我们的金融资产。应该以其他任何人都不能生成或拥有相同密钥的方式随机生成此密钥。我们从安全的随机生成器生成密钥，则密钥将是不可预测的，因此“安全随机”仅表示“不可预测的随机”。</p><p>​让我们更详细地讨论计算机科学中的随机数及其在密码学中的作用，伪随机数生成器（ pseudo-random numbers generators, PRNG），安全伪随机生成器（Cryptography secure pseudo-random generators, CSPRNG），以及开发人员应如何在代码中生成和使用随机数的一些准则。</p><h2 id="41-pseudo-random-number-generators-prng"><a class="markdownIt-Anchor" href="#41-pseudo-random-number-generators-prng"></a> 4.1 Pseudo-Random Number Generators (PRNG)</h2><p>​伪随机数生成器(PRNG)用于将少量的初始随机性扩展为大量的伪随机性，通常用于密码系统。注意，PRNGs不是加密安全的，并且不同于CSPRNGs。</p><p>​<code>PRNGs</code>是从某个初始熵（种子,seed）开始，并通过某种计算来计算下一个随机数的函数，而这些计算在不知道种子的情况下是无法预测的。 这种计算称为伪随机函数。<br />​<br /><img src="http://qiniu.gogocoding.cn//mweb/PRNGs.png" alt="PRNGs" /></p><p>此过程以最简单的形式可以实现如下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init(entropy):</span><br><span class="line">  state = entropy, counter = <span class="number">0</span></span><br><span class="line">netNum():</span><br><span class="line">  state = HMAC(state, ++counter)</span><br><span class="line">  <span class="keyword">return</span> state</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="built_in">print</span>(random.randrange(<span class="number">1000000</span>, <span class="number">9999999</span>))</span><br></pre></td></tr></table></figure><p>上面的代码生成一个随机数，但是这个数字是可以预测的。 这是因为Python（旧版本）中的随机库会在当前时间之前初始化随机生成器种子</p><h2 id="42-csprng-cryptography-secure-random-number-generators"><a class="markdownIt-Anchor" href="#42-csprng-cryptography-secure-random-number-generators"></a> 4.2 CSPRNG (Cryptography Secure Random Number Generators)</h2><p>​根据定义，<code>CSPRNG</code>（密码学安全随机数发生器）是一种伪随机数发生器（PRNG），其一些特性使其适合用于密码学。 要使PRNG成为CSPRNG，有两个主要要求：</p><ol><li>满足 <a href="https://en.wikipedia.org/wiki/Next-bit_test"><strong>next-bit test</strong></a> ：即使某人从PRNG的开头就知道所有k位，那么他将无法使用合理的计算资源来预测k + 1位。</li><li>经受<a href="https://www.owasp.org/index.php/PRNG_state_compromise_extension_attack"><strong>state compromise extensions</strong></a> : 如果攻击者猜出PRNG的内部状态或内部状态以某种方式被暴露，攻击者也无法重建内部状态暴露前的所有随机数。</li></ol><p>已提出许多设计来构造CSPRNG算法：</p><ol><li>基于数论、整数分解问题（IFP），离散对数问题（DLP）或椭圆曲线离散对数问题（ECDLP）。</li><li>基于密码安全随机性的特殊设计：例如：<code>MacOS</code> 和<code>FreeBSD</code>系统中的 <a href="https://en.wikipedia.org/wiki/Yarrow_algorithm">Yarrow algorithm</a> 和 <a href="https://en.wikipedia.org/wiki/Fortuna_(PRNG)">Fortuna</a>,</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> secrets</span><br><span class="line"><span class="built_in">print</span>(secrets.randbelow(<span class="built_in">int</span>(<span class="number">1e50</span>)))</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib, time, binascii</span><br><span class="line"></span><br><span class="line">entropy = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    s = <span class="built_in">input</span>(<span class="string">&quot;Enter something [&quot;</span> + <span class="built_in">str</span>(i+<span class="number">1</span>) + <span class="string">&quot; of 5]: &quot;</span>)</span><br><span class="line">    entropy = entropy + s + <span class="string">&#x27;|&#x27;</span> + <span class="built_in">str</span>(time.time()) + <span class="string">&#x27;|&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Entropy:&quot;</span>, entropy)</span><br><span class="line">startSeed = <span class="built_in">str</span>(binascii.hexlify(hashlib.sha256(entropy.encode(<span class="string">&#x27;ascii&#x27;</span>)).digest()))[<span class="number">2</span>:-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Start seed = SHA-256(entropy) =&quot;</span>, startSeed)</span><br><span class="line"></span><br><span class="line"><span class="built_in">min</span> = <span class="number">10</span></span><br><span class="line"><span class="built_in">max</span> = <span class="number">20</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    nextSeed = startSeed + <span class="string">&#x27;|&#x27;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">    <span class="built_in">hash</span> = hashlib.sha256(nextSeed.encode(<span class="string">&#x27;ascii&#x27;</span>)).digest()</span><br><span class="line">    bigRand = <span class="built_in">int</span>.from_bytes(<span class="built_in">hash</span>, <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">    rand = <span class="built_in">min</span> + bigRand % (<span class="built_in">max</span> - <span class="built_in">min</span> + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(nextSeed, bigRand, <span class="string">&#x27;--&gt;&#x27;</span>, rand)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Enter something [1 of 5]: first</span><br><span class="line">Enter something [2 of 5]: second</span><br><span class="line">Enter something [3 of 5]: random text</span><br><span class="line">Enter something [4 of 5]: dfasfdasfs</span><br><span class="line">Enter something [5 of 5]: last</span><br><span class="line">Entropy: first|1539885709.4494743|second|1539885713.687703|random text|1539885721.5754962|dfasfdasfs|1539885724.40904|last|1539885726.1286101|</span><br><span class="line">Start seed &#x3D; SHA-256(entropy) &#x3D; f8a4eaceb16156b1a23f4b6d08e54665ffa4822949b22e01d6de4c5daae965e3</span><br><span class="line">f8a4eaceb16156b1a23f4b6d08e54665ffa4822949b22e01d6de4c5daae965e3|0 84482770259566839097936866229004786554948913905882724148636325987196754263481 --&gt; 19</span><br><span class="line">f8a4eaceb16156b1a23f4b6d08e54665ffa4822949b22e01d6de4c5daae965e3|1 67001454659030164457342421011672033052466168976555224352709830050538321411120 --&gt; 14</span><br><span class="line">f8a4eaceb16156b1a23f4b6d08e54665ffa4822949b22e01d6de4c5daae965e3|2 103739181507291072572315034266940107849472122762876847172454548630886082729227 --&gt; 12</span><br><span class="line">f8a4eaceb16156b1a23f4b6d08e54665ffa4822949b22e01d6de4c5daae965e3|3 3011033199204097839903859902789759740091959530467456042709372597822032778153 --&gt; 16</span><br><span class="line">f8a4eaceb16156b1a23f4b6d08e54665ffa4822949b22e01d6de4c5daae965e3|4 100466094724924763659843669256673300207383922129676800217664465341535622195997 --&gt; 16</span><br></pre></td></tr></table></figure><p><strong>作为开发者如何访问CSPRNG</strong></p><ul><li>In <strong>Linux</strong> and <strong>macOS</strong>, it is considered that both <code>/dev/random</code> and <code>/dev/urandom</code> sources of randomness are <strong>secure enough for most cryptographic purposes</strong> and most cryptographic libraries access them internally.</li><li>In <strong>Windows</strong>, random numbers for cryptographic purposes can be securely generated using the <code>BCryptGenRandom</code> function from the <a href="https://docs.microsoft.com/windows/desktop/SecCNG/cng-portal">Cryptography API: Next Generation (CNG)</a> or higher level crypto libraries.</li><li>In <strong>C#</strong> use <code>System.Security.Cryptography.RandomNumberGenerator.Create()</code> from .NET Framework or .NET Core.</li><li>In <strong>Python</strong> use <code>os.urandom()</code> or the <code>secrets</code> library.</li><li>In <strong>Java</strong> use the <code>java.security.SecureRandom</code> system class.</li><li>In <strong>JavaScript</strong> use <code>window.crypto.getRandomValues(Uint8Array)</code> for client side (in the Web browser) or <code>crypto.randomBytes()</code> or external module like <code>node-sodium</code> for server-side (in Node.js).</li></ul><p><strong>Never use</strong> <code>Math.random()</code> or similar insecure RNG functions for cryptographic purposes!</p>]]></content>
      
      
      <categories>
          
          <category> CryptoGraphy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CryptoGraphy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03. MAC Codes and Key Derivation Functions</title>
      <link href="/2020/03/05/CryptoGraphy/03.%20MAC%20Codes%20and%20Key%20Derivation%20Functions/"/>
      <url>/2020/03/05/CryptoGraphy/03.%20MAC%20Codes%20and%20Key%20Derivation%20Functions/</url>
      
        <content type="html"><![CDATA[<p>​消息认证码(MAC)，HMAC(hash-based message authentication code,基于哈希的消息认证码)和KDF(key derivation functions, 密钥导出函数)在密码学中起着重要的作用。</p><h2 id="31-消息认证码"><a class="markdownIt-Anchor" href="#31-消息认证码"></a> 3.1 消息认证码</h2><p>消息验证码(MAC)是由给定密钥和消息计算出的密码。<br />​<code>auth_code = MAC(key, msg)</code><br />通常它的类似于哈希函数：</p><ul><li>消息或密钥中的微小变化会导致<code>MAC</code>值完全不同；</li><li>不可能通过更改秘钥或者消息来获得相同的<code>MAC</code>值；</li><li>无法从<code>MAC</code>值推测出原始消息或密钥。</li></ul><p>​存在许多用于计算消息认证码（MAC）的算法。 最受欢迎的是基于哈希算法，如：<a href="https://en.wikipedia.org/wiki/HMAC">HMAC</a>（Hash-based MAC, e.g. HMAC-SHA256）和<a href="https://www.cryptosys.net/manapi/api_kmac.html">KMAC</a>（Keccak-based MAC）。基于对称加密的MAC，如<a href="https://en.wikipedia.org/wiki/One-key_MAC">CMAC</a>(Cipher-based MAC)，<a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode">GMAC</a>（Galois MAC）和<a href="https://en.wikipedia.org/wiki/Poly1305">Poly1305</a>（Bernstein’s one-time authenticator）。</p><p><strong>例</strong>：可以通过HMAC-SHA256算法来计算MAC值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib, hmac, binascii</span><br><span class="line"></span><br><span class="line">mac = hmac.new(<span class="string">b&#x27;key&#x27;</span>, <span class="string">b&#x27;some msg&#x27;</span>, hashlib.sha256).digest()</span><br><span class="line"><span class="built_in">print</span>(binascii.hexlify(mac))</span><br></pre></td></tr></table></figure><p>MAC是类似于数字签名的数字认证码，但是他具有预共享的密钥。</p><p>消息认证码的应用场景：</p><ul><li>通信双方交换了某种特定的MAC的秘钥；</li><li>接收方从某处收到了msg + auth_code；</li><li>保证msg未被篡改，意味着秘钥key和msg是正确的，且可以匹配对应的MAC码。</li></ul><p><img src="http://q6r9jgptb.bkt.clouddn.com/mweb/sample%20scenario%20for%20using%20MAC%20codes.png" alt="sample scenario for using MAC codes" /></p><h3 id="311-认证加密使用mac加密解密消息"><a class="markdownIt-Anchor" href="#311-认证加密使用mac加密解密消息"></a> 3.1.1 认证加密：使用MAC加密/解密消息</h3><p>​使用MAC代码的另一种情况是认证加密：当我们加密消息时，我们要确保解密的密码正确并且解密后的消息与加密前的原始消息相同。<br />​<br />​加密msg过程：</p><ol><li>根据密码生成密钥。 我们可以将此密钥用于<code>MAC</code>算法。</li><li>使用生成的密钥对消息进行加密，并将密文存储在输出中。</li><li>使用密钥和原始消息来计算<code>MAC</code>，并将其附加到输出中。</li></ol><p>​解密msg过程</p><ol><li>根据用户输入的密码生成密钥，可能是正确的密码或错误的密码， 稍后可以得到验证。</li><li>使用生成的密钥解密消息， 它可能是原始消息，也可能是错误消息（取决于输入的密码）。</li><li>使用生成的密钥+解密后的消息来计算MAC代码。<ol><li>如果计算出的MAC码与加密消息中的MAC代码匹配，则密码正确。</li><li>否则，得到的解密消息和源消息不一致，意味着密码错误。</li></ol></li></ol><p>​一些认证加密算法（例如<strong>AES-GCM</strong>和<strong>ChaCha20-Poly1305</strong>）将MAC计算集成到加密算法中，并将MAC验证集成到解密算法中。MAC与密文一起存储，并且不会泄露密码或原始消息。 存储对任何人都可见的MAC码是安全的，并且在解密之后，我们知道消息是否是原始消息（密码是否错误）。</p><h3 id="312-基于mac的伪随机数器生成器"><a class="markdownIt-Anchor" href="#312-基于mac的伪随机数器生成器"></a> 3.1.2 基于MAC的伪随机数器生成器</h3><p><code>MAC</code>的另一个应用就是伪随机数器生成器，根据一个确定的salt(常量、当前日期和时间，或者其他随机数)和一些seed number（最新生成的随机数），我们可以如下计算next_seed：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next_seed = MAC(salt, seed)</span><br></pre></td></tr></table></figure><h2 id="32-hmac和密钥生成函数-key-derivation-functions-kdf"><a class="markdownIt-Anchor" href="#32-hmac和密钥生成函数-key-derivation-functions-kdf"></a> 3.2 HMAC和密钥生成函数( Key Derivation Functions, KDF)</h2><p>​仅通过计算哈希 <code>hash_func(key + msg)</code>来获得<code>MAC</code>是不安全的，<a href="https://en.wikipedia.org/wiki/HMAC#Design_principles">点击查看详情</a>。建议改用<strong>HMAC</strong>算法，例如 <code>HMAC-SHA256</code>或<code>HMAC-SHA3-512</code>或其他安全的MAC算法<br />​<br />​<a href="https://en.wikipedia.org/wiki/HMAC"><strong>HMAC</strong></a> = <strong>H</strong>ash-based <strong>M</strong>essage <strong>A</strong>uthentication <strong>C</strong>ode (MAC code, calculated using a cryptographic hash function):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMAC(key, msg, hash_func) -&gt; hash</span><br></pre></td></tr></table></figure><p>​得到的结果MAC码是混合了密钥的消息哈希值。 它具有哈希的加密属性：不可逆，抗碰撞等。<code>hash_func</code>可以是任何加密哈希函数，例如:<code>SHA-256</code>，<code>SHA-512</code>，<code>RIPEMD-160</code>，<code>SHA3-256</code>或<code>BLAKE2s</code>。<strong>HMAC</strong>用于保证消息真实性，消息完整性，有时还用于密钥生成。<br />​</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib, hmac, binascii</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hmac_sha256</span>(<span class="params">key, msg</span>):</span></span><br><span class="line">  <span class="keyword">return</span> hmac.new(key, msg, hashlib.sha256).digest()</span><br><span class="line"></span><br><span class="line">key = <span class="string">b&quot;12345&quot;</span></span><br><span class="line">msg = <span class="string">b&quot;sample message&quot;</span></span><br><span class="line"><span class="built_in">print</span>(binascii.hexlify(hmac_sha256(key, msg)))</span><br></pre></td></tr></table></figure><h3 id="321-秘钥生成函数key-derivation-functions-kdf"><a class="markdownIt-Anchor" href="#321-秘钥生成函数key-derivation-functions-kdf"></a> 3.2.1 秘钥生成函数(Key Derivation Functions, KDF)</h3><p>KDF是将可变长度密码转换为固定长度密钥（bit序列）的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function(password) -&gt; key</span><br></pre></td></tr></table></figure><h3 id="322-根据密码生成秘钥"><a class="markdownIt-Anchor" href="#322-根据密码生成秘钥"></a> 3.2.2 根据密码生成秘钥</h3><p>如何安全的根据密码生成秘钥？一起了解一下实践中常用的KDFs：<strong><a href="https://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a></strong>，<strong><a href="https://en.wikipedia.org/wiki/Bcrypt">Bcrypt</a></strong>，<strong><a href="https://en.wikipedia.org/wiki/Argon2">Scrypt</a><strong>和</strong><a href="https://en.wikipedia.org/wiki/Argon2">Argon2</a></strong>，并讨论上述KDFs的优缺点和使用它们的场景。</p><h4 id="3221-pbkdf2"><a class="markdownIt-Anchor" href="#3221-pbkdf2"></a> 3.2.2.1 PBKDF2:</h4><p>​<code>PBKDF2</code>是一个简单的可抵御<a href="https://en.wikipedia.org/wiki/Dictionary_attack">dictionary attacks</a>和 <a href="https://en.wikipedia.org/wiki/Rainbow_table">rainbow table attacks</a> 的 KDF。 该算法原理基于在HASH算法基础上增加随机盐，并进行多次HASH运算。PBKDF2接受多个输入参数，并生成密钥作为输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key &#x3D; pbkdf2(password, salt, iterations-count, hash-function, derived-key-len)</span><br></pre></td></tr></table></figure><p>从技术上讲，<code>PBKDF2</code>的输入数据包括：</p><ul><li><code>password</code> : 字节/字符串数组;</li><li><code>salt</code> : 安全生成的随机字节(最低64位，建议使用128位);</li><li><code>iterations-count</code>: 迭代次数；</li><li><code>hash-function</code> : 用于计算HMAC;</li><li><code>derived-key-len</code> : 生成秘钥长度;</li></ul><p><strong>注</strong>：PBKDF2不能抵抗<a href="https://security.stackexchange.com/questions/118147/how-are-gpus-used-in-brute-force-attacks">GPU attacks</a> (使用显卡并行密码破解)和<a href="https://en.wikipedia.org/wiki/Custom_hardware_attack">ASIC attacks</a>(专用密码破解硬件).如今<code>PBKDF2</code>被认为是过时的且不如现代KDF功能安全的，因此建议改用<code>Bcrypt</code>，<code>Scrypt</code>或<code>Argon2</code>。</p><p>在此处尝试PBKDF2密钥生成：<a href="https://asecuritysite.com/encryption/PBKDF2z">https://asecuritysite.com/encryption/PBKDF2z</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install backports.pbkdf2</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, binascii</span><br><span class="line"><span class="keyword">from</span> backports.pbkdf2 <span class="keyword">import</span> pbkdf2_hmac</span><br><span class="line"></span><br><span class="line">salt = binascii.unhexlify(<span class="string">&#x27;aaef2d3f4d77ac66e9c5a6c3d8f921d1&#x27;</span>)</span><br><span class="line">passwd = <span class="string">&quot;p@$Sw0rD~1&quot;</span>.encode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">key = pbkdf2_hmac(<span class="string">&quot;sha256&quot;</span>, passwd, salt, <span class="number">50000</span>, <span class="number">32</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Derived key:&quot;</span>, binascii.hexlify(key))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derived key: b&#39;52c5efa16e7022859051b1dec28bc65d9696a3005d0f97e506c42843bc3bdbc0&#39;</span><br></pre></td></tr></table></figure><h3 id="323-现代kdfbcryptscrypt和argon2"><a class="markdownIt-Anchor" href="#323-现代kdfbcryptscrypt和argon2"></a> 3.2.3 现代KDF：Bcrypt，Scrypt和Argon2</h3><p>​<code>Scrypt</code>和<code>Argon2</code>等现代KDF旨在抵抗字典攻击，GPU攻击和ASIC攻击。 这些功能根据密码（文本）生成固定长度密钥，需要大量内存（RAM），这使得无法在GPU或ASIC硬件上进行快速并行计算。</p><h4 id="3231-scrypt"><a class="markdownIt-Anchor" href="#3231-scrypt"></a> 3.2.3.1 Scrypt</h4><p>​<a href="https://en.wikipedia.org/wiki/Scrypt"><strong>Scrypt</strong></a> (<a href="https://tools.ietf.org/html/rfc7914.html">RFC 7914</a>)是一个健壮的，它需要耗费大量内存，旨在防止GPU，ASIC和FPGA攻击(高效的密码破解硬件)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key &#x3D; Scrypt(password, salt, N, r, p, derived-key-len)</span><br></pre></td></tr></table></figure><p><strong>Scrypt 参数</strong>：</p><ul><li><code>N</code> – 迭代计数（影响内存和CPU使用率）;</li><li><code>r</code> –块大小（影响内存和CPU使用率）;</li><li><code>p</code> –并行因素（并行运行的线程-影响内存，CPU使用率），通常为1;</li><li><code>password</code> – 输入密码（建议最小长度为8-10个字符）;</li><li><code>salt</code> – 安全生成的随机字节（最小64位，建议128位）</li><li><code>derived-key-len</code> - 要生成多少字节作为输出，例如 32个字节（256位）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Memory required &#x3D; 128 * N * r * p bytes</span><br></pre></td></tr></table></figure><p>参数的选择取决于你要等待的时间以及想要达到的安全级别（密码破解阻力）：</p><ol><li>交互式登录的示例参数：N = 16384，r = 8，p = 1（RAM = 2 MB）。 对于交互式登录，您很可能不想等待超过0.5秒， 同样在服务器端，通常许多用户可以同时登录，因此太过缓慢的Scrypt计算会减慢整个系统的速度。</li><li>用于文件加密的样本参数：N = 1048576，r = 8，p = 1（RAM = 1 GB）。 加密硬盘驱动器时，在极少会对数据进行加解密（通常每天不超过2-3次），所以在解锁加密的数据时，可以等待2-3秒以提高安全性。</li></ol><p><strong>Scrypt Calculation in Python</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scrypt</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyscrypt</span><br><span class="line"></span><br><span class="line">salt = <span class="string">b&#x27;aa1f2d3f4d23ac44e9c5a6c3d8f9ee8c&#x27;</span></span><br><span class="line">passwd = <span class="string">b&#x27;p@$Sw0rD~7&#x27;</span></span><br><span class="line">key = pyscrypt.<span class="built_in">hash</span>(passwd, salt, <span class="number">2048</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">32</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Derived key:&quot;</span>, key.<span class="built_in">hex</span>())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derived key: b&#39;e813a6f6ccc4e9110193bf9efb7c0a489d76655f9e36629dccbeaf2a73bc0c6f&#39;</span><br></pre></td></tr></table></figure><h4 id="3232-bcrypt"><a class="markdownIt-Anchor" href="#3232-bcrypt"></a> 3.2.3.2 Bcrypt</h4><p>​<a href="https://en.wikipedia.org/wiki/Bcrypt"><strong>Bcrypt</strong></a>是另一种KDF函数，它对ASIC和GPU攻击的抵抗力较弱。 Bcrypt提供了可配置的迭代计数，但使用恒定的内存消耗，因此更容易构建硬件加速的密码破解程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install bcrypt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import bcrypt</span><br><span class="line"></span><br><span class="line">salt &#x3D; bcrypt.gensalt()</span><br><span class="line">passwd &#x3D; b&#39;p@$Sw0rD~7&#39;</span><br><span class="line">bcrypt.hashpw(passwd, salt)</span><br></pre></td></tr></table></figure><h4 id="3233-argon2-安全的抗asic攻击的kdf"><a class="markdownIt-Anchor" href="#3233-argon2-安全的抗asic攻击的kdf"></a> 3.2.3.3 Argon2: 安全的，抗ASIC攻击的KDF</h4><p><a href="https://en.wikipedia.org/wiki/Argon2"><strong>Argon2</strong></a>是现代的抗ASIC攻击和抗GPU攻击的KDF。它具有比PBKDF2，Bcrypt和Scrypt（在相同CPU和RAM占用的参数配置下）更好的防止密码被破解能力。</p><p><strong>Argon2</strong>有多个变体：</p><ol><li><strong>Argon2d</strong> ：提供强大的抗GPU攻击能力，但具有潜在的side-channel攻击（在非常特殊的情况下）。</li><li><strong>Argon2i</strong> : 提供较低的抗GPU攻击能力，但没有side-channel攻击。</li><li><strong>Argon2id</strong> - 推荐，结合了Argon2d和Argon2i。</li></ol><p>Argon2需要以下参数，与Scrypt非常相似：</p><ul><li><strong>password</strong> <code>P</code>: the password (or message) to be hashed</li><li><strong>salt</strong> <code>S</code>: random-generated salt (16 bytes recommended for password hashing)</li><li><strong>iterations</strong> <code>t</code>: number of iterations to perform</li><li><strong>memorySizeKB</strong> <code>m</code>: amount of memory (in kilobytes) to use</li><li><strong>parallelism</strong> <code>p</code>: degree of parallelism (i.e. number of threads)</li><li><strong>outputKeyLength</strong> <code>T</code>: desired number of returned bytes</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install argon2_cffi</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argon2, binascii</span><br><span class="line"></span><br><span class="line"><span class="built_in">hash</span> = argon2.hash_password_raw(</span><br><span class="line">    time_cost=<span class="number">16</span>, memory_cost=<span class="number">2</span>**<span class="number">15</span>, parallelism=<span class="number">2</span>, hash_len=<span class="number">32</span>,</span><br><span class="line">    password=<span class="string">b&#x27;password&#x27;</span>, salt=<span class="string">b&#x27;some salt&#x27;</span>, <span class="built_in">type</span>=argon2.low_level.<span class="type">Type</span>.ID)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Argon2 raw hash:&quot;</span>, binascii.hexlify(<span class="built_in">hash</span>))</span><br><span class="line"></span><br><span class="line">argon2Hasher = argon2.PasswordHasher(</span><br><span class="line">    time_cost=<span class="number">16</span>, memory_cost=<span class="number">2</span>**<span class="number">15</span>, parallelism=<span class="number">2</span>, hash_len=<span class="number">32</span>, salt_len=<span class="number">16</span>)</span><br><span class="line"><span class="built_in">hash</span> = argon2Hasher.<span class="built_in">hash</span>(<span class="string">&quot;password&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Argon2 hash (random salt):&quot;</span>, <span class="built_in">hash</span>)</span><br><span class="line"></span><br><span class="line">verifyValid = argon2Hasher.verify(<span class="built_in">hash</span>, <span class="string">&quot;password&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Argon2 verify (correct password):&quot;</span>, verifyValid)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    argon2Hasher.verify(<span class="built_in">hash</span>, <span class="string">&quot;wrong123&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Argon2 verify (incorrect password):&quot;</span>, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Argon2 raw hash: b&#39;157f21dd3fdf7bafb76d2923ccaffa0b7be7cbae394709474d2bc66ee7b09d3e&#39;</span><br><span class="line">Argon2 hash (random salt): $argon2id$v&#x3D;19$m&#x3D;32768,t&#x3D;16,p&#x3D;2$Rfy6J41W9idBU+n&#x2F;8sZc6Q$i3QYYPtoogIAw78I2qqlUQ8vjzUXGG1V6QsBOq2NIp4</span><br><span class="line">Argon2 verify (correct password): True</span><br><span class="line">Argon2 verify (incorrect password): False</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left"><strong>Approach</strong></th><th style="text-align:left"><strong>Security</strong></th><th style="text-align:left"><strong>Comments</strong></th></tr></thead><tbody><tr><td style="text-align:left">Clear-text passwords</td><td style="text-align:left">Extremely low</td><td style="text-align:left">Never do this: compromised server will render all passwords leaked</td></tr><tr><td style="text-align:left">Simple password hash</td><td style="text-align:left">Low</td><td style="text-align:left">Vulnerable to dictionary attacks</td></tr><tr><td style="text-align:left">Salted hashed passwords</td><td style="text-align:left">Average</td><td style="text-align:left">Vulnerable to GPU-based and ASIC-based password cracking</td></tr><tr><td style="text-align:left">Secure KDF function (like Argon2)</td><td style="text-align:left">High</td><td style="text-align:left">Recommended, use strong KDF parameters</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> CryptoGraphy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CryptoGraphy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02. Hashing and Cryptographic Hash Functions</title>
      <link href="/2020/03/05/CryptoGraphy/02.%20Hashing%20and%20Cryptographic%20Hash%20Functions/"/>
      <url>/2020/03/05/CryptoGraphy/02.%20Hashing%20and%20Cryptographic%20Hash%20Functions/</url>
      
        <content type="html"><![CDATA[<h1 id="02-hashing-and-cryptographic-hash-functions"><a class="markdownIt-Anchor" href="#02-hashing-and-cryptographic-hash-functions"></a> 02. Hashing and Cryptographic Hash Functions</h1><p>​在计算机编程中，哈希函数用于将文本或其他数据映射到整形值。通常不通的输入值会映射到不通的输出值，但是输出值偶尔会发生<code>碰撞</code>（不同的输入值，但是输出值相同）。加密哈希函数将文本或二进制数据转换为固定长度的散列值，并且具有抗冲突性和不可逆性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHA3-256(<span class="string">&quot;hello&quot;</span>) = <span class="string">&quot;3338be694f50c5f338814986cdf0686453a888b84f424d792af4b9202398f392&quot;</span></span><br><span class="line">SHA256(<span class="string">&quot;hello&quot;</span>) = <span class="string">&quot;2CF24DBA5FB0A30E26E83B2AC5B9E29E1B161E5C1FA7425E73043362938B9824&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib, binascii</span><br><span class="line">sha3_256hash = hashlib.sha3_256(<span class="string">b&#x27;hello&#x27;</span>).digest()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;SHA3-256(&#x27;hello&#x27;) =&quot;</span>, binascii.hexlify(sha3_256hash))</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib, binascii</span><br><span class="line">sha256hash = hashlib.sha256(<span class="string">b&#x27;hello&#x27;</span>).digest()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;SHA3-256(&#x27;hello&#x27;) =&quot;</span>, binascii.hexlify(sha256hash))</span><br></pre></td></tr></table></figure><h2 id="21-加密哈希函数和冲突"><a class="markdownIt-Anchor" href="#21-加密哈希函数和冲突"></a> 2.1 加密哈希函数和冲突</h2><h3 id="211-哈希碰撞"><a class="markdownIt-Anchor" href="#211-哈希碰撞"></a> 2.1.1 哈希碰撞</h3><p>碰撞意味着两个不同输入的哈希值相同， 对于简单的哈希函数，很容易发生碰撞。例如，假设哈希函数h(text)等于文本中所有字符码的和。 则对于以不同顺序持有相同字母的文本，将产生相同的哈希值（碰撞），即：<code>h('abc') == h('cab') == h('bca')</code>。为了避免冲突，密码学家设计了抗碰撞的哈希函数。</p><h3 id="212-加密哈希函数无冲突"><a class="markdownIt-Anchor" href="#212-加密哈希函数无冲突"></a> 2.1.2 加密哈希函数：无冲突</h3><p>​加密哈希函数极不可能产生碰撞，可以认为加密哈希值几乎可以唯一地标识其对应的输入， 并且很难根据哈希值反推出输入值。加密哈希函数是不可逆的单向哈希函数。<br />​<br />理想的加密哈希函数应该具备以下属性：</p><ul><li><strong>确定性</strong>：相同输入总是可以得到相同的输出值</li><li><strong>快速性</strong>：计算任何给定消息的哈希值应该很快。</li><li><strong>难分析性</strong>：对输入值的微小更改将完全改变输出哈希值。</li><li><strong>不可逆性</strong>：无法根据哈希值反推出输入值，即：除了暴力穷举外，没有明显更好的办法来猜出输入值。</li></ul><p>现代的加密哈希函数（例如SHA2和SHA3）属性与上述属性匹配，并且在密码学中得到了广泛使用。</p><h2 id="22-加密哈希函数的应用"><a class="markdownIt-Anchor" href="#22-加密哈希函数的应用"></a> 2.2 加密哈希函数的应用</h2><ul><li>文件完整性校验</li><li>存储密码：/etc/shadow</li><li>生成唯一ID: <code>Git commit ID</code>、<code>Bitcoin addresses</code></li><li>生成伪随机数：</li><li>工作量证明算法：</li></ul><h2 id="23-安全哈希算法"><a class="markdownIt-Anchor" href="#23-安全哈希算法"></a> 2.3 安全哈希算法</h2><p>​软件开发人员提出并使用了许多密码哈希算法。 但是其中一些已经被证明为不安全的，例如MD5和SHA1；还有一些仍然认为是安全的，如SHA-2,SHA-3和BLAKE2等</p><h3 id="231-sha-2-sha-256-sha-512"><a class="markdownIt-Anchor" href="#231-sha-2-sha-256-sha-512"></a> 2.3.1 SHA-2, SHA-256, SHA-512</h3><p>​SHA-2是一组加密哈希函数，<strong>SHA-256</strong> (256 bits hash), <strong>SHA-384</strong> (384 bits hash), <strong>SHA-512</strong> (512 bits hash)，他们都是基于 &quot;<a href="https://en.wikipedia.org/wiki/Merkle%E2%80%93Damg%C3%A5rd_construction"><strong>Merkle–Damgård construction</strong></a>&quot;的密码学概念，SHA-2是美国的官方加密标准。更多位的哈希值能提供更好的抗碰撞性。</p><h3 id="232-sha-3-sha3-256-sha3-512-keccak-256"><a class="markdownIt-Anchor" href="#232-sha-3-sha3-256-sha3-512-keccak-256"></a> 2.3.2 SHA-3, SHA3-256, SHA3-512, Keccak-256</h3><p>​SHA-3及其变体SHA3-224，SHA3-256，SHA3-384，SHA3-512 在相同的哈希长度的情况下比SHA-2（SHA-224，SHA-256，SHA-384，SHA-512）更加安全 。SHA-3系列加密哈希函数不容易受到“<strong><a href="https://en.wikipedia.org/wiki/Length_extension_attack">length extension attack</a></strong>”的影响。</p><p>通过以下网址了解有关加密哈希函数，其强度和抗攻击性的更多信息：<a href="https://z.cash/technology/history-of-hash-function-attacks.html">https://z.cash/technology/history-of-hash-function-attacks.html</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib, binascii</span><br><span class="line"></span><br><span class="line">text = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">data = text.encode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line"></span><br><span class="line">sha256hash = hashlib.sha256(data).digest()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;SHA-256:   &quot;</span>, binascii.hexlify(sha256hash))</span><br><span class="line"></span><br><span class="line">sha3_256 = hashlib.sha3_256(data).digest()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;SHA3-256:  &quot;</span>, binascii.hexlify(sha3_256))</span><br><span class="line"></span><br><span class="line">blake2s = hashlib.new(<span class="string">&#x27;blake2s&#x27;</span>, data).digest()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;BLAKE2s:   &quot;</span>, binascii.hexlify(blake2s))</span><br><span class="line"></span><br><span class="line">ripemd160 = hashlib.new(<span class="string">&#x27;ripemd160&#x27;</span>, data).digest()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;RIPEMD-160:&quot;</span>, binascii.hexlify(ripemd160))</span><br></pre></td></tr></table></figure><h2 id="24-工作量证明哈希函数ethash-和-equihash"><a class="markdownIt-Anchor" href="#24-工作量证明哈希函数ethash-和-equihash"></a> 2.4 工作量证明哈希函数：ETHash 和 Equihash</h2><p>​区块链工作量证明挖矿算法使用一类特殊的哈希函数，这些哈希函数旨在消耗大量计算资源和大量内存，并且很难通过硬件设备来实现（例如FPGA集成电路或ASIC矿工） 这种哈希函数的特点被称为“抗ASIC”。这样做的目的在于通过激励小型矿工来最大程度地减少采矿的集中化。大量的小型参与者比少数几个大型参与者意味着更好的权力下放，更好的去中心化。</p><ul><li><strong>ETHash</strong>：以太坊区块链中的工作量证明哈希函数。</li><li><strong>Equihash</strong>：Zcash和Bitcoin Gold区块链中的工作量证明哈希函数</li></ul><p><code>MORE:</code><br />Learn more about <strong>ETHash</strong> at: <a href="https://github.com/ethereum/wiki/wiki/Ethash">https://github.com/ethereum/wiki/wiki/Ethash</a>, <a href="https://github.com/lukovkin/ethash">https://github.com/lukovkin/ethash</a>.</p><p>Learn more about <strong>Equihash</strong> at: <a href="https://www.cryptolux.org/images/b/b9/Equihash.pdf">https://www.cryptolux.org/images/b/b9/Equihash.pdf</a>, <a href="https://github.com/tromp/equihash">https://github.com/tromp/equihash</a>.</p><p>Lear more about the <strong>ASIC-resistant hash functions</strong> at: <a href="https://github.com/ifdefelse/ProgPOW">https://github.com/ifdefelse/ProgPOW</a>.</p>]]></content>
      
      
      <categories>
          
          <category> CryptoGraphy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CryptoGraphy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01. Hello, CryptoGraphy</title>
      <link href="/2020/03/05/CryptoGraphy/01.%20Hello,%20CryptoGraphy%20/"/>
      <url>/2020/03/05/CryptoGraphy/01.%20Hello,%20CryptoGraphy%20/</url>
      
        <content type="html"><![CDATA[<h1 id="01-hello-cryptography"><a class="markdownIt-Anchor" href="#01-hello-cryptography"></a> 01. Hello, CryptoGraphy</h1><p>​参加工作已有不短时间，在这期间，不可避免的接触使用了一些加密算法。平时忙于工作中的各种业务需求，没有对作为信息安全基石的现代密码学内容进行过系统的学习、归纳和总结。在即将迎接2020年春节之际，萌生一个想法，系统性的整理一套学习笔记，以供自己在此方面的知识积淀。</p><p>​密码学有着深刻的数学背景，虽然自己也是数学系毕业，但是查看学院派的书籍如 :<a href="https://crypto.stanford.edu/~dabo/cryptobook/">A Graduate Course in Applied Cryptography</a> 也难免觉得枯燥乏味，这份学习笔记会从工作实践的角度来进行总结。在此特别感谢Dr.<a href="https://nakov.com/">Svetlin Nakov</a>，我的学习笔记主要参考了其编写的<a href="https://wizardforcel.gitbooks.io/practical-cryptography-for-developers-book/"> Practical Cryptography for Developers</a> 一书，沿着该书的脉络，后面笔记预计会从以下主题展开：</p><ol><li>哈希和哈希加密函数(Hashing and Cryptographic Hash Functions)</li><li>消息验证码和秘钥导出函数(Message authentication codes and Key Derivation Functions)</li><li>安全随机数生成器(Secure Random Number Generators)</li><li>秘钥交换(Key Exchange)</li><li>对称秘钥密码(Symmetric Key Ciphers)</li><li>非对称秘钥密码(Asymmetric Key Ciphers)</li><li>数字签名(Digital Signatures)</li><li>更多的密码学概念(More Cryptographic Concepts)</li></ol><h2 id="11-什么是密码学"><a class="markdownIt-Anchor" href="#11-什么是密码学"></a> 1.1 什么是密码学？</h2><p>​<code>密码学</code>是为信息提供安全与防护的一门学科，他广泛应用于数字世界中。因此开发人员应该至少对密码学有基本的了解，以及如何使用密码算法和密码库，并了解他们背后的算法。<br />​</p><h2 id="12-加密和秘钥"><a class="markdownIt-Anchor" href="#12-加密和秘钥"></a> 1.2 加密和秘钥</h2><p>​密码学使用安全的方式处理存储和传输数据，以便于只有特定的人才能读取和处理这些数据。这会涉及使用对称或非对称加密方案对数据进行加密和解密，这些方案在明文和密文的相互转化过程中会用到一个或多个秘钥。</p><p>​对称加密（例如AES，Twofish和ChaCha20）使用相同的密钥来加密和解密消息，而非对称加密使用公钥密码系统（如RSA或ECC）和密钥对：公共密钥（加密密钥）和相应的私有密钥（解密密钥）。</p><h2 id="13-数字签名和消息认证"><a class="markdownIt-Anchor" href="#13-数字签名和消息认证"></a> 1.3 数字签名和消息认证</h2><p>​密码术提供了对消息进行数字签名的方法，可确保消息的真实性，完整性和不可否认性。大多数数字签名算法（例如DSA，ECDSA和EdDSA）都使用非对密钥对来完成：消息由私钥进行签名，签名由相应的公钥来完成验证。在银行系统中，数字签名用于签署和批准交易。在区块链中，签名交易允许用户将区块链资产从一个地址转移到另一个地址。密码学中使用消息认证算法（如：HMAC）和消息认证码（MAC codes）来证明消息的真实性，完整性和来源。</p><h2 id="14-安全随机数"><a class="markdownIt-Anchor" href="#14-安全随机数"></a> 1.4 安全随机数</h2><p>​安全随机数本质上是无法预测的，因此开发人员应在意它们，因为损坏的随机数生成器意味着系统或应用程序受到威胁或被黑。</p><h2 id="15-秘钥交换"><a class="markdownIt-Anchor" href="#15-秘钥交换"></a> 1.5 秘钥交换</h2><p>​密码学定义了密钥交换算法（例如Diffie-Hellman密钥交换和ECDH）和密钥生成方案，用于在打算使用加密算法安全地传输消息的两个节点之间安全地创建加密密钥。这种算法典型的应用就是在双方之间建立新的安全连接，例如，打开一个新的网站或连接到WiFi网络。<br />​<br />##1.6 加密哈希和密码哈希</p><p>​密码学提供加密哈希函数（如SHA-3和BLAKE2），可将消息转换为消息摘要（固定长度的哈希值），并且同时要满足哈希值不能被还原回原始消息，且可以几乎唯一地标识输入值。例如，在区块链系统中，散列用于生成区块链地址，交易ID。在Git中，加密散列用于为文件和提交生成唯一的ID。密码哈希和秘钥导出函数对应的密码如（Scrypt 和 Argon2）通过安全地从基于文本的密码生成散列(或密钥) 来保护用户的密码以及密码加密的文件和数据，并注入随机参数（盐，salt）并使用大量迭代和计算资源以使密码破解速度变慢</p><h2 id="17-密码学中的混乱和扩散"><a class="markdownIt-Anchor" href="#17-密码学中的混乱和扩散"></a> 1.7 密码学中的混乱和扩散</h2><p>​在密码学中，哈希，加密算法和随机生成器遵循香农的混淆和扩散原理。<code>混乱</code>意味着密码形式的输出中的每个bit都应取决于密钥和输入数据的几个部分，因此无法建立直接映射关系。<code>扩散</code>意味着更改输入中的任一bit应更改输出中大约一半的bits。这些原理已包含在大多数哈希函数，MAC算法，随机数生成器，对称和非对称加密中。</p><h2 id="18-加密库"><a class="markdownIt-Anchor" href="#18-加密库"></a> 1.8 加密库</h2><p>​开发人员应该了解现代密码库的编程语言和平台，以及如何使用它们。使用密码学进行开发需要了解加密概念。从Internet复制/粘贴代码或遵循Blog中的示例可能会导致安全风险。加密库非常有用，但是您应该首先了解概念，然后选择适当的算法组合并仔细调整其参数。</p>]]></content>
      
      
      <categories>
          
          <category> CryptoGraphy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CryptoGraphy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. Genesis</title>
      <link href="/2020/03/01/WorkDay/Genesis/"/>
      <url>/2020/03/01/WorkDay/Genesis/</url>
      
        <content type="html"><![CDATA[<h1 id="gogocoding-blog-goes-online"><a class="markdownIt-Anchor" href="#gogocoding-blog-goes-online"></a> GoGoCoding blog goes online !!!</h1><p>2020-03-01 14:37:12</p><h1 id="是的算法练习开始~"><a class="markdownIt-Anchor" href="#是的算法练习开始~"></a> 是的！算法练习开始~</h1><p>2020-08-01 18:49:58<br /><a href="https://time.geekbang.org/column/article/39922?utm_campaign=guanwang&amp;utm_source=baidu-ad&amp;utm_medium=ppzq-pc&amp;utm_content=title&amp;utm_term=baidu-ad-ppzq-title">参考教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作日 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作日 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何掌握企业级技术和项目经验</title>
      <link href="/2020/02/11/Forward/%E3%80%8A%E5%A6%82%E4%BD%95%E6%8E%8C%E6%8F%A1%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%8A%80%E6%9C%AF%E5%92%8C%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E3%80%8B%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
      <url>/2020/02/11/Forward/%E3%80%8A%E5%A6%82%E4%BD%95%E6%8E%8C%E6%8F%A1%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%8A%80%E6%9C%AF%E5%92%8C%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E3%80%8B%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<p>作者：神思者<br />链接：<a href="https://www.imooc.com/article/290648">https://www.imooc.com/article/290648</a><br />来源：慕课网<br />本文原创发布于慕课网 ，转载请注明出处，谢谢合作</p><p>这次分享的主题是《如何掌握企业级技术和项目经验》。因为和学习有关，所以我就先从学习这个话题谈起，学习方向和方式对了路子，不管多难的技术在有限的时间内都是可以攻破的。这次技术分享，我就做一回知音大姐，跟大家分享一下学习的事情。</p><p>为什么我意识到学习方法的重要性了呢？因为我在咱们慕课网的QQ群里面，发现有的同学很迷茫。技术这么多，学也学不完，更不知道应该学什么？其他讲师分享的都是某个技术某个框架，很少看到有人谈学习方法的，所以借着这次分享，我跟大家先聊一下学习的事情。</p><p>首先我们要做好学习计划，时间就按照一年来规划。每年给自己制定一个研究的方向，比如说今年我要成为数据库领域的专家；明年后年我要作Java领域的达人；大后年我要成为前端领域的小强。每年集中精力突破一个技术方向，是最容易取得成就的。</p><p>这就跟恒星诞生的过程一样，一个天体在宇宙里不停地俘获物质，增加自己质量，总有一天，到达临界点的时候，这个天体突然点亮了，发生核聚变反应，于是照亮了宇宙。学习的过程也是这样，你专攻一个领域的时候，积累了大量的学习材料，努力专研是最容易出成果的。</p><p>因为我看咱们群里很多小伙伴都是20多岁上下的样子。年轻人容易受到新事物的吸引，不容易集中注意力，往往生活中刷个抖音、逛个淘宝，打一局王者荣耀，时间就不知不觉过去了。咱们群里面不知道有没有做大数据业务的，大数据里面有个协同过滤算法很厉害，网站不需要长期跟踪你，积累用户数据，就能快速的识别出你的喜好。</p><p>比如说你刚下载了淘宝APP，不需要下订单买东西，淘宝就能找出你的喜好。假如你看一个运动鞋挺好的，点开看两眼，然后就给关上了。下次再打开淘宝APP，首页出现的商品都是你喜欢的。这就是淘宝后台利用协同过滤算法，分析出看这个运动鞋的一类人，大部分人会买什么东西，比如很多人买了篮球、充电宝、护肤品等等。所以你的APP上就会出现这类东西，然后你的购物欲就被勾引起来了，不停地买买买。抖音也是类似的原理，让你不停的看视频。</p><p>现在的年轻人在学习的时候，越来越难以集中精力了。然后更糟糕的是，学习编程技术，必须要用大段大段的时间，才有效果。你用碎片化的时间去学编程，拿过来一个框架看五分钟，然后就去聊QQ、打游戏去了。过了几个小时，再回来看学一会儿，这一天下来，跟什么都没学一样，什么东西也记不住。</p><p>人的大脑，调动理性思维让它活跃起来是需要时间的，前半个小时都是预热的过程，然后才能进入到学习的状态。所以我给大家的建议就是舍小取大，把零碎的事情都集中在一起处理，然后留出大段的时间去学习，这样的效果会非常好。</p><p>那么有的同学会说，学习这么辛苦，我坚持不下来。确实，学习是这个世界上最痛苦的事情。打游戏可比学习有意思多了，这是因为打游戏跟结果之间存在必然联系。砍死一个Boss能掉什么装备，得到多少经验，是有明确结果的。所以很多人追求这个明确的结果，不停的升级刷装备，沉迷于游戏。但是我们平时很少看见有人能沉迷于学习的，这是因为学习跟成果没有必然联系。比如说你今天背了50个单词，没人会给你承诺，四六级考试一定会考这些单词。</p><p>我们的大脑进化的还不完全，大脑只会为有明确结果的事情，分泌出多巴胺，让你感到快乐。你在做没有明确结果的事情的时候，大脑就不会分泌多巴胺，用不了多久，一件事情你就会做腻了。原始社会，物质条件很差，你要是整天不务正业，仰望星空，就容易饿死。所以大脑为了禁止你做一些消耗能量，而又不会有结果的事情，就不给你分泌多巴胺，让你感觉不到快乐，从而放弃一件事情，达到节省能量的目的。</p><p>恰恰学习就是一个没有明确结果的事情，所以从你上学的第一天起，就感受不到学习快乐，原因就在这儿。我们现在开始制定学习计划，要是一路枯燥的学习，恐怕有很多人都坚持不下去。那该怎么办呢？先找到一个参照物，然后自我鼓励。这个参照物可以是你自己，也可以是周边的人。你在学习的过程中，经常与这个参照物去比较，感知到自己的进步，就很容收获成就感。这样就把一个没有结果的事情，转化成有明确结果的事情。起码我知道我每个月的学习，都在进步。</p><p>比如说，公司目前用的是SSM单体架构。如果遇到高负载的情况下，肯定有问题。所以我应该学习一下Nginx负载均衡。等你搞明白负载均衡以后，又发现轮询式的请求转发，会造成Session丢失。比如说用户访问网站，Nginx把请求负载均衡到A节点，你在A节点登陆之后，HttpSession保存在A节点。如果刷新一下浏览器，请求被负载均衡到了B节点，B节点没有你的HTTPSession对象，于是就被判定成没有登陆。这时候就得用Redis缓存Session了，或者说把认证信息以Token的形式存储在客户端。</p><p>然后没多久，你又发现数据表记录太多了，需要缩表，要搞冷热数据分离，于是又要学习TokuDB引擎。这么一路研究下来，再跟你周围的同事比较一下，或者跟半年前的你自己，比较一下。技术水平，还有思考的维度都大不一样了，这种技术上碾压周围人的快感就是成就感。这种成就感会一路推动你后续的学习，从而走上终身学习的道路。学习是一件快乐的事情，其实很容易做到。这比会一个框架，学习一门语言，更重要。</p><p>接下来，我举一个反面的例子，相信很多同学都有过相似的经历。刚学会一个新的语言或者框架，就急不可待的虚构一个项目，立即用这种语言或者框架实现一下。比如说你刚学会Spring框架，于是就虚构了一个小型的微商系统，采用极限编程的方式，先不写文档，匆忙建了几张数据表，直接就进入到编码环节了。</p><p>过了几天，你在录入数据的时候，忽然发现有重大问题，商品表创建的不对，很难把所有商品数据都保存进入。食品有保质期属性，电视没有保质期属性。手机有操作系统属性，化妆品就没有这个属性。我建表怎么规定字段呢？不行，得重新设计数据表。一下子，SQL语句要改、PO和VO类要改、业务层要改、视图层也要改，然后还要跑一堆测试案例。你看，这是你的项目第一次推翻重来。</p><p>没过多久，你又发现了一个重大设计问题。如果订单表直接引用商品ID的话。如果顾客购买了进口奶粉，卖家偷换成了国产奶粉发货。顾客来投诉，卖家马上篡改商品信息，跟顾客说，我们卖的就是国产奶粉。电商平台绝对不可以出现这种行为，所以你又得去修改数据表结构。然后项目又推翻重来一次。</p><p>这种把项目反复退倒重来的经历，我相信很多小伙伴都有过。错误的学习实践方法，只会浪费我们大量的时间。每个人的职业生涯都是有限的，我们要在有限的时间里，学习到更多的技术，这样才不会出现中年职业危机。关于职业危机的事情，我放在后面再说。</p><p>在学习的过程中，同学们不要先着急做虚拟项目。每一个项目都不是靠单一技术实现的，所以我建议大家先充实理论知识，然后再去做项目。你掌握的技术多了，创建项目的时候，考虑的维度和深度也就到位了，具备了整合能力，所以再去做项目，基本上就可以驾驭了。</p><p>下面我来说一下，怎么选择学习方向。很多同学感叹，现在技术太多了，听上去都挺重要的，自己好像都快追赶不上了。这就需要我们抓大放小，利用有限的时间，多学习关键性的技术。</p><p>比如说技术体系里面，速成的是前端和Python方向，慢成的是Java方向。各位擅长Java的小伙伴，也都发现了，Java领域太复杂了，学起来太累了，那我们学习Java的意义何在呢？不如搞前端或者学习Python去了。其实从后台转前端和移动端，很容易；转到大数据领域也不难。但是从前端往后端转，就很困难，至少我身边前端工程师转型做后台开发的成功案例很少。所以我建议，大家在选择学习方向的时候，应该先从后端开始。</p><p>大上周有同学问我，该不该学习一下GO语言。我觉得这是一个典型的普遍性问题。面对一个冉冉升起的语言或者技术，很多人都觉得自己不应该落下。但是理性思维告诉我：抓大放小，先学习主流技术。你不妨问问自己，GO语言是不是主流语言？GO语言的就业市场有多大？GO语言的资料多不多？GO语言工程师月薪是多少？GO语言职位在北京有多少，Java工程师职位有多少？一路追问下来，虽然你感兴趣GO语言，但是还是得把学习的注意力放在主流的语言上。编程语言的老大哥Java语言，你学透彻了吗？</p><p>如果把需要研究的后台技术，排一个先后次序的话，无疑应该先从数据库开始。我知道你会用MYSQL，会写CRUD语句，这些还都太初级了，钻研的深度不够。比如说我们经常编写表连接SQL，数据库可不会按照书写的顺序去连接数据表，优化器会筛选出数据最少的表，优先查询，因为结果集数量比较少，所以连接大表的速度会很快。</p><p>当然了，这是理想的情况，有的时候SQL语句里面带上GROUP BY或者ORDER BY之后，优化器对SQL的优化就出问题了，不是小表驱动大表，这就需要我们在SQL语句里面添加STRAIGHT JOIN关键字调整表连接的顺序。一直以来我都保持手写SQL语句的习惯，对于Hibernate跟MyBatis Plus框架提供Criteria操作方式，一直都不感冒。</p><p>这些只是SQL层面的事情，还有数据库架构层面的事情。想去BATJ工作，写代码不懂得从MySQL集群中提取数据，怎么能行。所以作为一个大厂的后端程序员，操作数据库集群是个必备的工作。然而数据库集群的SQL语句跟单实例MySQL差别又很大，不能按照原有思路去想问题。</p><p>举个例子，在数据库集群中跨分片的表连接就很难实现。在水平切分的场景下，数据被切分到不同的数据库分片中。A分片具有客户表和订单表，B分片也有客户表和订单表。如果李强的客户记录被切分存储在A分片的客户表里面。李强开始在电商平台购物，他的订单如果有的被切分到A分片的订单表，有的被切分到B分片的订单表。如果这种情况下，你要查询李强等人的购物记录是不可能的。无论A分片把数据传给B分片，还是B分片把数据传给A分片做表连接，都要在网络里传输大量数据，而且查询的速度又很慢。所以就要在数据库中间件上配置父子表，客户表是父表，订单表是子表。子表的数据跟随父表，被切分到同一个分片里面。</p><p>比如李强被切分到A分片，他的所有购物记录都被切分到A分片。如果陈浩被切分到B分片，那么他的所有购物记录就连带着被切分到B分片，这样我们做表连接的时候，就不用跨分片了。分片内做表连接就能查询出数据，然后两个分片的数据汇总到MyCat，做一下合并就可以返回给客户端了。</p><p>还有就是冷热数据分离方面的事情，InnoDB引擎数据超过2000万，读写性能会很差。即便你加上很多索引也无济于事。所以我们要定期缩表，比如把1年以上的数据转移到归档库。如果冷数据也很重要，那就用TokuDB存储，带着事务写入速度是InnoDB的7-11倍。如果不是重要数据，扔到MongoDB里面就好了。</p><p>数据库是所有项目的基础，大部分人每天写程序都是围绕数据处理展开的，所以我建议你第一年应该彻底把数据库研究明白，看SQL语句优化、数据库参数优化、Replication集群、PXC集群、MHA集群、分布式事务等等。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 个人学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何掌握企业级技术和项目经验</title>
      <link href="/2020/02/11/Interview/Redis/"/>
      <url>/2020/02/11/Interview/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="我把问烂了的redis常见面试题总结了一下带答案"><a class="markdownIt-Anchor" href="#我把问烂了的redis常见面试题总结了一下带答案"></a> 我把问烂了的Redis常见面试题总结了一下（带答案）</h1><p><a href="https://blog.csdn.net/qq_35190492/article/details/103041932?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare">转载自 https://blog.csdn.net/qq_35190492</a></p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 个人学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka基本概念</title>
      <link href="/2019/03/15/Kafka&amp;RabbitMQ/Kafka%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/03/15/Kafka&amp;RabbitMQ/Kafka%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-kafka介绍"><a class="markdownIt-Anchor" href="#1-kafka介绍"></a> 1. Kafka介绍</h1><p>Apache Kafka 是一个分布式流处理平台。<br />Kafka有以下三种特性:</p><ul><li>可以发布和订阅流式的记录。这一方面与消息队列或者企业消息系统类似。</li><li>可以储存流式的记录，并且有较好的容错性。</li><li>可以在流式记录产生时就进行处理。</li></ul><p>Kafka可以用于两大类别的应用:</p><ul><li>构造实时流数据管道，它可以在系统或应用之间可靠地获取数据。 (相当于message queue)</li><li>构建实时流式应用程序，对这些流数据进行转换或者影响。 (就是流处理，通过kafka stream topic和topic之间内部进行变化)</li></ul><h2 id="11-kafka基本概念"><a class="markdownIt-Anchor" href="#11-kafka基本概念"></a> 1.1 kafka基本概念</h2><ul><li><p><strong>Topic</strong>: 逻辑概念，Kafka消息的类别，对数据区分、隔离，每一类的消息称之为一个主题（Topic）。</p></li><li><p><strong>Producer</strong>: 消息和数据的生产者，向Kafka的一个Topic发布消息的进程/代码/服务。</p></li><li><p><strong>Consumer</strong>: 消息和数据的消费者，订阅数据（Topic）并且处理其发布的消息的进程/代码/服务。</p></li><li><p><strong>Consumer Group</strong>: 逻辑概念，对于同一个Topic，会广播给不同的group，一个group中，只有一个consumer可以消费该消息。</p></li><li><p><strong>Broker</strong>: 物理概念，Kafka集群中的每个Kafka节点。</p></li><li><p><strong>Partition</strong>： 物理概念，Kafka下数据存储的基本单元。一个Topic数据，会被分散存储到多个Partition，每个Partition是有序的。</p></li><li><p><strong>Replication</strong>: 同一个Partition可能会有多个Replication，多个Replication之间数据时一样的。</p></li><li><p><strong>Replication Leader</strong>: 一个Partition的多个Replication上，需要一个Leader负责该Partition上与Producer和Consumer交互。</p></li><li><p><strong>ReplicaManager</strong>: 负责管理当前broker所有分区和副本的信息，处理KafkaController发起的一些请求，副本状态的切换、添加/读取消息等。</p></li></ul><h3 id="111-主题和日志topic和log"><a class="markdownIt-Anchor" href="#111-主题和日志topic和log"></a> 1.1.1 主题和日志（Topic和Log）</h3><p>Topic是发布的消息的类别名，一个topic可以有零个，一个或多个消费者订阅该主题的消息。对于每个topic，Kafka集群都会维护一个分区log，就像下图中所示：<br /><img src="http://qiniu.gogocoding.cn/mweb/%E5%88%86%E5%8C%BAlog.png" alt="分区log" /></p><h3 id="112-分区partition"><a class="markdownIt-Anchor" href="#112-分区partition"></a> 1.1.2 分区（Partition）</h3><p>每一个分区都是一个顺序的、不可变的消息队列， 并且可以持续的添加。分区中的消息都被分了一个序列号，称之为偏移量(offset)，在每个分区中此偏移量都是唯一的。</p><p>Kafka集群保持所有的消息，直到它们过期（无论消息是否被消费）。实际上消费者所持有的仅有的元数据就是这个offset（偏移量），也就是说offset由消费者来控制：正常情况当消费者消费消息的时候，偏移量也线性的的增加。但是实际偏移量由消费者控制，消费者可以将偏移量重置为更早的位置，重新读取消息。可以看到这种设计对消费者来说操作自如，一个消费者的操作不会影响其它消费者对此log的处理。<br /><img src="http://qiniu.gogocoding.cn/mweb/%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9.png" alt="生产消费" /></p><ul><li>每个Topic被切分为多个Partitions</li><li>消费者数目少于或等于Partition的数目</li><li>broker Group中的每一个Broker保存Topic的一个或多个Partitions</li><li>Consumer Group中的仅有一个Consumer读取Topic的一个或多个Partitions，并且是唯一的Consumer</li></ul><h3 id="113-生产者producers"><a class="markdownIt-Anchor" href="#113-生产者producers"></a> 1.1.3 生产者（Producers）</h3><p>生产者往某个Topic上发布消息。生产者也负责选择发布到Topic上的哪一个分区。最简单的方式从分区列表中轮流选择。也可以根据某种算法依照权重选择分区。开发者负责如何选择分区的算法。</p><h3 id="114-消费者consumers"><a class="markdownIt-Anchor" href="#114-消费者consumers"></a> 1.1.4 消费者（Consumers）</h3><p>通常来讲，消息模型可以分为两种， 队列和发布-订阅式。 队列的处理方式是 一组消费者从服务器读取消息，一条消息只有其中的一个消费者来处理。在发布-订阅模型中，消息被广播给所有的消费者，接收到消息的消费者都可以处理此消息。Kafka为这两种模型提供了单一的消费者抽象模型： 消费者组 （consumer group）。 消费者用一个消费者组名标记自己。 一个发布在Topic上消息被分发给此消费者组中的一个消费者。 假如所有的消费者都在一个组中，那么这就变成了queue模型。 假如所有的消费者都在不同的组中，那么就完全变成了发布-订阅模型。 更通用的， 我们可以创建一些消费者组作为逻辑上的订阅者。每个组包含数目不等的消费者， 一个组内多个消费者可以用来扩展性能和容错。</p><h3 id="115-备份replication"><a class="markdownIt-Anchor" href="#115-备份replication"></a> 1.1.5 备份（Replication）</h3><ul><li>当集群中有Broker挂掉的情况，系统可以主动地使Replicas提供服务</li><li>系统默认设置每一个Topic的replication系数为1，可以在创建Topic时单独设置</li><li>Replication的基本单位时Topic的Partition</li><li>所有的读和写都从Leader进，Followers只是做为备份</li><li>Follower必须能够及时复制Leader的数据</li><li>增加容错性与可扩展性</li></ul><h2 id="12-kafka的基本结构"><a class="markdownIt-Anchor" href="#12-kafka的基本结构"></a> 1.2. Kafka的基本结构</h2><p><img src="http://qiniu.gogocoding.cn/mweb/Kafka%E7%BB%93%E6%9E%84-2.png" alt="Kafka结构" /></p><ul><li><strong>Producer Api</strong>: 允许应用程序发送数据流到kafka集群中的topic</li><li><strong>Consumer Api</strong>: 允许应用程序从kafka集群的topic中读取数据流</li><li><strong>Streams Api</strong>: 允许从输入topic转换数据流到输出topic</li><li><strong>Connectors Api</strong>: 通过实现连接器（connector），不断地从一些源系统或应用程序中拉取数据到kafka，或从kafka提交数据到宿系统（sink system）或应用程序。</li></ul><p><img src="http://qiniu.gogocoding.cn/mweb/kafka%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84.png" alt="kafka消息结构" /></p><h2 id="13-kafka特点"><a class="markdownIt-Anchor" href="#13-kafka特点"></a> 1.3 Kafka特点</h2><ul><li>分布式<ul><li>多分区</li><li>多副本</li><li>多订阅者</li><li>基于Zookeeper调度</li></ul></li><li>高性能<ul><li>高吞吐量</li><li>低延迟</li><li>高并发</li><li>时间复杂度为O(1)</li></ul></li><li>持久性和扩展性<ul><li>数据可持久化</li><li>容错性</li><li>支持在线水平扩展</li><li>消息自动平衡</li></ul></li></ul><h1 id="2-kafka应用场景"><a class="markdownIt-Anchor" href="#2-kafka应用场景"></a> 2. Kafka应用场景</h1><ul><li><strong>消息队列</strong>：kafka更好的替换传统的消息系统，消息系统被用于各种场景（解耦数据生产者，缓存未处理的消息，等），与大多数消息系统比较，kafka有更好的吞吐量，内置分区，副本和故障转移，这有利于处理大规模的消息。在端到端延迟这一领域，kafka比得上传统的消息系统，如的ActiveMQ或RabbitMQ的。</li><li><strong>行为跟踪</strong>：kafka原本的使用场景：用户的活动追踪，网站的活动（网页游览，搜索或其他用户的操作信息）发布到不同的话题中心，这些消息可实时处理，实时监测，也可加载到Hadoop或离线处理数据仓库。</li><li><strong>元信息监控</strong>：kafka也常常用于监测数据。分布式应用程序生成的统计数据集中聚合。</li><li><strong>日志收集</strong>：Kafka抽象出文件的细节，并将日志或事件数据更清晰地抽象为消息流。这允许更低延迟的处理并更容易支持多个数据源和分布式数据消费。</li><li><strong>流处理</strong>：kafka中消息处理一般包含多个阶段。其中原始输入数据是从kafka主题消费的，然后汇总，丰富，或者以其他的方式处理转化为新主题，例如，一个推荐新闻文章，文章内容可能从“articles”主题获取；然后进一步处理内容，得到一个处理后的新内容，最后推荐给用户。这种处理是基于单个主题的实时数据流。从0.10.0.0开始，轻量，但功能强大的流处理，就可以这样进行数据处理了。</li><li><strong>事件采集</strong>：事件采集是一种应用程序的设计风格，其中状态的变化根据时间的顺序记录下来，kafka支持这种非常大的存储日志数据的场景。</li><li><strong>持久性日志</strong>：kafka可以作为一种分布式的外部日志，可帮助节点之间复制数据，并作为失败的节点来恢复数据重新同步，kafka的日志压缩功能很好的支持这种用法，这种用法类似于Apacha BookKeeper项目。</li></ul><h1 id="3-kafka安装启动"><a class="markdownIt-Anchor" href="#3-kafka安装启动"></a> 3. Kafka安装启动</h1><p><strong>1 下载镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull wurstmeister/zookeeper</span><br><span class="line">docker pull wurstmeister/kafka</span><br></pre></td></tr></table></figure><p><strong>2 启动镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name zookeeper --publish 2181:2181 --volume /etc/localtime:/etc/localtime zookeeper:latest</span><br><span class="line"></span><br><span class="line">docker run -p 9092:9092 --name kafka1 -d -e KAFKA_BROKER_ID=0 -e KAFKA_ZOOKEEPER_CONNECT=宿主机IP:2181 -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://宿主机IP:19092 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 wurstmeister/kafka:latest</span><br></pre></td></tr></table></figure><p><strong>3 创建一个主题（Topic）</strong><br />创建topic</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</span><br></pre></td></tr></table></figure><p>查看topic</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --zookeeper localhost:2181 test</span><br></pre></td></tr></table></figure><p><strong>4 发送消息</strong><br />Kafka提供了一个命令行的工具，可以从输入文件或者命令行中读取消息并发送给Kafka集群。每一行是一条消息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test</span><br><span class="line">This is a message</span><br><span class="line">This is another message</span><br></pre></td></tr></table></figure><p><strong>5 消费消息</strong><br />Kafka也提供了一个消费消息的命令行工具，将存储的信息输出出来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning</span><br><span class="line">This is a message</span><br><span class="line">This is another message</span><br></pre></td></tr></table></figure><p><strong>6 设置多个broker集群</strong></p><p><code>broker.id</code>是集群中每个节点的唯一且永久的名称，我们修改端口和日志目录是因为我们现在在同一台机器上运行，我们要防止broker在同一端口上注册和覆盖对方的数据。<br />启动2个新的kafka节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9093:9093 --name kafka2 -d -e KAFKA_BROKER_ID&#x3D;1 -e KAFKA_ZOOKEEPER_CONNECT&#x3D;宿主机IP:2181 -e KAFKA_ADVERTISED_LISTENERS&#x3D;PLAINTEXT:&#x2F;&#x2F;宿主机IP:19093 -e KAFKA_LISTENERS&#x3D;PLAINTEXT:&#x2F;&#x2F;0.0.0.0:9092 wurstmeister&#x2F;kafka:latest</span><br><span class="line"></span><br><span class="line">docker run -p 9094:9094 --name kafka3 -d -e KAFKA_BROKER_ID&#x3D;2 -e KAFKA_ZOOKEEPER_CONNECT&#x3D;宿主机IP:2181 -e KAFKA_ADVERTISED_LISTENERS&#x3D;PLAINTEXT:&#x2F;&#x2F;宿主机IP:19094 -e KAFKA_LISTENERS&#x3D;PLAINTEXT:&#x2F;&#x2F;0.0.0.0:9092 wurstmeister&#x2F;kafka:latest</span><br></pre></td></tr></table></figure><p>现在，我们创建一个新topic，把备份设置为：3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 1 --topic my-replicated-topic</span><br></pre></td></tr></table></figure><p>好了，现在我们已经有了一个集群了，我们怎么知道每个集群在做什么呢？运行命令“describe topics”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka-topics.sh --describe --zookeeper localhost:2181 --topic my-replicated-topic</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 流处理平台 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人生规划</title>
      <link href="/2019/02/11/WorkDay/%E4%BA%BA%E7%94%9F%E8%A7%84%E5%88%92/"/>
      <url>/2019/02/11/WorkDay/%E4%BA%BA%E7%94%9F%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p><strong>人们常常高估了一天所能做的事,却低估一年所能做的事</strong></p><h2 id="2020"><a class="markdownIt-Anchor" href="#2020"></a> 2020</h2><p><strong>目标：</strong></p><ol><li>掌握MySQL数据库分布式集群</li><li>掌握Redis数据库分布式集群</li><li>掌握Kafka、RabbitMQ</li><li>微服务架构</li><li>了解k8s集群管理</li><li>LeetCode 200题</li><li>研读一本经典书籍</li><li>要注意锻炼身体了，疫情过去，每周游泳一次+跑步&amp;健身两次</li><li>晋升T6 &amp; 转后端Go语言开发</li><li>工作之余好好享受家庭生活，日常带娃，每个季度带家人郊游一次，小暖喜欢海边，夏天再去一次吧。</li></ol><p><strong>结果：</strong></p><h2 id="2019"><a class="markdownIt-Anchor" href="#2019"></a> 2019</h2><p><strong>目标：</strong></p><ol><li>晋升T5</li><li>Flutter</li><li>移动端音视频</li><li>Go语言基础</li><li>Docker的使用</li><li>读一本密码学入门的书</li><li>提升自己的表达能力</li></ol><p><strong>结果：</strong></p><ul><li>[x] 1. 晋升T5； ---- 2020-01；</li><li>[x] 2. 学习并推动了Flutter技术在项目中的实践，采用脚本收集产物，远程依赖集成的方式在原有项目中集成了Flutter模块，重构了<code>用户模块</code>、<code>意见反馈模块</code>、<code>物联网场景自动化模块</code>；---- 2020-01；</li><li>[x] 3. 参与了xx摄像头项目的开发，主持了iOS端的开发任务，完成了摄像头实时流播放模块、人形检测报警视频模块、云存视频等模块的开发；---- 2019-06</li><li>[x] 4. GO语言核心语法、并发调度原理，使用Gin+MySQL+Redis+RabbitMQ+Flutter搭建了个人前后端分离的Blog； ---- 2019-10</li><li>[x] 5. Docker的常用操作；---- 2019-10</li><li>[x] 6. <a href="https://wizardforcel.gitbooks.io/practical-cryptography-for-developers-book/preface.html#preface">《Practical Cryptography for Developers》</a>；---- 2019-12</li><li>[x] 7. 在部门做了两次在线技术分享《Flutter在XX项目中的实践》、《密码学在XX项目中的实践》 ---- 2019-09 &amp; 2019-12</li></ul><h2 id="2018-2017"><a class="markdownIt-Anchor" href="#2018-2017"></a> 2018 - 2017</h2><p>初入职场的第一年，很遗憾这段时间还没有开始记录自己的人生规划。从实习生开始进入IoT领域，从T1连续升职到了T4，成为了团队的主力开发者之一，熟悉了一些IoT移动端的核心技术：各种设备配网技术如softAP、一键配网等，基于HTTP2的AVS,智能音箱、智能耳机, 设备自动化执行引擎IFTTT。</p><p>结婚啦！有了自己的家庭和宝宝。以后肩上的担子更重了，加油啊！少年！~   oh，No~  中年！</p>]]></content>
      
      
      <categories>
          
          <category> 职业规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 职业规划 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
